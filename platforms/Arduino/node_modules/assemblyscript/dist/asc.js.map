{
  "version": 3,
  "sources": ["../util/browser/fs.js", "../util/browser/module.js", "../util/browser/process.js", "../util/browser/path.js", "../util/browser/url.js", "../cli/index.js", "../util/node.js", "../util/terminal.js", "../node_modules/diff/lib/index.mjs", "../util/text.js", "../util/options.js", "../cli/index.generated.js", "../lib/binaryen.js"],
  "sourcesContent": ["export const promises = {};\n", "export function createRequire() {\n  return function require(path) {\n    throw new Error(`Cannot find module: '${path}'`);\n  };\n}\n", "export const platform = \"linux\";\n\nexport function cwd() {\n  return \".\";\n}\n\nexport function umask() {\n  return 0;\n}\n\nexport const argv = [];\n\nexport function exit(code = 0) {\n  throw Error(`exit ${code}`);\n}\n\n// https://github.com/kumavis/browser-process-hrtime v1.0.0\n//\n// Copyright 2014 kumavis\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n// this list of conditions and the following disclaimer in the documentation\n// and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nvar performance = globalThis.performance || {};\nvar performanceNow = performance.now || function() { return new Date().getTime(); };\n\nexport function hrtime(previousTimestamp) {\n  var clocktime = performanceNow.call(performance);\n  var seconds = Math.floor(clocktime * 1e-3);\n  var nanoseconds = Math.floor(clocktime * 1e6 - seconds * 1e9);\n  if (previousTimestamp) {\n    seconds -= previousTimestamp[0];\n    nanoseconds -= previousTimestamp[1];\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [ seconds, nanoseconds ];\n}\n", "import * as process from \"./process.js\";\n\n// https://github.com/browserify/path-browserify v1.0.1\n//\n// Copyright (c) 2013 James Halliday\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\n// path.resolve([from ...], to)\nexport function resolve() {\n  var resolvedPath = '';\n  var resolvedAbsolute = false;\n  var cwd;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path;\n    if (i >= 0)\n      path = arguments[i];\n    else {\n      if (cwd === undefined)\n        cwd = process.cwd();\n      path = cwd;\n    }\n\n    assertPath(path);\n\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0)\n      return '/' + resolvedPath;\n    else\n      return '/';\n  } else if (resolvedPath.length > 0) {\n    return resolvedPath;\n  } else {\n    return '.';\n  }\n}\n\nexport function normalize(path) {\n  assertPath(path);\n\n  if (path.length === 0) return '.';\n\n  var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n  var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n  // Normalize the path\n  path = normalizeStringPosix(path, !isAbsolute);\n\n  if (path.length === 0 && !isAbsolute) path = '.';\n  if (path.length > 0 && trailingSeparator) path += '/';\n\n  if (isAbsolute) return '/' + path;\n  return path;\n}\n\nexport function isAbsolute(path) {\n  assertPath(path);\n  return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n}\n\nexport function join() {\n  if (arguments.length === 0)\n    return '.';\n  var joined;\n  for (var i = 0; i < arguments.length; ++i) {\n    var arg = arguments[i];\n    assertPath(arg);\n    if (arg.length > 0) {\n      if (joined === undefined)\n        joined = arg;\n      else\n        joined += '/' + arg;\n    }\n  }\n  if (joined === undefined)\n    return '.';\n  return normalize(joined);\n}\n\nexport function relative(from, to) {\n  assertPath(from);\n  assertPath(to);\n\n  if (from === to) return '';\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return '';\n\n  if (from === \".\") return to; // FIX for 'odule.ts' (see issue #1398)\n\n  // Trim any leading backslashes\n  var fromStart = 1;\n  for (; fromStart < from.length; ++fromStart) {\n    if (from.charCodeAt(fromStart) !== 47 /*/*/)\n      break;\n  }\n  var fromEnd = from.length;\n  var fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  var toStart = 1;\n  for (; toStart < to.length; ++toStart) {\n    if (to.charCodeAt(toStart) !== 47 /*/*/)\n      break;\n  }\n  var toEnd = to.length;\n  var toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  var length = fromLen < toLen ? fromLen : toLen;\n  var lastCommonSep = -1;\n  var i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        } else if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n      break;\n    }\n    var fromCode = from.charCodeAt(fromStart + i);\n    var toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode)\n      break;\n    else if (fromCode === 47 /*/*/)\n      lastCommonSep = i;\n  }\n\n  var out = '';\n  // Generate the relative path based on the path difference between `to`\n  // and `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n      if (out.length === 0)\n        out += '..';\n      else\n        out += '/..';\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0)\n    return out + to.slice(toStart + lastCommonSep);\n  else {\n    toStart += lastCommonSep;\n    if (to.charCodeAt(toStart) === 47 /*/*/)\n      ++toStart;\n    return to.slice(toStart);\n  }\n}\n\nexport function dirname(path) {\n  assertPath(path);\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) return '//';\n  return path.slice(0, end);\n}\n\nexport function basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n  assertPath(path);\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n    if (ext.length === path.length && ext === path) return '';\n    var extIdx = ext.length - 1;\n    var firstNonSlashEnd = -1;\n    for (i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          // We saw the first non-path separator, remember this index in case\n          // we need it if the extension ends up not matching\n          matchedSlash = false;\n          firstNonSlashEnd = i + 1;\n        }\n        if (extIdx >= 0) {\n          // Try to match the explicit extension\n          if (code === ext.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              // We matched the extension, so mark this as the end of our path\n              // component\n              end = i;\n            }\n          } else {\n            // Extension does not match, so our result is the entire path\n            // component\n            extIdx = -1;\n            end = firstNonSlashEnd;\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n    return path.slice(start, end);\n  } else {\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) return '';\n    return path.slice(start, end);\n  }\n}\n\nexport function extname(path) {\n  assertPath(path);\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1)\n        startDot = i;\n      else if (preDotState !== 1)\n        preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n}\n\nexport function format(pathObject) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n  }\n  return _format('/', pathObject);\n}\n\nexport function parse(path) {\n  assertPath(path);\n\n  var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n  if (path.length === 0) return ret;\n  var code = path.charCodeAt(0);\n  var isAbsolute = code === 47 /*/*/;\n  var start;\n  if (isAbsolute) {\n    ret.root = '/';\n    start = 1;\n  } else {\n    start = 0;\n  }\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= start; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n  // We saw a non-dot character immediately before the dot\n  preDotState === 0 ||\n  // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    if (end !== -1) {\n      if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n    }\n  } else {\n    if (startPart === 0 && isAbsolute) {\n      ret.name = path.slice(1, startDot);\n      ret.base = path.slice(1, end);\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n    }\n    ret.ext = path.slice(startDot, end);\n  }\n\n  if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n  return ret;\n}\n\nexport const sep = '/';\nexport const delimiter = ':';\nexport const win32 = null;\n", "import * as path from \"./path.js\";\n\nfunction encodePathChars(filepath) {\n  return filepath\n    .replace(/%/g, \"%25\")\n    .replace(/\\\\/g, \"%5C\")\n    .replace(/\\n/g, \"%0A\")\n    .replace(/\\r/g, \"%0D\")\n    .replace(/\\t/g, \"%09\");\n}\n\nexport function pathToFileURL(filepath) {\n  let resolved = path.resolve(filepath);\n  if (\n    filepath.charCodeAt(filepath.length - 1) === /* SLASH */ 47 &&\n    resolved[resolved.length - 1] !== path.sep\n  ) {\n    resolved += \"/\";\n  }\n  const url = new URL(\"file://\");\n  url.pathname = encodePathChars(resolved);\n  return url;\n}\n", "/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Compiler frontend for node.js\n *\n * Uses the low-level API exported from src/index.ts so it works with the compiler compiled to\n * JavaScript as well as the compiler compiled to WebAssembly (eventually).\n *\n * Can also be packaged as a bundle suitable for in-browser use with the standard library injected\n * in the build step. See dist/asc.js for the bundle.\n */\n\nimport { fs, module, path, process, url } from \"../util/node.js\";\nimport { Colors } from \"../util/terminal.js\";\nimport { utf8 } from \"../util/text.js\";\nimport * as optionsUtil from \"../util/options.js\";\nimport * as generated from \"./index.generated.js\";\n\nimport binaryen from \"../lib/binaryen.js\";\nimport * as assemblyscriptJS from \"assemblyscript\";\n\n// Use the TS->JS variant by default\nlet assemblyscript = assemblyscriptJS;\n\n// Use the AS->Wasm variant as an option (experimental)\nconst wasmPos = process.argv.indexOf(\"--wasm\");\nif (~wasmPos) {\n  const wasmPath = String(process.argv[wasmPos + 1]);\n  process.argv.splice(wasmPos, 2);\n  assemblyscript = await import(new URL(wasmPath, url.pathToFileURL(process.cwd() + \"/\")));\n}\n\nconst require = module.createRequire(import.meta.url);\n\nconst WIN = process.platform === \"win32\";\nconst EOL = WIN ? \"\\r\\n\" : \"\\n\";\nconst SEP = WIN ? \"\\\\\"   : \"/\";\n\nconst extension = \".ts\";\nconst extension_d = `.d${extension}`;\nconst extension_re = new RegExp(\"\\\\\" + extension + \"$\");\nconst extension_re_except_d = new RegExp(\"^(?!.*\\\\.d\\\\\" + extension + \"$).*\\\\\" + extension + \"$\");\n\nfunction toUpperSnakeCase(str) {\n  return str.replace(/-/g, \"_\").toUpperCase();\n}\n\nfunction isNonEmptyString(value) {\n  return typeof value === \"string\" && value !== \"\";\n}\n\n/** Ensures that an object is a wrapper class instead of just a pointer. */\n// function __wrap(ptrOrObj, wrapperClass) {\n//   if (typeof ptrOrObj === \"number\") {\n//     return ptrOrObj === 0 ? null : wrapperClass.wrap(ptrOrObj);\n//   }\n//   return ptrOrObj;\n// }\n\n/** AssemblyScript version. */\nexport const version = generated.version;\n\n/** Available CLI options. */\nexport const options = generated.options;\n\n/** Prefix used for library files. */\nexport const libraryPrefix = generated.libraryPrefix;\n\n/** Bundled library files. */\nexport const libraryFiles = generated.libraryFiles;\n\n/** Bundled definition files. */\nexport const definitionFiles = generated.definitionFiles;\n\n/** Default Binaryen optimization level. */\nexport const defaultOptimizeLevel = 3;\n\n/** Default Binaryen shrink level. */\nexport const defaultShrinkLevel = 0;\n\n/** Converts a configuration object to an arguments array. */\nexport function configToArguments(options, argv = []) {\n  Object.keys(options || {}).forEach(key => {\n    const val = options[key];\n    const opt = generated.options[key];\n    if (opt && opt.type === \"b\") {\n      if (val) argv.push(`--${key}`);\n    } else {\n      if (Array.isArray(val)) {\n        val.forEach(val => { argv.push(`--${key}`, String(val)); });\n      }\n      else argv.push(`--${key}`, String(val));\n    }\n  });\n  return argv;\n}\n\n/** Convenience function that parses and compiles source strings directly. */\nexport async function compileString(sources, config = {}) {\n  if (typeof sources === \"string\") sources = { [`input${extension}`]: sources };\n  let argv = [\n    \"--outFile\", \"binary\",\n    \"--textFile\", \"text\",\n  ];\n  configToArguments(config, argv);\n  const output = {};\n  const result = await main(argv.concat(Object.keys(sources)), {\n    readFile: name => Object.prototype.hasOwnProperty.call(sources, name) ? sources[name] : null,\n    writeFile: (name, contents) => { output[name] = contents; },\n    listFiles: () => []\n  });\n  return Object.assign(result, output);\n}\n\n/** Runs the command line utility using the specified arguments array. */\nexport async function main(argv, options) {\n  if (!Array.isArray(argv)) argv = configToArguments(argv);\n  if (!options) options = {};\n\n  const stats = options.stats || new Stats();\n  const statsBegin = stats.begin();\n\n  // Bundle semantic version\n  let bundleMinorVersion = 0, bundleMajorVersion = 0, bundlePatchVersion = 0;\n  const versionParts = (version || \"\").split(\".\");\n  if (versionParts.length === 3) {\n    bundleMajorVersion = parseInt(versionParts[0]) | 0;\n    bundleMinorVersion = parseInt(versionParts[1]) | 0;\n    bundlePatchVersion = parseInt(versionParts[2]) | 0;\n  }\n\n  const stdout = options.stdout || createMemoryStream();\n  const stderr = options.stderr || createMemoryStream();\n  const readFile = options.readFile || readFileNode;\n  const writeFile = options.writeFile || writeFileNode;\n  const listFiles = options.listFiles || listFilesNode;\n\n  // Parse command line options but do not populate option defaults yet\n  const optionsResult = optionsUtil.parse(argv, generated.options, false);\n  let opts = optionsResult.options;\n  argv = optionsResult.arguments;\n\n  const stdoutColors = new Colors(stdout);\n  const stderrColors = new Colors(stderr);\n  if (opts.noColors) {\n    stdoutColors.enabled = false;\n    stderrColors.enabled = false;\n  }\n\n  // Check for unknown options\n  const unknownOpts = optionsResult.unknown;\n  if (unknownOpts.length) {\n    unknownOpts.forEach(arg => {\n      stderr.write(\n        `${stderrColors.yellow(\"WARNING \")}Unknown option '${arg}'${EOL}`\n      );\n    });\n  }\n\n  // Check for trailing arguments\n  const trailingArgv = optionsResult.trailing;\n  if (trailingArgv.length) {\n    stderr.write(\n      `${stderrColors.yellow(\"WARNING \")}Unsupported trailing arguments: ${trailingArgv.join(\" \")}${EOL}`\n    );\n  }\n\n  let module = null;\n  let binaryenModule = null;\n\n  // Prepares the result object\n  let prepareResult = (error, result = {}) => {\n    if (error) {\n      stderr.write(`${stderrColors.red(\"FAILURE \")}${error.stack.replace(/^ERROR: /i, \"\")}${EOL}`);\n    }\n    if (binaryenModule) binaryenModule.dispose();\n    if (!stats.total) stats.total = stats.end(statsBegin);\n    return Object.assign({ error, stdout, stderr, stats }, result);\n  };\n\n  // Just print the version if requested\n  if (opts.version) {\n    stdout.write(`Version ${version}${EOL}`);\n    return prepareResult(null);\n  }\n\n  // Set up base directory\n  const baseDir = path.normalize(opts.baseDir || \".\");\n\n  // Check if a config file is present\n  let configPath = optionsUtil.resolvePath(opts.config || \"asconfig.json\", baseDir);\n  let configFile = path.basename(configPath);\n  let configDir = path.dirname(configPath);\n  let config = await getConfig(configFile, configDir, readFile);\n  let configHasEntries = config != null && Array.isArray(config.entries) && config.entries.length;\n\n  // Print the help message if requested or no source files are provided\n  if (opts.help || (!argv.length && !configHasEntries)) {\n    let out = opts.help ? stdout : stderr;\n    let colors = opts.help ? stdoutColors : stderrColors;\n    out.write([\n      colors.white(\"SYNTAX\"),\n      \"  \" + colors.cyan(\"asc\") + \" [entryFile ...] [options]\",\n      \"\",\n      colors.white(\"EXAMPLES\"),\n      \"  \" + colors.cyan(\"asc\") + \" hello\" + extension,\n      \"  \" + colors.cyan(\"asc\") + \" hello\" + extension + \" -o hello.wasm -t hello.wat\",\n      \"  \" + colors.cyan(\"asc\") + \" hello1\" + extension + \" hello2\" + extension + \" -o -O > hello.wasm\",\n      \"  \" + colors.cyan(\"asc\") + \" --config asconfig.json --target release\",\n      \"\",\n      colors.white(\"OPTIONS\"),\n    ].concat(\n      optionsUtil.help(generated.options, 24, EOL)\n    ).join(EOL) + EOL);\n    return prepareResult(null);\n  }\n\n  // I/O must be specified if not present in the environment\n  if (!(fs.promises && fs.promises.readFile)) {\n    if (readFile === readFileNode)   throw Error(\"'options.readFile' must be specified\");\n    if (writeFile === writeFileNode) throw Error(\"'options.writeFile' must be specified\");\n    if (listFiles === listFilesNode) throw Error(\"'options.listFiles' must be specified\");\n  }\n\n  // Load additional options from asconfig.json\n  const seenAsconfig = new Set();\n  seenAsconfig.add(configPath);\n  const target = opts.target || \"release\";\n  while (config) {\n    // Merge target first\n    if (config.targets) {\n      const targetOptions = config.targets[target];\n      if (targetOptions) {\n        opts = optionsUtil.merge(generated.options, opts, targetOptions, configDir);\n      }\n    }\n    // Merge general options\n    const generalOptions = config.options;\n    if (generalOptions) {\n      opts = optionsUtil.merge(generated.options, opts, generalOptions, configDir);\n    }\n\n    // Append entries\n    if (config.entries) {\n      for (let entry of config.entries) {\n        argv.push(optionsUtil.resolvePath(entry, configDir));\n      }\n    }\n\n    // Look up extended asconfig and repeat\n    if (config.extends) {\n      configPath = optionsUtil.resolvePath(config.extends, configDir, true);\n      configFile = path.basename(configPath);\n      configDir = path.dirname(configPath);\n      if (seenAsconfig.has(configPath)) break;\n      seenAsconfig.add(configPath);\n      config = await getConfig(configFile, configDir, readFile);\n    } else {\n      break;\n    }\n  }\n\n  // Populate option defaults once user-defined options are set\n  optionsUtil.addDefaults(generated.options, opts);\n\n  // If showConfig print options and exit\n  if (opts.showConfig) {\n    stderr.write(JSON.stringify({\n      options: opts,\n      entries: argv\n    }, null, 2));\n    return prepareResult(null);\n  }\n\n  // create a unique set of values\n  function unique(values) {\n    return [...new Set(values)];\n  }\n\n  // Set up options\n  let program, runtime, uncheckedBehavior;\n  const compilerOptions = assemblyscript.newOptions();\n  switch (opts.runtime) {\n    case \"stub\": runtime = 0; break;\n    case \"minimal\": runtime = 1; break;\n    /* incremental */\n    default: runtime = 2; break;\n  }\n  switch (opts.uncheckedBehavior) {\n    /* default */\n    default: uncheckedBehavior = 0; break;\n    case \"never\": uncheckedBehavior = 1; break;\n    case \"always\": uncheckedBehavior = 2; break;\n  }\n  assemblyscript.setTarget(compilerOptions, 0);\n  assemblyscript.setDebugInfo(compilerOptions, !!opts.debug);\n  assemblyscript.setRuntime(compilerOptions, runtime);\n  assemblyscript.setNoAssert(compilerOptions, opts.noAssert);\n  assemblyscript.setExportMemory(compilerOptions, !opts.noExportMemory);\n  assemblyscript.setImportMemory(compilerOptions, opts.importMemory);\n  assemblyscript.setInitialMemory(compilerOptions, opts.initialMemory >>> 0);\n  assemblyscript.setMaximumMemory(compilerOptions, opts.maximumMemory >>> 0);\n  assemblyscript.setSharedMemory(compilerOptions, opts.sharedMemory);\n  assemblyscript.setImportTable(compilerOptions, opts.importTable);\n  assemblyscript.setExportTable(compilerOptions, opts.exportTable);\n  if (opts.exportStart != null) {\n    assemblyscript.setExportStart(compilerOptions, isNonEmptyString(opts.exportStart) ? opts.exportStart : \"_start\");\n  }\n  assemblyscript.setMemoryBase(compilerOptions, opts.memoryBase >>> 0);\n  assemblyscript.setTableBase(compilerOptions, opts.tableBase >>> 0);\n  assemblyscript.setSourceMap(compilerOptions, opts.sourceMap != null);\n  assemblyscript.setUncheckedBehavior(compilerOptions, uncheckedBehavior);\n  assemblyscript.setNoUnsafe(compilerOptions, opts.noUnsafe);\n  assemblyscript.setPedantic(compilerOptions, opts.pedantic);\n  assemblyscript.setLowMemoryLimit(compilerOptions, opts.lowMemoryLimit >>> 0);\n  assemblyscript.setExportRuntime(compilerOptions, opts.exportRuntime);\n  assemblyscript.setBundleVersion(compilerOptions, bundleMajorVersion, bundleMinorVersion, bundlePatchVersion);\n  if (!opts.stackSize && runtime === 2 /* incremental */) {\n    opts.stackSize = assemblyscript.DEFAULT_STACK_SIZE;\n  }\n  assemblyscript.setStackSize(compilerOptions, opts.stackSize);\n  assemblyscript.setBindingsHint(compilerOptions, opts.bindings && opts.bindings.length > 0);\n\n  // Instrument callback to perform GC\n  // prepareResult = (original => {\n  //   return function gcBeforePrepareResult(err) {\n  //     __unpin(compilerOptions);\n  //     if (program) __unpin(program);\n  //     __collect();\n  //     return original(err);\n  //   };\n  // })(prepareResult);\n\n  // Add or override aliases if specified\n  if (opts.use) {\n    let aliases = opts.use;\n    for (let i = 0, k = aliases.length; i < k; ++i) {\n      let part = aliases[i];\n      let p = part.indexOf(\"=\");\n      if (p < 0) return prepareResult(Error(`Global alias '${part}' is invalid.`));\n      let alias = part.substring(0, p).trim();\n      let name = part.substring(p + 1).trim();\n      if (!alias.length) {\n        return prepareResult(Error(`Global alias '${part}' is invalid.`));\n      }\n      assemblyscript.addGlobalAlias(compilerOptions, alias, name);\n    }\n  }\n\n  // Disable default features if specified\n  let features;\n  if ((features = opts.disable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[`FEATURE_${toUpperSnakeCase(name)}`];\n      if (!flag) return prepareResult(Error(`Feature '${name}' is unknown.`));\n      assemblyscript.setFeature(compilerOptions, flag, false);\n    }\n  }\n\n  // Enable experimental features if specified\n  if ((features = opts.enable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[`FEATURE_${toUpperSnakeCase(name)}`];\n      if (!flag) return prepareResult(Error(`Feature '${name}' is unknown.`));\n      assemblyscript.setFeature(compilerOptions, flag, true);\n    }\n  }\n\n  // Set up optimization levels\n  let optimizeLevel = 0;\n  let shrinkLevel = 0;\n  if (opts.optimize) {\n    optimizeLevel = defaultOptimizeLevel;\n    shrinkLevel = defaultShrinkLevel;\n  }\n  if (typeof opts.optimizeLevel === \"number\") optimizeLevel = opts.optimizeLevel;\n  if (typeof opts.shrinkLevel === \"number\") shrinkLevel = opts.shrinkLevel;\n  optimizeLevel = Math.min(Math.max(optimizeLevel, 0), 3);\n  shrinkLevel = Math.min(Math.max(shrinkLevel, 0), 2);\n  assemblyscript.setOptimizeLevelHints(compilerOptions, optimizeLevel, shrinkLevel);\n\n  // Initialize the program\n  program = assemblyscript.newProgram(compilerOptions);\n\n  // Collect transforms *constructors* from the `--transform` CLI flag as well\n  // as the `transform` option into the `transforms` array.\n  let transforms = [];\n  // `transform` option from `main()`\n  if (Array.isArray(options.transforms)) {\n    transforms.push(...options.transforms);\n  }\n  // `--transform` CLI flag\n  if (opts.transform) {\n    let transformArgs = unique(opts.transform);\n    for (let i = 0, k = transformArgs.length; i < k; ++i) {\n      let filename = transformArgs[i].trim();\n      let resolved;\n      let transform;\n      if (require.resolve) {\n        try {\n          resolved = require.resolve(filename, { paths: [process.cwd(), baseDir] });\n          transform = await import(url.pathToFileURL(resolved));\n          if (transform.default) transform = transform.default;\n        } catch (e1) {\n          try {\n            transform = require(resolved);\n          } catch (e2) {\n            return prepareResult(e1);\n          }\n        }\n      } else {\n        try {\n          transform = await import(new URL(filename, import.meta.url));\n          if (transform.default) transform = transform.default;\n        } catch (e) {\n          return prepareResult(e);\n        }\n      }\n      if (!transform || (typeof transform !== \"function\" && typeof transform !== \"object\")) {\n        return prepareResult(Error(\"not a transform: \" + transformArgs[i]));\n      }\n      transforms.push(transform);\n    }\n  }\n\n  // Fix up the prototype of the transforms\u2019 constructors and instantiate them.\n  try {\n    transforms = transforms.map(transform => {\n      if (typeof transform === \"function\") {\n        Object.assign(transform.prototype, {\n          program,\n          binaryen,\n          baseDir,\n          stdout,\n          stderr,\n          log: console.error,\n          readFile,\n          writeFile,\n          listFiles\n        });\n        transform = new transform();\n      }\n      return transform;\n    });\n  } catch (e) {\n    return prepareResult(e);\n  }\n\n  async function applyTransform(name, ...args) {\n    for (let i = 0, k = transforms.length; i < k; ++i) {\n      let transform = transforms[i];\n      if (typeof transform[name] === \"function\") {\n        try {\n          let start = stats.begin();\n          stats.transformCount++;\n          await transform[name](...args);\n          stats.transformTime += stats.end(start);\n        } catch (e) {\n          return e;\n        }\n      }\n    }\n  }\n\n  // Parse library files\n  Object.keys(libraryFiles).forEach(libPath => {\n    if (libPath.includes(\"/\")) return; // in sub-directory: imported on demand\n    let begin = stats.begin();\n    stats.parseCount++;\n    assemblyscript.parse(program, libraryFiles[libPath], libraryPrefix + libPath + extension, false);\n    stats.parseTime += stats.end(begin);\n  });\n  let customLibDirs = [];\n  if (opts.lib) {\n    let lib = opts.lib;\n    if (typeof lib === \"string\") lib = lib.split(\",\");\n    customLibDirs.push(...lib.map(p => p.trim()));\n    customLibDirs = unique(customLibDirs); // `lib` and `customLibDirs` may include duplicates\n    for (let i = 0, k = customLibDirs.length; i < k; ++i) { // custom\n      let libDir = customLibDirs[i];\n      let libFiles;\n      if (libDir.endsWith(extension)) {\n        libFiles = [ path.basename(libDir) ];\n        libDir = path.dirname(libDir);\n      } else {\n        libFiles = await listFiles(libDir, baseDir) || [];\n      }\n      for (let libPath of libFiles) {\n        let libText = await readFile(libPath, libDir);\n        if (libText == null) {\n          return prepareResult(Error(`Library file '${libPath}' not found.`));\n        }\n        libraryFiles[libPath.replace(extension_re, \"\")] = libText;\n        let begin = stats.begin();\n        stats.parseCount++;\n        assemblyscript.parse(program, libText, libraryPrefix + libPath, false);\n        stats.parseTime += stats.end(begin);\n      }\n    }\n  }\n  opts.path = opts.path || [];\n\n  // Maps package names to parent directory\n  const packageBases = new Map();\n\n  // Gets the file matching the specified source path, imported at the given dependee path\n  async function getFile(internalPath, dependeePath) {\n    let sourceText = null; // text reported back to the compiler\n    let sourcePath = null; // path reported back to the compiler\n\n    // Try file.ext, file/index.ext, file.d.ext\n    if (!internalPath.startsWith(libraryPrefix)) {\n      if ((sourceText = await readFile(sourcePath = internalPath + extension, baseDir)) == null) {\n        if ((sourceText = await readFile(sourcePath = internalPath + \"/index\" + extension, baseDir)) == null) {\n          // portable d.ext: uses the .js file next to it in JS or becomes an import in Wasm\n          sourcePath = internalPath + extension;\n          sourceText = await readFile(internalPath + extension_d, baseDir);\n        }\n      }\n\n    // Search library in this order: stdlib, custom lib dirs, paths\n    } else {\n      const plainName = internalPath.substring(libraryPrefix.length);\n      const indexName = `${plainName}/index`;\n      if (Object.prototype.hasOwnProperty.call(libraryFiles, plainName)) {\n        sourceText = libraryFiles[plainName];\n        sourcePath = libraryPrefix + plainName + extension;\n      } else if (Object.prototype.hasOwnProperty.call(libraryFiles, indexName)) {\n        sourceText = libraryFiles[indexName];\n        sourcePath = libraryPrefix + indexName + extension;\n      } else { // custom lib dirs\n        for (const libDir of customLibDirs) {\n          if ((sourceText = await readFile(plainName + extension, libDir)) != null) {\n            sourcePath = libraryPrefix + plainName + extension;\n            break;\n          } else {\n            if ((sourceText = await readFile(indexName + extension, libDir)) != null) {\n              sourcePath = libraryPrefix + indexName + extension;\n              break;\n            }\n          }\n        }\n        if (sourceText == null) { // paths\n          const match = internalPath.match(/^~lib\\/((?:@[^/]+\\/)?[^/]+)(?:\\/(.+))?/); // ~lib/(pkg)/(path), ~lib/(@org/pkg)/(path)\n          if (match) {\n            const packageName = match[1];\n            const filePath = match[2] || \"index\";\n            const basePath = packageBases.has(dependeePath) ? packageBases.get(dependeePath) : \".\";\n            const paths = [];\n            const parts = path.resolve(baseDir, basePath).split(SEP);\n            for (let i = parts.length, k = WIN ? 1 : 0; i >= k; --i) {\n              if (parts[i - 1] !== \"node_modules\") {\n                paths.push(`${parts.slice(0, i).join(SEP)}${SEP}node_modules`);\n              }\n            }\n            paths.push(...opts.path);\n            for (const currentDir of paths.map(p => path.relative(baseDir, p))) {\n              const plainName = filePath;\n              if ((sourceText = await readFile(path.join(currentDir, packageName, plainName + extension), baseDir)) != null) {\n                sourcePath = `${libraryPrefix}${packageName}/${plainName}${extension}`;\n                packageBases.set(sourcePath.replace(extension_re, \"\"), path.join(currentDir, packageName));\n                break;\n              }\n              const indexName = `${filePath}/index`;\n              if ((sourceText = await readFile(path.join(currentDir, packageName, indexName + extension), baseDir)) != null) {\n                sourcePath = `${libraryPrefix}${packageName}/${indexName}${extension}`;\n                packageBases.set(sourcePath.replace(extension_re, \"\"), path.join(currentDir, packageName));\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    // No such file\n    if (sourceText == null) return null;\n    return { sourceText, sourcePath };\n  }\n\n  // Gets all pending imported files from the the backlog\n  function getBacklog(paths = []) {\n    do {\n      let internalPath = assemblyscript.nextFile(program);\n      if (internalPath == null) break;\n      paths.push(internalPath);\n    } while (true);\n    return paths;\n  }\n\n  // Parses the backlog of imported files after including entry files\n  async function parseBacklog() {\n    let backlog;\n    while ((backlog = getBacklog()).length) {\n      let files = [];\n      for (let internalPath of backlog) {\n        const dependee = assemblyscript.getDependee(program, internalPath);\n        files.push(getFile(internalPath, dependee)); // queue\n      }\n      files = await Promise.all(files); // parallel\n      for (let i = 0, k = backlog.length; i < k; ++i) {\n        const internalPath = backlog[i];\n        const file = files[i];\n        const begin = stats.begin();\n        stats.parseCount++;\n        if (file) {\n          assemblyscript.parse(program, file.sourceText, file.sourcePath, false);\n        } else {\n          assemblyscript.parse(program, null, internalPath + extension, false);\n        }\n        stats.parseTime += stats.end(begin);\n      }\n    }\n    const numErrors = checkDiagnostics(program, stderr, opts.disableWarning, options.reportDiagnostic, stderrColors.enabled);\n    if (numErrors) {\n      const err = Error(`${numErrors} parse error(s)`);\n      err.stack = err.message; // omit stack\n      return prepareResult(err);\n    }\n  }\n\n  // Include runtime before entry files so its setup runs first\n  {\n    let runtimeName = String(opts.runtime);\n    let runtimePath = `rt/index-${runtimeName}`;\n    let runtimeText = libraryFiles[runtimePath];\n    if (runtimeText == null) {\n      runtimePath = runtimeName;\n      runtimeText = await readFile(runtimePath + extension, baseDir);\n      if (runtimeText == null) return prepareResult(Error(`Runtime '${path.resolve(baseDir, runtimePath + extension)}' is not found.`));\n    } else {\n      runtimePath = `~lib/${runtimePath}`;\n    }\n    let begin = stats.begin();\n    stats.parseCount++;\n    assemblyscript.parse(program, runtimeText, runtimePath + extension, true);\n    stats.parseTime += stats.end(begin);\n  }\n\n  // Include entry files\n  for (let i = 0, k = argv.length; i < k; ++i) {\n    const filename = String(argv[i]);\n\n    // Setting the path to relative path\n    let sourcePath = path.isAbsolute(filename)\n      ? path.relative(baseDir, filename)\n      : path.normalize(filename);\n\n    sourcePath = sourcePath\n      .replace(/\\\\/g, \"/\")\n      .replace(extension_re, \"\")\n      .replace(/\\/$/, \"\");\n    \n    // Try entryPath.ext, then entryPath/index.ext\n    let sourceText = await readFile(sourcePath + extension, baseDir);\n    if (sourceText == null) {\n      const path = `${sourcePath}/index${extension}`;\n      sourceText = await readFile(path, baseDir);\n      if (sourceText != null) sourcePath = path;\n      else sourcePath += extension;\n    } else {\n      sourcePath += extension;\n    }\n\n    let begin = stats.begin();\n    stats.parseCount++;\n    assemblyscript.parse(program, sourceText, sourcePath, true);\n    stats.parseTime += stats.end(begin);\n  }\n\n  // Parse entry files\n  {\n    let code = await parseBacklog();\n    if (code) return code;\n  }\n\n  // Call afterParse transform hook\n  {\n    let error = await applyTransform(\"afterParse\", program.parser);\n    if (error) return prepareResult(error);\n  }\n\n  // Parse additional files, if any\n  {\n    let code = await parseBacklog();\n    if (code) return code;\n  }\n\n  // Pre-emptively initialize the program\n  {\n    let begin = stats.begin();\n    stats.initializeCount++;\n    try {\n      assemblyscript.initializeProgram(program);\n    } catch (e) {\n      crash(\"initialize\", e);\n    }\n    stats.initializeTime += stats.end(begin);\n  }\n\n  // Call afterInitialize transform hook\n  {\n    let error = await applyTransform(\"afterInitialize\", program);\n    if (error) return prepareResult(error);\n  }\n\n  // Compile the program\n  {\n    let begin = stats.begin();\n    stats.compileCount++;\n    try {\n      module = assemblyscript.compile(program);\n    } catch (e) {\n      crash(\"compile\", e);\n    }\n    stats.compileTime += stats.end(begin);\n  }\n  // From here on we are going to use Binaryen.js\n  binaryenModule = binaryen.wrapModule(\n    typeof module === \"number\" || module instanceof Number\n      ? assemblyscript.getBinaryenModuleRef(module)\n      : module.ref\n  );\n  let numErrors = checkDiagnostics(program, stderr, opts.disableWarning, options.reportDiagnostic, stderrColors.enabled);\n  if (numErrors) {\n    const err = Error(`${numErrors} compile error(s)`);\n    err.stack = err.message; // omit stack\n    return prepareResult(err);\n  }\n\n  // Call afterCompile transform hook\n  {\n    let error = await applyTransform(\"afterCompile\", binaryenModule);\n    if (error) return prepareResult(error);\n  }\n\n  numErrors = checkDiagnostics(program, stderr, opts.disableWarning, options.reportDiagnostic, stderrColors.enabled);\n  if (numErrors) {\n    const err = Error(`${numErrors} afterCompile error(s)`);\n    err.stack = err.message; // omit stack\n    return prepareResult(err);\n  }\n\n  // Validate the module if requested\n  if (!opts.noValidate) {\n    let begin = stats.begin();\n    stats.validateCount++;\n    let isValid = assemblyscript.validate(module);\n    stats.validateTime += stats.end(begin);\n    if (!isValid) {\n      return prepareResult(Error(\"validate error\"));\n    }\n  }\n\n  // Set Binaryen-specific options\n  if (opts.trapMode === \"clamp\" || opts.trapMode === \"js\") {\n    let begin = stats.begin();\n    try {\n      binaryenModule.runPasses([`trap-mode-${opts.trapMode}`]);\n    } catch (e) {\n      crash(\"runPasses\", e);\n    }\n    stats.compileTime += stats.end(begin);\n  } else if (opts.trapMode !== \"allow\") {\n    return prepareResult(Error(\"Unsupported trap mode\"));\n  }\n\n  // Optimize the module\n  const debugInfo = opts.debug;\n  const converge = opts.converge;\n  const zeroFilledMemory = opts.importMemory\n    ? opts.zeroFilledMemory\n    : false;\n\n  const runPasses = [];\n  if (opts.runPasses) {\n    if (typeof opts.runPasses === \"string\") {\n      opts.runPasses = opts.runPasses.split(\",\");\n    }\n    if (opts.runPasses.length) {\n      opts.runPasses.forEach(pass => {\n        if (!runPasses.includes(pass = pass.trim())) {\n          runPasses.push(pass);\n        }\n      });\n    }\n  }\n\n  {\n    let begin = stats.begin();\n    try {\n      stats.optimizeCount++;\n      assemblyscript.optimize(module, optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n    } catch (e) {\n      crash(\"optimize\", e);\n    }\n    try {\n      binaryenModule.runPasses(runPasses);\n    } catch (e) {\n      crash(\"runPasses\", e);\n    }\n    if (converge) {\n      let last;\n      try {\n        let begin = stats.begin();\n        stats.emitCount++;\n        last = binaryenModule.emitBinary();\n        stats.emitTime += stats.end(begin);\n      } catch (e) {\n        crash(\"emitBinary (converge)\", e);\n      }\n      do {\n        try {\n          stats.optimizeCount++;\n          assemblyscript.optimize(module, optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n        } catch (e) {\n          crash(\"optimize (converge)\", e);\n        }\n        try {\n          binaryenModule.runPasses(runPasses);\n        } catch (e) {\n          crash(\"runPasses (converge)\", e);\n        }\n        let next;\n        try {\n          let begin = stats.begin();\n          stats.emitCount++;\n          next = binaryenModule.emitBinary();\n          stats.emitTime += stats.end(begin);\n        } catch (e) {\n          crash(\"emitBinary (converge)\", e);\n        }\n        if (next.length >= last.length) {\n          if (next.length > last.length) {\n            stderr.write(`Last converge was suboptimal.${EOL}`);\n          }\n          break;\n        }\n        last = next;\n      } while (true);\n    }\n    stats.optimizeTime += stats.end(begin);\n  }\n\n  const pending = [];\n\n  // Prepare output\n  if (!opts.noEmit) {\n    if (opts.binaryFile) {\n      // We catched lagacy field for binary output (before 0.20)\n      return prepareResult(Error(\"Usage of the --binaryFile compiler option is no longer supported. Use --outFile instead.\"));\n    }\n    let bindings = opts.bindings || [];\n    let hasStdout = false;\n    let hasOutFile = opts.outFile != null;\n    let hasTextFile = opts.textFile != null;\n    let hasOutput = hasOutFile || hasTextFile;\n    let hasFileOutput = (hasOutFile && opts.outFile.length > 0) || (hasTextFile && opts.textFile.length > 0);\n    let basepath = hasFileOutput\n      ? (opts.outFile || opts.textFile).replace(/\\.\\w+$/, \"\")\n      : null;\n    let basename = hasFileOutput\n      ? path.basename(basepath)\n      : \"output\";\n\n    assemblyscript.setBasenameHint(compilerOptions, basename);\n\n    // Write binary\n    if (opts.outFile != null) {\n      let sourceMapURL = opts.sourceMap != null\n        ? opts.sourceMap.length\n          ? opts.sourceMap\n          : `./${basename}.wasm.map`\n        : null;\n\n      let begin = stats.begin();\n      stats.emitCount++;\n      let wasm;\n      try {\n        wasm = binaryenModule.emitBinary(sourceMapURL);\n      } catch (e) {\n        crash(\"emitBinary\", e);\n      }\n      stats.emitTime += stats.end(begin);\n\n      if (opts.outFile.length) {\n        pending.push(\n          writeFile(opts.outFile, wasm.binary, baseDir)\n        );\n      } else {\n        hasStdout = true;\n        writeStdout(wasm.binary);\n      }\n\n      // Post-process source map\n      if (wasm.sourceMap != \"\") {\n        if (opts.outFile.length) {\n          let map = JSON.parse(wasm.sourceMap);\n          map.sourceRoot = `./${basename}`;\n          let contents = [];\n          for (let i = 0, k = map.sources.length; i < k; ++i) {\n            let name = map.sources[i];\n            let text = assemblyscript.getSource(program, name.replace(extension_re, \"\"));\n            if (text == null) return prepareResult(Error(`Source of file '${name}' not found.`));\n            contents[i] = text;\n          }\n          map.sourcesContent = contents;\n          pending.push(\n            writeFile(path.join(\n              path.dirname(opts.outFile),\n              path.basename(sourceMapURL)\n            ).replace(/^\\.\\//, \"\"), JSON.stringify(map), baseDir)\n          );\n        } else {\n          stderr.write(`Skipped source map (no output path)${EOL}`);\n        }\n      }\n    }\n\n    // Write text (also fallback)\n    if (opts.textFile != null || !hasOutput) {\n      let begin = stats.begin();\n      stats.emitCount++;\n      let out;\n      try {\n        // use superset text format when extension is `.wast`.\n        // Otherwise use official stack IR format (wat).\n        out = opts.textFile?.endsWith(\".wast\")\n          ? binaryenModule.emitText()\n          : binaryenModule.emitStackIR(true);\n      } catch (e) {\n        crash(\"emitText\", e);\n      }\n      stats.emitTime += stats.end(begin);\n\n      if (opts.textFile != null && opts.textFile.length) {\n        pending.push(\n          writeFile(opts.textFile, out, baseDir)\n        );\n      } else if (!hasStdout) {\n        hasStdout = true;\n        writeStdout(out);\n      }\n    }\n\n    // Write TypeScript definition\n    const bindingsEsm = bindings.includes(\"esm\");\n    const bindingsRaw = !bindingsEsm && bindings.includes(\"raw\");\n    if (bindingsEsm || bindingsRaw) {\n      if (basepath) {\n        let begin = stats.begin();\n        stats.emitCount++;\n        let source;\n        try {\n          source = assemblyscript.buildTSD(program, bindingsEsm);\n        } catch (e) {\n          crash(\"buildTSD\", e);\n        }\n        stats.emitTime += stats.end(begin);\n        pending.push(\n          writeFile(basepath + \".d.ts\", source, baseDir)\n        );\n      } else {\n        stderr.write(`Skipped TypeScript binding (no output path)${EOL}`);\n      }\n    }\n\n    // Write JavaScript bindings\n    if (bindingsEsm || bindingsRaw) {\n      if (basepath) {\n        let begin = stats.begin();\n        stats.emitCount++;\n        let source;\n        try {\n          source = assemblyscript.buildJS(program, bindingsEsm);\n        } catch (e) {\n          crash(\"buildJS\", e);\n        }\n        stats.emitTime += stats.end(begin);\n        pending.push(\n          writeFile(basepath + \".js\", source, baseDir)\n        );\n      } else {\n        stderr.write(`Skipped JavaScript binding (no output path)${EOL}`);\n      }\n    }\n  }\n\n  try {\n    await Promise.all(pending);\n  } catch (err) {\n    return prepareResult(err);\n  }\n\n  stats.total = stats.end(statsBegin);\n  if (opts.stats) stderr.write(stats.toString());\n\n  return prepareResult(null);\n\n  // Default implementation to read files on node\n  async function readFileNode(filename, baseDir) {\n    let name = path.resolve(baseDir, filename);\n    try {\n      stats.readCount++;\n      return await fs.promises.readFile(name, \"utf8\");\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Default implementation to write files on node\n  async function writeFileNode(filename, contents, baseDir) {\n    try {\n      stats.writeCount++;\n      const dirPath = path.resolve(baseDir, path.dirname(filename));\n      const filePath = path.join(dirPath, path.basename(filename));\n      await fs.promises.mkdir(dirPath, { recursive: true });\n      await fs.promises.writeFile(filePath, contents);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Default implementation to list files on node\n  async function listFilesNode(dirname, baseDir) {\n    try {\n      stats.readCount++;\n      return (await fs.promises.readdir(path.join(baseDir, dirname)))\n        .filter(file => extension_re_except_d.test(file));\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Writes to stdout\n  function writeStdout(contents) {\n    if (!writeStdout.used) {\n      writeStdout.used = true;\n      stats.writeCount++;\n    }\n    stdout.write(contents);\n  }\n\n  // Crash handler\n  function crash(stage, e) {\n    const BAR = stdoutColors.red(\"\u258C \");\n    console.error([\n      EOL,\n      BAR, \"Whoops, the AssemblyScript compiler has crashed during \", stage, \" :-(\", EOL,\n      BAR, EOL,\n      (typeof e.stack === \"string\"\n        ? [\n            BAR, \"Here is the stack trace hinting at the problem, perhaps it's useful?\", EOL,\n            BAR, EOL,\n            e.stack.replace(/^/mg, BAR), EOL\n          ]\n        : [\n            BAR, \"There is no stack trace. Perhaps a Binaryen exception above / in console?\", EOL,\n            BAR, EOL,\n            BAR, \"> \" + e.stack, EOL\n          ]\n      ).join(\"\"),\n      BAR, EOL,\n      BAR, \"If you see where the error is, feel free to send us a pull request. If not,\", EOL,\n      BAR, \"please let us know: https://github.com/AssemblyScript/assemblyscript/issues\", EOL,\n      BAR, EOL,\n      BAR, \"Thank you!\", EOL\n    ].join(\"\"));\n    process.exit(1);\n  }\n}\n\nfunction isObject(arg) {\n  return Object.prototype.toString.call(arg) === \"[object Object]\";\n}\n\nasync function getConfig(file, baseDir, readFile) {\n  const contents = await readFile(file, baseDir);\n  const location = path.join(baseDir, file);\n  if (!contents) return null;\n\n  // obtain the configuration\n  let config;\n  try {\n    config = JSON.parse(contents);\n  } catch(ex) {\n    throw new Error(`Asconfig is not valid json: ${location}`);\n  }\n\n  // validate asconfig shape\n  if (config.options && !isObject(config.options)) {\n    throw new Error(`Asconfig.options is not an object: ${location}`);\n  }\n\n  if (config.include && !Array.isArray(config.include)) {\n    throw new Error(`Asconfig.include is not an array: ${location}`);\n  }\n\n  if (config.targets) {\n    if (!isObject(config.targets)) {\n      throw new Error(`Asconfig.targets is not an object: ${location}`);\n    }\n    const targets = Object.keys(config.targets);\n    for (let i = 0; i < targets.length; i++) {\n      const target = targets[i];\n      if (!isObject(config.targets[target])) {\n        throw new Error(`Asconfig.targets.${target} is not an object: ${location}`);\n      }\n    }\n  }\n\n  if (config.extends && typeof config.extends !== \"string\") {\n    throw new Error(`Asconfig.extends is not a string: ${location}`);\n  }\n\n  return config;\n}\n\n/** Checks diagnostics emitted so far for errors. */\nexport function checkDiagnostics(program, stderr, disableWarning, reportDiagnostic, useColors) {\n  if (typeof useColors === \"undefined\" && stderr) useColors = stderr.isTTY;\n  let numErrors = 0;\n  do {\n    let diagnostic = assemblyscript.nextDiagnostic(program);\n    if (!diagnostic) break;\n    if (stderr) {\n      const isDisabledWarning = (diagnostic) => {\n        if (disableWarning == null) return false;\n        if (!disableWarning.length) return true;\n        const code = assemblyscript.getDiagnosticCode(diagnostic);\n        return disableWarning.includes(code);\n      };\n      if (assemblyscript.isError(diagnostic) || !isDisabledWarning(diagnostic)) {\n        stderr.write(assemblyscript.formatDiagnostic(diagnostic, useColors, true) + EOL + EOL);\n      }\n    }\n    if (reportDiagnostic) {\n      function wrapRange(range) {\n        return range && {\n          start: assemblyscript.getRangeStart(range),\n          end: assemblyscript.getRangeEnd(range),\n          source: wrapSource(assemblyscript.getRangeSource(range))\n        } || null;\n      }\n      function wrapSource(source) {\n        return source && {\n          normalizedPath: assemblyscript.getSourceNormalizedPath(source)\n        } || null;\n      }\n      reportDiagnostic({\n        message: assemblyscript.getDiagnosticMessage(diagnostic),\n        code: assemblyscript.getDiagnosticCode(diagnostic),\n        category: assemblyscript.getDiagnosticCategory(diagnostic),\n        range: wrapRange(assemblyscript.getDiagnosticRange(diagnostic)),\n        relatedRange: wrapRange(assemblyscript.getDiagnosticRelatedRange(diagnostic))\n      });\n    }\n    if (assemblyscript.isError(diagnostic)) ++numErrors;\n  } while (true);\n  return numErrors;\n}\n\nexport class Stats {\n  readCount = 0;\n  writeCount = 0;\n  parseTime = 0;\n  parseCount = 0;\n  initializeTime = 0;\n  initializeCount = 0;\n  compileTime = 0;\n  compileCount = 0;\n  emitTime = 0;\n  emitCount = 0;\n  validateTime = 0;\n  validateCount = 0;\n  optimizeTime = 0;\n  optimizeCount = 0;\n  transformTime = 0;\n  transformCount = 0;\n  begin() {\n    return process.hrtime();\n  }\n  end(begin) {\n    const hrtime = process.hrtime(begin);\n    return hrtime[0] * 1e9 + hrtime[1];\n  }\n  toString() {\n    const formatTime = time => time ? `${(time / 1e6).toFixed(3)} ms` : \"n/a\";\n    const keys = Object.keys(this).filter(key => key.endsWith(\"Time\")).map(key => key.substring(0, key.length - 4));\n    const times = keys.map(key => formatTime(this[`${key}Time`]));\n    const counts = keys.map(key => this[`${key}Count`].toString());\n    const keysLen = keys.reduce((current, key) => Math.max(key.length, current), 0);\n    const timesLen = times.reduce((current, time) => Math.max(time.length, current), 0);\n    const countsLen = counts.reduce((current, count) => Math.max(count.length, current), 0);\n    const totalLen = keysLen + timesLen + countsLen + 6;\n    const out = [];\n    out.push(`\u256D\u2500${\"\u2500\".repeat(totalLen)}\u2500\u256E${EOL}`);\n    const header = `Stats`;\n    out.push(`\u2502 ${header}${\" \".repeat(totalLen - header.length)} \u2502${EOL}`);\n    out.push(`\u255E\u2550${\"\u2550\".repeat(keysLen)}\u2550\u2564\u2550${\"\u2550\".repeat(timesLen)}\u2550\u2564\u2550${\"\u2550\".repeat(countsLen)}\u2550\u2561${EOL}`);\n    for (let i = 0, k = keys.length; i < k; ++i) {\n      out.push(`\u2502 ${keys[i].padEnd(keysLen)} \u2502 ${times[i].padStart(timesLen)} \u2502 ${counts[i].padStart(countsLen)} \u2502${EOL}`);\n    }\n    out.push(`\u251C\u2500${\"\u2500\".repeat(keysLen)}\u2500\u2534\u2500${\"\u2500\".repeat(timesLen)}\u2500\u2534\u2500${\"\u2500\".repeat(countsLen)}\u2500\u2524${EOL}`);\n    const totalTime = `Took ${formatTime(this.total)}`;\n    out.push(`\u2502 ${totalTime}${\" \".repeat(totalLen - totalTime.length)} \u2502${EOL}`);\n    const readsWrites = `${this.readCount} reads, ${this.writeCount} writes`;\n    out.push(`\u2502 ${readsWrites}${\" \".repeat(totalLen - readsWrites.length)} \u2502${EOL}`);\n    out.push(`\u2570\u2500${\"\u2500\".repeat(totalLen)}\u2500\u256F${EOL}`);\n    return out.join(\"\");\n  }\n}\n\nlet allocBuffer = typeof global !== \"undefined\" && global.Buffer\n  ? global.Buffer.allocUnsafe || (len => new global.Buffer(len))\n  : len => new Uint8Array(len);\n\n/** Creates a memory stream that can be used in place of stdout/stderr. */\nexport function createMemoryStream(fn) {\n  let stream = [];\n  stream.write = function(chunk) {\n    if (fn) fn(chunk);\n    if (typeof chunk === \"string\") {\n      let buffer = allocBuffer(utf8.length(chunk));\n      utf8.write(chunk, buffer, 0);\n      chunk = buffer;\n    }\n    this.push(chunk);\n  };\n  stream.reset = function() {\n    stream.length = 0;\n  };\n  stream.toBuffer = function() {\n    let offset = 0, i = 0, k = this.length;\n    while (i < k) offset += this[i++].length;\n    let buffer = allocBuffer(offset);\n    offset = i = 0;\n    while (i < k) {\n      buffer.set(this[i], offset);\n      offset += this[i].length;\n      ++i;\n    }\n    return buffer;\n  };\n  stream.toString = function() {\n    let buffer = this.toBuffer();\n    return utf8.read(buffer, 0, buffer.length);\n  };\n  return stream;\n}\n\n/** Compatible TypeScript compiler options for syntax highlighting etc. */\nexport const tscOptions = {\n  alwaysStrict: true,\n  strictNullChecks: true,\n  noImplicitAny: true,\n  noImplicitReturns: true,\n  noImplicitThis: true,\n  noEmitOnError: true,\n  noPropertyAccessFromIndexSignature: true,\n  experimentalDecorators: true,\n  target: \"esnext\",\n  noLib: true,\n  types: [],\n  allowJs: false\n};\n\nexport * as default from \"./index.js\";\n", "/**\n * @fileoverview Node.js polyfills.\n * @license Apache-2.0\n */\n\nexport const isNode = Object.prototype.toString.call(typeof globalThis.process !== 'undefined' ? globalThis.process : 0) === '[object process]';\n\nvar fs;\nvar module;\nvar path;\nvar process;\nvar url;\n\nif (isNode) {\n  fs = await import(\"fs\");\n  module = await import(\"module\");\n  path = await import(\"path\");\n  process = globalThis.process;\n  url = await import(\"url\");\n} else {\n  fs = await import(\"./browser/fs.js\");\n  module = await import(\"./browser/module.js\");\n  path = await import(\"./browser/path.js\");\n  process = await import(\"./browser/process.js\");\n  url = await import(\"./browser/url.js\");\n}\n\nexport {\n  fs,\n  module,\n  path,\n  process,\n  url\n};\n", "/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\nvar proc = typeof process !== \"undefined\" && process || {};\nvar isCI = proc.env && \"CI\" in proc.env;\n\nexport const GRAY = \"\\u001b[90m\";\nexport const RED = \"\\u001b[91m\";\nexport const GREEN = \"\\u001b[92m\";\nexport const YELLOW = \"\\u001b[93m\";\nexport const BLUE = \"\\u001b[94m\";\nexport const MAGENTA = \"\\u001b[95m\";\nexport const CYAN = \"\\u001b[96m\";\nexport const WHITE = \"\\u001b[97m\";\nexport const RESET = \"\\u001b[0m\";\n\nexport class Colors {\n  constructor(stream) {\n    this.stream = stream;\n    this.enabled = Boolean((this.stream && this.stream.isTTY) || isCI);\n  }\n  gray(text) { return this.enabled ? GRAY + text + RESET : text; }\n  red(text) { return this.enabled ? RED + text + RESET : text; }\n  green(text) { return this.enabled ? GREEN + text + RESET : text; }\n  yellow(text) { return this.enabled ? YELLOW + text + RESET : text; }\n  blue(text) { return this.enabled ? BLUE + text + RESET : text; }\n  magenta(text) { return this.enabled ? MAGENTA + text + RESET : text; }\n  cyan(text) { return this.enabled ? CYAN + text + RESET : text; }\n  white(text) { return this.enabled ? WHITE + text + RESET : text; }\n}\n\nexport const stdoutColors = new Colors(proc.stdout);\nexport const stderrColors = new Colors(proc.stderr);\n", "function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080\u201300FF\n//  - U+00D7  \u00D7 Multiplication sign\n//  - U+00F7  \u00F7 Division sign\n// Latin Extended-A, 0100\u2013017F\n// Latin Extended-B, 0180\u2013024F\n// IPA Extensions, 0250\u201302AF\n// Spacing Modifier Letters, 02B0\u201302FF\n//  - U+02C7  \u02C7 &#711;  Caron\n//  - U+02D8  \u02D8 &#728;  Breve\n//  - U+02D9  \u02D9 &#729;  Dot Above\n//  - U+02DA  \u02DA &#730;  Ring Above\n//  - U+02DB  \u02DB &#731;  Ogonek\n//  - U+02DC  \u02DC &#732;  Small Tilde\n//  - U+02DD  \u02DD &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00\u20131EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n\n  if (!diff) {\n    return;\n  }\n\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\n", "/**\n * @fileoverview Text utility.\n * @license Apache-2.0\n */\n\nimport * as Diff from \"diff\";\nimport { stdoutColors } from \"./terminal.js\";\n\nexport function utf8Length(string) {\n  var len = 0;\n  for (var i = 0, k = string.length; i < k; ++i) {\n    let c = string.charCodeAt(i);\n    if (c < 128) {\n      len += 1;\n    } else if (c < 2048) {\n      len += 2;\n    } else if ((c & 0xFC00) === 0xD800 && i + 1 < k && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nexport function utf8Read(buffer, start, end) {\n  var len = end - start;\n  if (len < 1) return \"\";\n  var parts = null,\n      chunk = [],\n      i = 0, // char offset\n      t;     // temporary\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128) {\n      chunk[i++] = t;\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n      chunk[i++] = 0xD800 + (t >> 10);\n      chunk[i++] = 0xDC00 + (t & 1023);\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n    }\n    if (i >= 8192) {\n      (parts || (parts = [])).push(String.fromCharCode(...chunk));\n      i = 0;\n    }\n  }\n  if (parts) {\n    if (i) parts.push(String.fromCharCode(...chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode(...chunk.slice(0, i));\n}\n\nexport function utf8Write(string, buffer, offset) {\n  var start = offset;\n  for (var i = 0, k = string.length; i < k; ++i) {\n    let c1 = string.charCodeAt(i), c2;\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192;\n      buffer[offset++] = c1 & 63 | 128;\n    } else if ((c1 & 0xFC00) === 0xD800 && i + 1 < k && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n      ++i;\n      buffer[offset++] = c1 >> 18 | 240;\n      buffer[offset++] = c1 >> 12 & 63 | 128;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    } else {\n      buffer[offset++] = c1 >> 12 | 224;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    }\n  }\n  return offset - start;\n}\n\nexport const utf8 = {\n  length: utf8Length,\n  read: utf8Read,\n  write: utf8Write\n};\n\nexport function diff(filename, expected, actual) {\n  const diff = Diff.structuredPatch(filename, filename, expected, actual, \"expected\", \"actual\", { context: 5 });\n  if (!diff.hunks.length) return null;\n\n  const out = [\n    '--- ' + diff.oldHeader,\n    '+++ ' + diff.newHeader\n  ];\n  for (const hunk of diff.hunks) {\n    out.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    out.push(...hunk.lines.map(line =>\n      line.charAt(0) === \"+\"\n        ? stdoutColors.green(line)\n        : line.charAt(0) === \"-\"\n        ? line = stdoutColors.red(line)\n        : line\n    ));\n  }\n\n  return out.join('\\n') + '\\n';\n}\n", "/**\n * @fileoverview Command line options utility.\n * @license Apache-2.0\n */\n\nimport { path, module } from \"./node.js\";\nimport { stdoutColors } from \"./terminal.js\";\n\nconst require = module.createRequire(import.meta.url);\n\n// type | meaning\n// -----|---------------\n// b    | boolean\n// i    | integer\n// f    | float\n// s    | string\n// I    | integer array\n// F    | float array\n// S    | string array\n\n/** Parses the specified command line arguments according to the given configuration. */\nexport function parse(argv, config, propagateDefaults = true) {\n  var options = {};\n  var unknown = [];\n  var args = [];\n  var trailing = [];\n\n  // make an alias map and initialize defaults\n  var aliases = {};\n  Object.keys(config).forEach(key => {\n    if (key.startsWith(\" \")) return;\n    var option = config[key];\n    if (option.alias != null) {\n      if (typeof option.alias === \"string\") aliases[option.alias] = key;\n      else if (Array.isArray(option.alias)) option.alias.forEach(alias => aliases[alias] = key);\n    }\n    if (propagateDefaults && option.default != null) options[key] = option.default;\n  });\n\n  // iterate over argv\n  for (var i = 0, k = (argv = argv.slice()).length; i < k; ++i) {\n    let arg = argv[i];\n    if (arg == \"--\") { ++i; break; }\n    let match = /^(?:(-\\w)(?:=(.*))?|(--\\w{2,})(?:=(.*))?)$/.exec(arg), option, key;\n    if (match) {\n      if (config[arg]) option = config[key = arg]; // exact\n      else if (match[1] != null) { // alias\n        option = config[key = aliases[match[1].substring(1)]];\n        if (option && match[2] != null) argv[i--] = match[2];\n      } else if (match[3] != null) { // full\n        option = config[key = match[3].substring(2)];\n        if (option && match[4] != null) argv[i--] = match[4];\n      }\n    } else {\n      if (arg.charCodeAt(0) == 45) option = config[key = arg]; // exact\n      else { args.push(arg); continue; } // argument\n    }\n    if (option) {\n      if (option.value) {\n        // alias setting fixed values\n        Object.keys(option.value).forEach(k => options[k] = option.value[k]);\n      } else if (option.type == null || option.type === \"b\") {\n        // boolean flag not taking a value\n        options[key] = true;\n      } else {\n        if (i + 1 < argv.length && argv[i + 1].charCodeAt(0) != 45) {\n          // non-boolean with given value\n          switch (option.type) {\n            case \"i\": options[key] = parseInt(argv[++i], 10); break;\n            case \"I\": options[key] = (options[key] || []).concat(parseInt(argv[++i], 10)); break;\n            case \"f\": options[key] = parseFloat(argv[++i]); break;\n            case \"F\": options[key] = (options[key] || []).concat(parseFloat(argv[++i])); break;\n            case \"s\": options[key] = String(argv[++i]); break;\n            case \"S\": options[key] = (options[key] || []).concat(argv[++i].split(\",\")); break;\n            default: unknown.push(arg); --i;\n          }\n        } else {\n          // non-boolean with omitted value\n          switch (option.type) {\n            case \"i\":\n            case \"f\": options[key] = option.default || 0; break;\n            case \"s\": options[key] = option.default || \"\"; break;\n            case \"I\":\n            case \"F\":\n            case \"S\": options[key] = option.default || []; break;\n            default: unknown.push(arg);\n          }\n        }\n      }\n    } else unknown.push(arg);\n  }\n  while (i < k) trailing.push(argv[i++]); // trailing\n  if (propagateDefaults) addDefaults(config, options);\n\n  return { options, unknown, arguments: args, trailing };\n}\n\n/** Generates the help text for the specified configuration. */\nexport function help(config, options) {\n  if (!options) options = {};\n  var indent = options.indent || 2;\n  var padding = options.padding || 24;\n  var eol = options.eol || \"\\n\";\n  var sbCategories = {};\n  var sbOther = [];\n  Object.keys(config).forEach(key => {\n    var option = config[key];\n    if (option.description == null) return;\n    var text = \"\";\n    while (text.length < indent) text += \" \";\n    text += \"--\" + key;\n    if (option.alias) text += \", -\" + option.alias;\n    while (text.length < padding) text += \" \";\n    var sb;\n    if (!options.noCategories && option.category) {\n      if (!(sb = sbCategories[option.category])) {\n        sbCategories[option.category] = sb = [];\n      }\n    } else {\n      sb = sbOther;\n    }\n    if (Array.isArray(option.description)) {\n      sb.push(text + option.description[0] + option.description.slice(1).map(line => {\n        for (let i = 0; i < padding; ++i) line = \" \" + line;\n        return eol + line;\n      }).join(\"\"));\n    } else sb.push(text + option.description);\n  });\n  var sb = [];\n  var hasCategories = false;\n  Object.keys(sbCategories).forEach(category => {\n    hasCategories = true;\n    sb.push(eol + \" \" + stdoutColors.gray(category) + eol);\n    sb.push(sbCategories[category].join(eol));\n  });\n  if (hasCategories && sbOther.length) {\n    sb.push(eol + \" \" + stdoutColors.gray(\"Other\") + eol);\n  }\n  sb.push(sbOther.join(eol));\n  return sb.join(eol);\n}\n\n/** Sanitizes an option value to be a valid value of the option's type. */\nfunction sanitizeValue(value, type) {\n  if (value != null) {\n    switch (type) {\n      case undefined:\n      case \"b\": return Boolean(value);\n      case \"i\": return Math.trunc(value) || 0;\n      case \"f\": return Number(value) || 0;\n      case \"s\": {\n        if (value === true) return \"\";\n        if (value === false) return null;\n        return String(value);\n      }\n      case \"I\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(v => Math.trunc(v) || 0);\n      }\n      case \"F\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(v => Number(v) || 0);\n      }\n      case \"S\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(String);\n      }\n    }\n  }\n  return undefined;\n}\n\n/** Merges two sets of options into one, preferring the current over the parent set. */\nexport function merge(config, currentOptions, parentOptions, parentBaseDir) {\n  const mergedOptions = {};\n  for (const [key, { type, mutuallyExclusive, isPath, useNodeResolution, cliOnly }] of Object.entries(config)) {\n    let currentValue = sanitizeValue(currentOptions[key], type);\n    let parentValue = sanitizeValue(parentOptions[key], type);\n    if (currentValue == null) {\n      if (parentValue != null) {\n        // only parent value present\n        if (cliOnly) continue;\n        if (Array.isArray(parentValue)) {\n          let exclude;\n          if (isPath) {\n            parentValue = parentValue.map(value => resolvePath(value, parentBaseDir, useNodeResolution));\n          }\n          if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {\n            mergedOptions[key] = parentValue.filter(value => !exclude.includes(value));\n          } else {\n            mergedOptions[key] = parentValue.slice();\n          }\n        } else {\n          if (isPath) {\n            parentValue = resolvePath(parentValue, parentBaseDir, useNodeResolution);\n          }\n          mergedOptions[key] = parentValue;\n        }\n      }\n    } else if (parentValue == null) {\n      // only current value present\n      if (Array.isArray(currentValue)) {\n        mergedOptions[key] = currentValue.slice();\n      } else {\n        mergedOptions[key] = currentValue;\n      }\n    } else {\n      // both current and parent values present\n      if (Array.isArray(currentValue)) {\n        if (cliOnly) {\n          mergedOptions[key] = currentValue.slice();\n          continue;\n        }\n        let exclude;\n        if (isPath) {\n          parentValue = parentValue.map(value => resolvePath(value, parentBaseDir, useNodeResolution));\n        }\n        if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {\n          mergedOptions[key] = [\n            ...currentValue,\n            ...parentValue.filter(value => !currentValue.includes(value) && !exclude.includes(value))\n          ];\n        } else {\n          mergedOptions[key] = [\n            ...currentValue,\n            ...parentValue.filter(value => !currentValue.includes(value)) // dedup\n          ];\n        }\n      } else {\n        mergedOptions[key] = currentValue;\n      }\n    }\n  }\n  return mergedOptions;\n}\n\n/** Normalizes a path. */\nexport function normalizePath(p) {\n  const parsed = path.parse(p);\n  if (!parsed.root) {\n    parsed.root = \"./\";\n  }\n  return path.format(parsed);\n}\n\n/** Resolves a single possibly relative path. Keeps absolute paths, otherwise prepends baseDir. */\nexport function resolvePath(p, baseDir, useNodeResolution = false) {\n  if (path.isAbsolute(p)) return p;\n  if (useNodeResolution && !p.startsWith(\".\") && require.resolve) {\n    return require.resolve(p, { paths: [ baseDir ] });\n  }\n  return normalizePath(path.join(baseDir, p));\n}\n\n/** Populates default values on a parsed options result. */\nexport function addDefaults(config, options) {\n  for (const [key, { default: defaultValue }] of Object.entries(config)) {\n    if (options[key] == null && defaultValue != null) {\n      options[key] = defaultValue;\n    }\n  }\n}\n", "// GENERATED FILE. DO NOT EDIT.\n\nexport const version = \"0.27.29\";\nexport const options = {\n  \"version\": {\n    \"category\": \"General\",\n    \"description\": \"Prints just the compiler's version and exits.\",\n    \"type\": \"b\",\n    \"alias\": \"v\"\n  },\n  \"help\": {\n    \"category\": \"General\",\n    \"description\": \"Prints this message and exits.\",\n    \"type\": \"b\",\n    \"alias\": \"h\"\n  },\n  \"config\": {\n    \"category\": \"General\",\n    \"description\": \"Configuration file to apply. CLI arguments take precedence.\",\n    \"type\": \"s\",\n    \"cliOnly\": true\n  },\n  \"target\": {\n    \"category\": \"General\",\n    \"description\": \"Configuration file target to use. Defaults to 'release'.\",\n    \"type\": \"s\",\n    \"cliOnly\": true\n  },\n  \"optimize\": {\n    \"category\": \"Optimization\",\n    \"description\": [\n      \"Optimizes the module. Typical shorthands are:\",\n      \"\",\n      \" Default optimizations   -O\",\n      \" Make a release build    -O --noAssert\",\n      \" Make a debug build      --debug\",\n      \" Optimize for speed      -Ospeed\",\n      \" Optimize for size       -Osize\",\n      \"\"\n    ],\n    \"type\": \"b\",\n    \"alias\": \"O\"\n  },\n  \"optimizeLevel\": {\n    \"category\": \"Optimization\",\n    \"description\": \"How much to focus on optimizing code. [0-3]\",\n    \"type\": \"i\"\n  },\n  \"shrinkLevel\": {\n    \"category\": \"Optimization\",\n    \"description\": \"How much to focus on shrinking code size. [0-2, s=1, z=2]\",\n    \"type\": \"i\"\n  },\n  \"converge\": {\n    \"category\": \"Optimization\",\n    \"description\": \"Re-optimizes until no further improvements can be made.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"noAssert\": {\n    \"category\": \"Optimization\",\n    \"description\": \"Replaces assertions with just their value without trapping.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"outFile\": {\n    \"category\": \"Output\",\n    \"description\": \"Specifies the WebAssembly output file (.wasm).\",\n    \"type\": \"s\",\n    \"alias\": \"o\",\n    \"isPath\": true\n  },\n  \"textFile\": {\n    \"category\": \"Output\",\n    \"description\": \"Specifies the WebAssembly text output file (.wat).\",\n    \"type\": \"s\",\n    \"alias\": \"t\",\n    \"isPath\": true\n  },\n  \"bindings\": {\n    \"category\": \"Output\",\n    \"description\": [\n      \"Specifies the bindings to generate (.js + .d.ts).\",\n      \"\",\n      \"  esm  JavaScript bindings & typings for ESM integration.\",\n      \"  raw  Like esm, but exports just the instantiate function.\",\n      \"       Useful where modules are meant to be instantiated\",\n      \"       multiple times or non-ESM imports must be provided.\"\n    ],\n    \"type\": \"S\",\n    \"alias\": \"b\"\n  },\n  \"sourceMap\": {\n    \"category\": \"Debugging\",\n    \"description\": [\n      \"Enables source map generation. Optionally takes the URL\",\n      \"used to reference the source map from the binary file.\"\n    ],\n    \"type\": \"s\"\n  },\n  \"uncheckedBehavior\": {\n    \"category\": \"Debugging\",\n    \"description\": [\n      \"Changes the behavior of unchecked() expressions.\",\n      \"Using this option can potentially cause breakage.\",\n      \"\",\n      \"  default  The default behavior: unchecked operations are\",\n      \"           only used inside of unchecked().\",\n      \"  never    Unchecked operations are never used, even when\",\n      \"           inside of unchecked().\",\n      \"  always   Unchecked operations are always used if possible,\",\n      \"           whether or not unchecked() is used.\"\n    ],\n    \"type\": \"s\",\n    \"default\": \"default\"\n  },\n  \"debug\": {\n    \"category\": \"Debugging\",\n    \"description\": \"Enables debug information in emitted binaries.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"importMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Imports the memory from 'env.memory'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"noExportMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Does not export the memory as 'memory'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"initialMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Sets the initial memory size in pages.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"maximumMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Sets the maximum memory size in pages.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"sharedMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Declare memory as shared. Requires maximumMemory.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"zeroFilledMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Assume imported memory is zeroed. Requires importMemory.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"importTable\": {\n    \"category\": \"Features\",\n    \"description\": \"Imports the function table from 'env.table'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"exportTable\": {\n    \"category\": \"Features\",\n    \"description\": \"Exports the function table as 'table'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"exportStart\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Exports the start function using the specified name instead\",\n      \"of calling it implicitly. Useful to obtain the exported memory\",\n      \"before executing any code accessing it.\"\n    ],\n    \"type\": \"s\"\n  },\n  \"runtime\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Specifies the runtime variant to include in the program.\",\n      \"\",\n      \" incremental  TLSF + incremental GC (default)\",\n      \" minimal      TLSF + lightweight GC invoked externally\",\n      \" stub         Minimal runtime stub (never frees)\",\n      \" ...          Path to a custom runtime implementation\",\n      \"\"\n    ],\n    \"type\": \"s\",\n    \"default\": \"incremental\"\n  },\n  \"exportRuntime\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Always exports the runtime helpers (__new, __collect, __pin etc.).\",\n      \"Automatically determined when generation of --bindings is enabled.\"\n    ],\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"stackSize\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Overrides the stack size. Only relevant for incremental GC\",\n      \"or when using a custom runtime that requires stack space.\",\n      \"Defaults to 0 without and to 32768 with incremental GC.\"\n    ],\n    \"default\": 0,\n    \"type\": \"i\"\n  },\n  \"enable\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Enables WebAssembly features being disabled by default.\",\n      \"\",\n      \" threads             Threading and atomic operations.\",\n      \" simd                SIMD types and operations.\",\n      \" reference-types     Reference types and operations.\",\n      \" gc                  Garbage collection (WIP).\",\n      \" stringref           String reference types.\",\n      \" relaxed-simd        Relaxed SIMD operations.\",\n      \"\"\n    ],\n    \"TODO_doesNothingYet\": [\n      \" exception-handling  Exception handling.\",\n      \" tail-calls          Tail call operations.\",\n      \" multi-value         Multi value types.\",\n      \" memory64            Memory64 operations.\",\n      \" extended-const      Extended const expressions.\"\n    ],\n    \"type\": \"S\",\n    \"mutuallyExclusive\": \"disable\"\n  },\n  \"disable\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Disables WebAssembly features being enabled by default.\",\n      \"\",\n      \" mutable-globals     Mutable global imports and exports.\",\n      \" sign-extension      Sign-extension operations\",\n      \" nontrapping-f2i     Non-trapping float to integer ops.\",\n      \" bulk-memory         Bulk memory operations.\",\n      \"\"\n    ],\n    \"type\": \"S\",\n    \"mutuallyExclusive\": \"enable\"\n  },\n  \"use\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Aliases a global object under another name, e.g., to switch\",\n      \"the default 'Math' implementation used: --use Math=JSMath\",\n      \"Can also be used to introduce an integer constant.\"\n    ],\n    \"type\": \"S\",\n    \"alias\": \"u\"\n  },\n  \"lowMemoryLimit\": {\n    \"category\": \"Features\",\n    \"description\": \"Enforces very low (<64k) memory constraints.\",\n    \"default\": 0,\n    \"type\": \"i\"\n  },\n  \"memoryBase\": {\n    \"category\": \"Linking\",\n    \"description\": \"Sets the start offset of emitted memory segments.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"tableBase\": {\n    \"category\": \"Linking\",\n    \"description\": \"Sets the start offset of emitted table elements.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"transform\": {\n    \"category\": \"API\",\n    \"description\": \"Specifies the path to a custom transform to load.\",\n    \"type\": \"S\",\n    \"isPath\": true,\n    \"useNodeResolution\": true\n  },\n  \"trapMode\": {\n    \"category\": \"Binaryen\",\n    \"description\": [\n      \"Sets the trap mode to use.\",\n      \"\",\n      \" allow  Allow trapping operations. This is the default.\",\n      \" clamp  Replace trapping operations with clamping semantics.\",\n      \" js     Replace trapping operations with JS semantics.\",\n      \"\"\n    ],\n    \"type\": \"s\",\n    \"default\": \"allow\"\n  },\n  \"runPasses\": {\n    \"category\": \"Binaryen\",\n    \"description\": [\n      \"Specifies additional Binaryen passes to run after other\",\n      \"optimizations, if any. See: Binaryen/src/passes/pass.cpp\"\n    ],\n    \"type\": \"s\"\n  },\n  \"noValidate\": {\n    \"category\": \"Binaryen\",\n    \"description\": \"Skips validating the module using Binaryen.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"baseDir\": {\n    \"description\": \"Specifies the base directory of input and output files.\",\n    \"type\": \"s\",\n    \"default\": \".\"\n  },\n  \"noColors\": {\n    \"description\": \"Disables terminal colors.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"noUnsafe\": {\n    \"description\": [\n      \"Disallows the use of unsafe features in user code.\",\n      \"Does not affect library files and external modules.\"\n    ],\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"disableWarning\": {\n    \"description\": [\n      \"Disables warnings matching the given diagnostic code.\",\n      \"If no diagnostic code is given, all warnings are disabled.\"\n    ],\n    \"type\": \"I\"\n  },\n  \"noEmit\": {\n    \"description\": \"Performs compilation as usual but does not emit code.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"showConfig\": {\n    \"description\": \"Print computed compiler options and exit.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"stats\": {\n    \"description\": \"Prints statistics on I/O and compile times.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"pedantic\": {\n    \"description\": \"Make yourself sad for no good reason.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"lib\": {\n    \"description\": [\n      \"Adds one or multiple paths to custom library components and\",\n      \"uses exports of all top-level files at this path as globals.\"\n    ],\n    \"type\": \"S\",\n    \"isPath\": true\n  },\n  \"path\": {\n    \"description\": [\n      \"Adds one or multiple paths to package resolution, similar\",\n      \"to node_modules. Prefers an 'ascMain' entry in a package's\",\n      \"package.json and falls back to an inner 'assembly/' folder.\"\n    ],\n    \"type\": \"S\",\n    \"isPath\": true\n  },\n  \"wasm\": {\n    \"description\": \"Uses the specified Wasm binary of the compiler.\",\n    \"type\": \"s\"\n  },\n  \" ...\": {\n    \"description\": \"Specifies node.js options (CLI only). See: node --help\"\n  },\n  \"-Os\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-Oz\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O0\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O1\": {\n    \"value\": {\n      \"optimizeLevel\": 1,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O2\": {\n    \"value\": {\n      \"optimizeLevel\": 2,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O3\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O0s\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O1s\": {\n    \"value\": {\n      \"optimizeLevel\": 1,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O2s\": {\n    \"value\": {\n      \"optimizeLevel\": 2,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O3s\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O0z\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O1z\": {\n    \"value\": {\n      \"optimizeLevel\": 1,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O2z\": {\n    \"value\": {\n      \"optimizeLevel\": 2,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O3z\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-Ospeed\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-Osize\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 2,\n      \"converge\": true\n    }\n  },\n  \"--measure\": {\n    \"value\": {\n      \"stats\": true\n    }\n  }\n};\nexport const libraryPrefix = \"~lib/\";\nexport const libraryFiles = {\n  \"array\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { BLOCK_MAXSIZE } from \\\"./rt/common\\\";\\nimport { Runtime } from \\\"shared/runtime\\\";\\nimport { COMPARATOR, SORT } from \\\"./util/sort\\\";\\nimport { REVERSE, FILL } from \\\"./util/bytes\\\";\\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \\\"./util/string\\\";\\nimport { idof, isArray as builtin_isArray } from \\\"./builtins\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \\\"./util/error\\\";\\n\\n// @ts-ignore: decorator\\n@inline @lazy const MIN_SIZE: usize = 8;\\n\\n/** Ensures that the given array has _at least_ the specified backing size. */\\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\\n  // Depends on the fact that Arrays mimic ArrayBufferView\\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\\n  if (newSize > oldCapacity >>> alignLog2) {\\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\\n    // Grows old capacity by factor of two.\\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\\n    let newData = __renew(oldData, newCapacity);\\n    // __new / __renew already init memory range as zeros in Incremental runtime.\\n    // So try to avoid this.\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\\n    }\\n    if (newData != oldData) { // oldData has been free'd\\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\\\"buffer\\\"));\\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\\\"dataStart\\\"));\\n      __link(array, changetype<usize>(newData), false);\\n    }\\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\\\"byteLength\\\"));\\n  }\\n}\\n\\nexport class Array<T> {\\n  [key: number]: T;\\n\\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\\n\\n  private buffer: ArrayBuffer;\\n  @unsafe readonly dataStart: usize;\\n  private byteLength: i32; // Uses here as capacity\\n\\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\\n  // type-safety anymore. For lack of a better word, such an array is \\\"holey\\\".\\n\\n  private length_: i32;\\n\\n  static isArray<U>(value: U): bool {\\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\\n  }\\n\\n  static create<T>(capacity: i32 = 0): Array<T> {\\n    WARNING(\\\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\\\");\\n    let array = new Array<T>(capacity);\\n    array.length = 0;\\n    return array;\\n  }\\n\\n  constructor(length: i32 = 0) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\\n    // reserve capacity for at least MIN_SIZE elements\\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\\n    }\\n    this.buffer = buffer; // links\\n    this.dataStart = changetype<usize>(buffer);\\n    this.byteLength = <i32>bufferSize;\\n    this.length_ = length;\\n  }\\n\\n  get length(): i32 {\\n    return this.length_;\\n  }\\n\\n  set length(newLength: i32) {\\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\\n    this.length_ = newLength;\\n  }\\n\\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\\n    }\\n    return true;\\n  }\\n\\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\\n    for (let i = this.length_ - 1; i >= 0; --i) {\\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  @operator(\\\"[]\\\") private __get(index: i32): T {\\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\") private __uget(index: i32): T {\\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\\n  }\\n\\n  @operator(\\\"[]=\\\") private __set(index: i32, value: T): void {\\n    if (<u32>index >= <u32>this.length_) {\\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\\n      this.length_ = index + 1;\\n    }\\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\\n    if (isManaged<T>()) {\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    }\\n  }\\n\\n  at(index: i32): T {\\n    let len = this.length_;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\\n    if (isManaged<T>()) {\\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\\n      __link(changetype<usize>(this), changetype<usize>(value), false);\\n    } else {\\n      FILL<T>(this.dataStart, this.length_, value, start, end);\\n    }\\n    return this;\\n  }\\n\\n  includes(value: T, fromIndex: i32 = 0): bool {\\n    if (isFloat<T>()) {\\n      let len = this.length_;\\n      if (len == 0 || fromIndex >= len) return false;\\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\\n      let ptr = this.dataStart;\\n      while (fromIndex < len) {\\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\\n        // @ts-ignore\\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\\n        ++fromIndex;\\n      }\\n      return false;\\n    } else {\\n      return this.indexOf(value, fromIndex) >= 0;\\n    }\\n  }\\n\\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\\n    let len = this.length_;\\n    if (len == 0 || fromIndex >= len) return -1;\\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\\n    let ptr = this.dataStart;\\n    while (fromIndex < len) {\\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      ++fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\\n    let len = this.length_;\\n    if (len == 0) return -1;\\n    if (fromIndex < 0) fromIndex = len + fromIndex;\\n    else if (fromIndex >= len) fromIndex = len - 1;\\n    let ptr = this.dataStart;\\n    while (fromIndex >= 0) {\\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      --fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  push(value: T): i32 {\\n    let oldLen = this.length_;\\n    let len = oldLen + 1;\\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\\n    if (isManaged<T>()) {\\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    } else {\\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\\n    }\\n    this.length_ = len;\\n    return len;\\n  }\\n\\n  concat(other: Array<T>): Array<T> {\\n    let thisLen = this.length_;\\n    let otherLen = other.length_;\\n    let outLen = thisLen + otherLen;\\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\\n    let outStart = out.dataStart;\\n    let thisSize = <usize>thisLen << alignof<T>();\\n    if (isManaged<T>()) {\\n      let thisStart = this.dataStart;\\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\\n        let ref = load<usize>(thisStart + offset);\\n        store<usize>(outStart + offset, ref);\\n        __link(changetype<usize>(out), ref, true);\\n      }\\n      outStart += thisSize;\\n      let otherStart = other.dataStart;\\n      let otherSize = <usize>otherLen << alignof<T>();\\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\\n        let ref = load<usize>(otherStart + offset);\\n        store<usize>(outStart + offset, ref);\\n        __link(changetype<usize>(out), ref, true);\\n      }\\n    } else {\\n      memory.copy(outStart, this.dataStart, thisSize);\\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\\n    }\\n    return out;\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\\n    let ptr = this.dataStart;\\n    let len = this.length_;\\n\\n    end = min<i32>(end, len);\\n\\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\\n    let count = min(last - from, len - to);\\n\\n    memory.copy( // is memmove\\n      ptr + (<usize>to << alignof<T>()),\\n      ptr + (<usize>from << alignof<T>()),\\n      <usize>count << alignof<T>()\\n    );\\n    return this;\\n  }\\n\\n  pop(): T {\\n    let len = this.length_;\\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\\n    this.length_ = len;\\n    return val;\\n  }\\n\\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n    }\\n  }\\n\\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\\n    let len = this.length_;\\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\\n    let outStart = out.dataStart;\\n    for (let i = 0; i < min(len, this.length_); ++i) {\\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\\n      if (isManaged<U>()) {\\n        __link(changetype<usize>(out), changetype<usize>(result), true);\\n      }\\n    }\\n    return out;\\n  }\\n\\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\\n      if (fn(value, i, this)) result.push(value);\\n    }\\n    return result;\\n  }\\n\\n  reduce<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  reduceRight<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = this.length_ - 1; i >= 0; --i) {\\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  shift(): T {\\n    let len = this.length_;\\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\\n    let base = this.dataStart;\\n    let element = load<T>(base);\\n    let lastIndex = len - 1;\\n    memory.copy(\\n      base,\\n      base + sizeof<T>(),\\n      <usize>lastIndex << alignof<T>()\\n    );\\n    if (isReference<T>()) {\\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\\n    } else {\\n      // @ts-ignore\\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\\n    }\\n    this.length_ = lastIndex;\\n    return element;\\n  }\\n\\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\\n    }\\n    return false;\\n  }\\n\\n  unshift(value: T): i32 {\\n    let len = this.length_ + 1;\\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\\n    let ptr = this.dataStart;\\n    memory.copy(\\n      ptr + sizeof<T>(),\\n      ptr,\\n      <usize>(len - 1) << alignof<T>()\\n    );\\n    store<T>(ptr, value);\\n    if (isManaged<T>()) {\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    }\\n    this.length_ = len;\\n    return len;\\n  }\\n\\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\\n    let len = this.length_;\\n    start = start < 0 ? max(start + len, 0) : min(start, len);\\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\\n    len = max(end - start, 0);\\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\\n    let sliceBase = slice.dataStart;\\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\\n    if (isManaged<T>()) {\\n      let off = <usize>0;\\n      let end = <usize>len << alignof<usize>();\\n      while (off < end) {\\n        let ref = load<usize>(thisBase + off);\\n        store<usize>(sliceBase + off, ref);\\n        __link(changetype<usize>(slice), ref, true);\\n        off += sizeof<usize>();\\n      }\\n    } else {\\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\\n    }\\n    return slice;\\n  }\\n\\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\\n    let len = this.length_;\\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\\n    let resultStart = result.dataStart;\\n    let thisStart = this.dataStart;\\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\\n    memory.copy(\\n      resultStart,\\n      thisBase,\\n      <usize>deleteCount << alignof<T>()\\n    );\\n    let offset = start + deleteCount;\\n    if (len != offset) {\\n      memory.copy(\\n        thisBase,\\n        thisStart + (<usize>offset << alignof<T>()),\\n        <usize>(len - offset) << alignof<T>()\\n      );\\n    }\\n    this.length_ = len - deleteCount;\\n    return result;\\n  }\\n\\n  reverse(): Array<T> {\\n    REVERSE<T>(this.dataStart, this.length_);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\\n    SORT<T>(this.dataStart, this.length_, comparator);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    let ptr = this.dataStart;\\n    let len = this.length_;\\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\\n    }\\n    // For rest objects and arrays use general join routine\\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\\n    ERROR(\\\"unspported element type\\\");\\n    return <string>unreachable();\\n  }\\n\\n  flat(): T {\\n    if (!isArray<T>()) {\\n      ERROR(\\\"Cannot call flat() on Array<T> where T is not an Array.\\\");\\n    }\\n    // Get the length and data start values\\n    let ptr = this.dataStart;\\n    let len = this.length_;\\n\\n    // calculate the end size with an initial pass\\n    let size = 0;\\n    for (let i = 0; i < len; ++i) {\\n      let child = load<usize>(ptr + (i << alignof<T>()));\\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\\\"length_\\\"));\\n    }\\n\\n    // calculate the byteLength of the resulting backing ArrayBuffer\\n    const align = alignof<valueof<T>>();\\n    let byteLength = <usize>size << align;\\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\\n\\n    // create the return value and initialize it\\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\\\"length_\\\"));\\n\\n    // byteLength, dataStart, and buffer are all readonly\\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\\\"byteLength\\\"));\\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\\\"dataStart\\\"));\\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\\\"buffer\\\"));\\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\\n\\n    // set the elements\\n    let resultOffset: usize = 0;\\n    for (let i = 0; i < len; ++i) { // for each child\\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\\n\\n      // ignore null arrays\\n      if (!child) continue;\\n\\n      // copy the underlying buffer data to the result buffer\\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\\\"length_\\\")) << align;\\n      memory.copy(\\n        changetype<usize>(outBuffer) + resultOffset,\\n        load<usize>(child, offsetof<T>(\\\"dataStart\\\")),\\n        childDataLength\\n      );\\n\\n      // advance the result length\\n      resultOffset += childDataLength;\\n    }\\n\\n    // if the `valueof<T>` type is managed, we must link each reference\\n    if (isManaged<valueof<T>>()) {\\n      for (let i = 0; i < size; ++i) {\\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\\n        __link(changetype<usize>(outBuffer), ref, true);\\n      }\\n    }\\n\\n    return outArray;\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    if (isManaged<T>()) {\\n      let cur = this.dataStart;\\n      let end = cur + (<usize>this.length_ << alignof<T>());\\n      while (cur < end) {\\n        let val = load<usize>(cur);\\n        if (val) __visit(val, cookie);\\n        cur += sizeof<usize>();\\n      }\\n    }\\n    __visit(changetype<usize>(this.buffer), cookie);\\n  }\\n}\\n\",\n  \"arraybuffer\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \\\"./rt/common\\\";\\nimport { Runtime } from \\\"shared/runtime\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { E_INVALIDLENGTH } from \\\"./util/error\\\";\\n\\nexport abstract class ArrayBufferView {\\n\\n  readonly buffer: ArrayBuffer;\\n  @unsafe readonly dataStart: usize;\\n  readonly byteLength: i32;\\n\\n  get byteOffset(): i32 {\\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\\n  }\\n\\n  protected constructor(length: i32, alignLog2: i32) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\\n    }\\n    this.buffer = buffer; // links\\n    this.dataStart = changetype<usize>(buffer);\\n    this.byteLength = length;\\n  }\\n}\\n\\n@final export class ArrayBuffer {\\n\\n  static isView<T>(value: T): bool {\\n    if (isNullable<T>()) {\\n      if (changetype<usize>(value) == 0) return false;\\n    }\\n    if (value instanceof Int8Array) return true;\\n    if (value instanceof Uint8Array) return true;\\n    if (value instanceof Uint8ClampedArray) return true;\\n    if (value instanceof Int16Array) return true;\\n    if (value instanceof Uint16Array) return true;\\n    if (value instanceof Int32Array) return true;\\n    if (value instanceof Uint32Array) return true;\\n    if (value instanceof Int64Array) return true;\\n    if (value instanceof Uint64Array) return true;\\n    if (value instanceof Float32Array) return true;\\n    if (value instanceof Float64Array) return true;\\n    if (value instanceof DataView) return true;\\n    return false;\\n  }\\n\\n  constructor(length: i32) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\\n    }\\n    return buffer;\\n  }\\n\\n  get byteLength(): i32 {\\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\\n    let length = this.byteLength;\\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\\n    let outSize = <usize>max(end - begin, 0);\\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\\n    return out;\\n  }\\n\\n  toString(): string {\\n    return \\\"[object ArrayBuffer]\\\";\\n  }\\n}\\n\",\n  \"atomics\": \"import { ArrayBufferView } from \\\"./arraybuffer\\\";\\nimport { E_INDEXOUTOFRANGE } from \\\"./util/error\\\";\\n\\nexport namespace Atomics {\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function load<T extends ArrayBufferView>(array: T, index: i32): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.load<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function store<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): void {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    atomic.store<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function add<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.add<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function sub<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.sub<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function and<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.and<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function or<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.or<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function xor<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.xor<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function exchange<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.xchg<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function compareExchange<T extends ArrayBufferView>(\\n    array: T,\\n    index: i32,\\n    expectedValue: valueof<T>,\\n    replacementValue: valueof<T>\\n  ): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.cmpxchg<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      expectedValue,\\n      replacementValue\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function wait<T extends ArrayBufferView>(array: T, value: valueof<T>, timeout: i64 = -1): AtomicWaitResult {\\n    return atomic.wait<valueof<T>>(changetype<usize>(array.buffer) + array.byteOffset, value, timeout);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function notify<T extends ArrayBufferView>(array: T, index: i32, count: i32 = -1): i32 {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.notify(changetype<usize>(array.buffer) + (index << align) + array.byteOffset, count);\\n  }\\n\\n  export function isLockFree(size: usize): bool {\\n    return size == 1 || size == 2 || size == 4;\\n  }\\n}\\n\",\n  \"bindings/asyncify\": \"@unmanaged\\nexport class StackDescriptor {\\n  /** The index in linear memory of the start of the \u201Casyncify stack\u201D. */\\n  stackStart: usize;\\n  /** The index of the end of that stack region, which implies how big it is. */\\n  stackEnd: usize;\\n}\\n\\n/** Starts to unwind the call stack. */\\nexport declare function start_unwind(data: StackDescriptor): void;\\n/** Stops unwinding the call stack. */\\nexport declare function stop_unwind(): void;\\n/** Starts to rewind the call stack. */\\nexport declare function start_rewind(data: StackDescriptor): void;\\n/** Stops rewinding the call stack. */\\nexport declare function stop_rewind(): void;\\n\",\n  \"bindings/dom\": \"@external(\\\"env\\\", \\\"globalThis\\\")\\nexport declare const globalThis: externref;\\n\\nexport declare namespace Math {\\n  @external(\\\"env\\\", \\\"Math.E\\\")\\n  export const E: f64;\\n  @external(\\\"env\\\", \\\"Math.LN2\\\")\\n  export const LN2: f64;\\n  @external(\\\"env\\\", \\\"Math.LN10\\\")\\n  export const LN10: f64;\\n  @external(\\\"env\\\", \\\"Math.LOG2E\\\")\\n  export const LOG2E: f64;\\n  @external(\\\"env\\\", \\\"Math.LOG10E\\\")\\n  export const LOG10E: f64;\\n  @external(\\\"env\\\", \\\"Math.PI\\\")\\n  export const PI: f64;\\n  @external(\\\"env\\\", \\\"Math.SQRT1_2\\\")\\n  export const SQRT1_2: f64;\\n  @external(\\\"env\\\", \\\"Math.SQRT2\\\")\\n  export const SQRT2: f64;\\n  @external(\\\"env\\\", \\\"Math.abs\\\")\\n  export function abs(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.acos\\\")\\n  export function acos(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.acosh\\\")\\n  export function acosh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.asin\\\")\\n  export function asin(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.asinh\\\")\\n  export function asinh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.atan\\\")\\n  export function atan(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.atan2\\\")\\n  export function atan2(y: f64, x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.atanh\\\")\\n  export function atanh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.cbrt\\\")\\n  export function cbrt(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.ceil\\\")\\n  export function ceil(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.clz32\\\")\\n  export function clz32(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.cos\\\")\\n  export function cos(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.cosh\\\")\\n  export function cosh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.exp\\\")\\n  export function exp(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.expm1\\\")\\n  export function expm1(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.floor\\\")\\n  export function floor(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.fround\\\")\\n  export function fround(x: f64): f32;\\n  @external(\\\"env\\\", \\\"Math.hypot\\\")\\n  export function hypot(value1: f64, value2: f64): f64; // TODO: rest\\n  @external(\\\"env\\\", \\\"Math.imul\\\")\\n  export function imul(a: f64, b: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log\\\")\\n  export function log(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log10\\\")\\n  export function log10(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log1p\\\")\\n  export function log1p(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log2\\\")\\n  export function log2(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.max\\\")\\n  export function max(value1: f64, value2: f64): f64; // TODO: rest\\n  @external(\\\"env\\\", \\\"Math.min\\\")\\n  export function min(value1: f64, value2: f64): f64; // TODO: rest\\n  @external(\\\"env\\\", \\\"Math.pow\\\")\\n  export function pow(base: f64, exponent: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.random\\\")\\n  export function random(): f64;\\n  @external(\\\"env\\\", \\\"Math.round\\\")\\n  export function round(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sign\\\")\\n  export function sign(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sin\\\")\\n  export function sin(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sinh\\\")\\n  export function sinh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sqrt\\\")\\n  export function sqrt(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.tan\\\")\\n  export function tan(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.tanh\\\")\\n  export function tanh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.trunc\\\")\\n  export function trunc(x: f64): f64;\\n}\\n\\nexport declare namespace Reflect {\\n  @external(\\\"env\\\", \\\"Reflect.get\\\")\\n  export function get(target: externref, propertyKey: string): externref;\\n  @external(\\\"env\\\", \\\"Reflect.getWithReceiver\\\")\\n  @external.js(\\\"return Reflect.get(target, propertyKey, receiver);\\\")\\n  export function getWithReceiver(target: externref, propertyKey: string, receiver: externref): externref;\\n  @external(\\\"env\\\", \\\"Reflect.has\\\")\\n  export function has(target: externref, propertyKey: string): bool;\\n  @external(\\\"env\\\", \\\"Reflect.set\\\")\\n  export function set(target: externref, propertyKey: string, value: externref): externref;\\n  @external(\\\"env\\\", \\\"Reflect.setWithReceiver\\\")\\n  @external.js(\\\"return Reflect.set(target, propertyKey, value, receiver);\\\")\\n  export function setWithReceiver(target: externref, propertyKey: string, value: externref , receiver: externref): externref;\\n  @external(\\\"env\\\", \\\"Reflect.apply\\\")\\n  export function apply(target: externref, thisArgument: externref, argumentsList: externref): externref;\\n}\\n\\nexport declare namespace String {\\n  @external(\\\"env\\\", \\\"String.fromCodePoint\\\")\\n  export function fromCodePoint(codepoint: i32): externref;\\n  @external(\\\"env\\\", \\\"String.fromCodePoints\\\")\\n  @external.js(\\\"return String.fromCodePoint(...codepoints);\\\")\\n  export function fromCodePoints(codepoints: i32[]): externref;\\n}\\n\\nexport declare namespace Object {\\n  @external(\\\"env\\\", \\\"Object.is\\\")\\n  export function is(a: externref, b: externref): bool;\\n  @external(\\\"env\\\", \\\"Object.hasOwn\\\")\\n  export function hasOwn(target: externref, propertyKey: string): bool;\\n  @external(\\\"env\\\", \\\"Object.assign\\\")\\n  export function assign(target: externref, source: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.keys\\\")\\n  export function keys(target: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.values\\\")\\n  export function values(target: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.entries\\\")\\n  export function entries(target: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.getOwnPropertyNames\\\")\\n  export function getOwnPropertyNames(target: externref): externref;\\n}\\n\\nexport declare namespace Date {\\n  @external(\\\"env\\\", \\\"Date.now\\\")\\n  export function now(): f64;\\n}\\n\\nexport declare namespace console {\\n  @external(\\\"env\\\", \\\"console.assert\\\")\\n  export function assert(condition: bool, message: string): void;\\n  @external(\\\"env\\\", \\\"console.log\\\")\\n  export function log(text: string): void;\\n  @external(\\\"env\\\", \\\"console.debug\\\")\\n  export function debug(text: string): void;\\n  @external(\\\"env\\\", \\\"console.info\\\")\\n  export function info(text: string): void;\\n  @external(\\\"env\\\", \\\"console.warn\\\")\\n  export function warn(text: string): void;\\n  @external(\\\"env\\\", \\\"console.error\\\")\\n  export function error(text: string): void;\\n  @external(\\\"env\\\", \\\"console.time\\\")\\n  export function time(label: string): void;\\n  @external(\\\"env\\\", \\\"console.timeLog\\\")\\n  export function timeLog(label: string): void;\\n  @external(\\\"env\\\", \\\"console.timeEnd\\\")\\n  export function timeEnd(label: string): void;\\n}\\n\\nexport declare namespace document {\\n  /** Returns document's encoding. */\\n  @external(\\\"env\\\", \\\"document.characterSet\\\")\\n  export const characterSet: string;\\n  /** Returns a value that indicates whether standards-compliant mode is switched on for the object. */\\n  @external(\\\"env\\\", \\\"document.compatMode\\\")\\n  export const compatMode: string;\\n  /** Returns document's content type. */\\n  @external(\\\"env\\\", \\\"document.contentType\\\")\\n  export const contentType: string;\\n  /** Returns a reference to the root node of the document. */\\n  @external(\\\"env\\\", \\\"document.documentElement\\\")\\n  export const documentElement: externref;\\n  /** Returns document's URL. */\\n  @external(\\\"env\\\", \\\"document.documentURI\\\")\\n  export const documentURI: string;\\n  /** Returns the URL of the location that referred the user to the current page. */\\n  @external(\\\"env\\\", \\\"document.referrer\\\")\\n  export const referrer: string;\\n  /** Returns true if document has the ability of fullscreen mode, or false otherwise. */\\n  @external(\\\"env\\\", \\\"document.pictureInPictureEnabled\\\")\\n  export const fullscreenEnabled: bool;\\n  /** Returns true if document has the ability of picture-in-picture mode, or false otherwise. */\\n  @external(\\\"env\\\", \\\"document.pictureInPictureEnabled\\\")\\n  export const pictureInPictureEnabled: bool;\\n\\n  /** Returns the number of child elements. */\\n  @external(\\\"env\\\", \\\"document.childElementCount\\\")\\n  export const childElementCount: i32;\\n  /** Returns the child elements. */\\n  @external(\\\"env\\\", \\\"document.children\\\")\\n  export const children: externref;\\n  /** Returns the first child that is an element, and null otherwise. */\\n  @external(\\\"env\\\", \\\"document.firstElementChild\\\")\\n  export const firstElementChild: externref;\\n  /** Returns the last child that is an element, and null otherwise. */\\n  @external(\\\"env\\\", \\\"document.lastElementChild\\\")\\n  export const lastElementChild: externref;\\n\\n  /**\\n   * Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied\\n   * to this resource, the empty string will be returned.\\n   *\\n   * Can be set, to add a new cookie to the element's set of HTTP cookies.\\n   *\\n   * If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute),\\n   * a \\\"SecurityError\\\" DOMException will be thrown on getting and setting.\\n   */\\n  @external(\\\"env\\\", \\\"document.cookie\\\")\\n  export let cookie: string;\\n  /** Represents the <body> or <frameset> node of the current document, or null if no such element exists. */\\n  @external(\\\"env\\\", \\\"document.body\\\")\\n  export let body: externref;\\n  /** Sets or gets the security domain of the document. */\\n  @external(\\\"env\\\", \\\"document.domain\\\")\\n  export let domain: string;\\n  /** Sets or gets the title of the document. */\\n  @external(\\\"env\\\", \\\"document.title\\\")\\n  export let title: string;\\n  /** Sets or gets information about the current Location. */\\n  @external(\\\"env\\\", \\\"document.location\\\")\\n  export let location: externref;\\n  /** Sets or gets the URL for the current document. */\\n  @external(\\\"env\\\", \\\"document.URL\\\")\\n  export let URL: string;\\n\\n  /**\\n   * Creates an instance of the element for the specified tag.\\n   * @param tagName The name of an element.\\n   */\\n  @external(\\\"env\\\", \\\"document.createElement\\\")\\n  export function createElement(tagName: string /* , options?: ElementCreationOptions */): externref;\\n  /**\\n   * Returns a reference to the first HTMLElement object with the specified value of the ID attribute.\\n   * @param id String that specifies the ID value.\\n   */\\n  @external(\\\"env\\\", \\\"document.getElementById\\\")\\n  export function getElementById(id: string): externref;\\n  /**\\n   * Returns a HTMLCollection of the elements in the object on which the method was invoked that have all the classes\\n   * given by classNames. The classNames argument is interpreted as a space-separated list of classes.\\n   * @param classNames Gets a collection of objects based on the value of the CLASS attribute.\\n   */\\n  @external(\\\"env\\\", \\\"document.getElementsByClassName\\\")\\n  export function getElementsByClassName(classNames: string): externref;\\n  /**\\n   * Gets a collection of HTMLElement objects based on the value of the NAME or ID attribute.\\n   * @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.\\n   */\\n  @external(\\\"env\\\", \\\"document.getElementsByName\\\")\\n  export function getElementsByName(elementName: string): externref;\\n  /** Gets a value indicating whether the object currently has focus. */\\n  @external(\\\"env\\\", \\\"document.hasFocus\\\")\\n  export function hasFocus(): bool;\\n  /** Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes. */\\n  @external(\\\"env\\\", \\\"document.append\\\")\\n  export function append(node: externref): void;\\n  /** Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes. */\\n  @external(\\\"env\\\", \\\"document.prepend\\\")\\n  export function prepend(node: externref): void;\\n  /** Replace all children of node with nodes, while replacing strings in nodes with equivalent Text nodes. */\\n  @external(\\\"env\\\", \\\"document.replaceChildren\\\")\\n  export function replaceChildren(node: externref): void;\\n  /**\\n   * Writes one or more HTML expressions to a document in the specified window.\\n   * @param content Specifies the text and HTML tags to write.\\n   */\\n  @external(\\\"env\\\", \\\"document.write\\\")\\n  export function write(content: string): void;\\n  /**\\n   * Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window.\\n   * @param content Specifies the text and HTML tags to write.\\n   */\\n  @external(\\\"env\\\", \\\"document.writeln\\\")\\n  export function writeln(content: string): void;\\n}\\n\\nexport declare namespace performance {\\n  @external(\\\"env\\\", \\\"performance.now\\\")\\n  export function now(): f64;\\n}\\n\\nexport namespace crypto {\\n  export function getRandomValues(array: Uint8Array): void {\\n    let values = getRandomValuesN(array.length);\\n    array.set(values);\\n  }\\n  @external(\\\"env\\\", \\\"crypto.getRandomValuesN\\\")\\n  @external.js(\\\"let a = new Uint8Array(n); crypto.getRandomValues(a); return a;\\\")\\n  export declare function getRandomValuesN(n: u32): Uint8Array;\\n}\\n\",\n  \"bindings/node\": \"export declare namespace process {\\n  @external(\\\"env\\\", \\\"process.argv\\\")\\n  export const argv: string[];\\n  @external(\\\"env\\\", \\\"process.exit\\\")\\n  export function exit(code: i32): void;\\n}\\n\",\n  \"builtins\": \"import { strtol, strtod, strtob } from \\\"./util/string\\\";\\n\\ntype auto = i32;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isBoolean<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isInteger<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isSigned<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isFloat<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isVector<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isReference<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isString<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isArray<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isArrayLike<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isFunction<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isNullable<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isDefined(expression: auto): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isConstant(expression: auto): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isManaged<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isVoid<T>(): bool;\\n\\n// @ts-ignore\\n@builtin\\nexport declare function lengthof<T>(func?: T): i32;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function clz<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function ctz<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function popcnt<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function rotl<T>(value: T, shift: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function rotr<T>(value: T, shift: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function abs<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function max<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function min<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function ceil<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function floor<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function copysign<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function nearest<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function reinterpret<T>(value: number): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function sqrt<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function trunc<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function add<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function sub<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function mul<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function div<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function eq<T>(left: T, right: T): i32;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function ne<T>(left: T, right: T): i32;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function rem<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function sizeof<T>(): usize; // | u32 / u64\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function alignof<T>(): usize; // | u32 / u64\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function idof<T>(): u32;\\n\\n// @ts-ignore\\n@builtin\\nexport declare function nameof<T>(): string;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function unreachable(): auto;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function changetype<T>(value: auto): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function assert<T>(isTrueish: T, message?: string): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function unchecked<T>(expr: T): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function instantiate<T>(...args: auto[]): T;\\n\\nexport namespace atomic {\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function notify(ptr: usize, count: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function fence(): void;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const enum AtomicWaitResult {\\n  OK = 0,\\n  NOT_EQUAL = 1,\\n  TIMED_OUT = 2\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i8(value: auto): i8;\\n\\nexport namespace i8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i8 = -128;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i8 =  127;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i8 {\\n    return <i8>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i16(value: auto): i16;\\n\\nexport namespace i16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i16 = -32768;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i16 =  32767;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i16 {\\n    return <i16>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i32(value: auto): i32;\\n\\nexport namespace i32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i32 = -2147483648;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i32 =  2147483647;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i32 {\\n    return strtol<i32>(value, radix);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function clz(value: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ctz(value: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt(value: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_s(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_u(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotl(value: i32, shift: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotr(value: i32, shift: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_s(left: i32, right: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_u(left: u32, right: u32): u32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_f32(value: f32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n\\n  export namespace atomic {\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load(ptr: usize, immOffset?: usize): i32;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\\n\\n    export namespace rmw8 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n\\n    export namespace rmw16 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n\\n    export namespace rmw {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i64(value: auto): i64;\\n\\nexport namespace i64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i64 = -9223372036854775808;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i64 =  9223372036854775807;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i64 {\\n    return strtol<i64>(value, radix);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function clz(value: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ctz(value: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_s(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_u(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt(value: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotl(value: i64, shift: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotr(value: i64, shift: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: i64, right:i64): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: i64, right:i64): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_s(left: i64, right: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_u(left: u64, right: u64): u64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_f64(value: f64): i64;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  export namespace atomic {\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    export namespace rmw8 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n\\n    export namespace rmw16 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n\\n    export namespace rmw32 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n\\n    export namespace rmw {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isize(value: auto): isize;\\n\\nexport namespace isize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\\n    ? -2147483648\\n    : <isize>-9223372036854775808;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\\n    ? 2147483647\\n    : <isize>9223372036854775807;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): isize {\\n    return <isize>strtol<i64>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u8(value: auto): u8;\\n\\nexport namespace u8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u8 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u8 = 255;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u8 {\\n    return <u8>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u16(value: auto): u16;\\n\\nexport namespace u16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u16 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u16 = 65535;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u16 {\\n    return <u16>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u32(value: auto): u32;\\n\\nexport namespace u32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u32 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u32 = 4294967295;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u32 {\\n    return <u32>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u64(value: auto): u64;\\n\\nexport namespace u64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u64 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u64 = 18446744073709551615;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u64 {\\n    return <u64>strtol<i64>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function usize(value: auto): usize;\\n\\nexport namespace usize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: usize = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\\n    ? 4294967295\\n    : <usize>18446744073709551615;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): usize {\\n    return <usize>strtol<i64>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function bool(value: auto): bool;\\n\\nexport namespace bool {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: bool = false;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: bool = true;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string): bool {\\n    return strtob(value);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f32(value: auto): f32;\\n\\nexport namespace f32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const POSITIVE_INFINITY: f32 =  Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NaN: f32 = 0.0 / 0.0;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string): f32 {\\n    return <f32>strtod(value);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function copysign(x: f32, y: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_i32(value: i32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: f32, right: f32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: f32, right: f32): i32;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f64(value: auto): f64;\\n\\nexport namespace f64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const POSITIVE_INFINITY: f64 =  Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NaN: f64 = 0.0 / 0.0;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string): f64 {\\n    return strtod(value);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function copysign(x: f64, y: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_i64(value: i64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: f64, right: f64): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: f64, right: f64): i32;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function v128(\\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\\n): v128;\\n\\nexport namespace v128 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat<T>(x: T): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl<T>(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr<T>(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function and(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function or(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function xor(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function andnot(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function not(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function any_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true<T>(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask<T>(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmin<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmax<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_low<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_zero<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function demote_zero<T = f64>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function promote_low<T = f32>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_trunc<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_trunc_zero<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_madd<T>(a: v128, b: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_nmadd<T>(a: v128, b: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_laneselect<T>(a: v128, b: v128, m: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_min<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_max<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_q15mulr<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_dot<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_dot_add<T>(a: v128, b: v128, c: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i8x16(\\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\\n): v128;\\n\\nexport namespace i8x16 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function avgr_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(\\n    a: v128, b: v128,\\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\\n  ): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\\n\\nexport namespace i16x8 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i16): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function avgr_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i8x16_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i8x16_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i8x16_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i8x16_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(\\n    a: v128, b: v128,\\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\\n  ): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_q15mulr_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_dot_i8x16_i7x16_s(a: v128, b: v128, c: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\\n\\nexport namespace i32x4 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i16x8_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i16x8_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i16x8_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i16x8_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_trunc_f32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_trunc_f32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_trunc_f64x2_s_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_trunc_f64x2_u_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_dot_i8x16_i7x16_add_s(a: v128, b: v128, c: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i64x2(a: i64, b: i64): v128;\\n\\nexport namespace i64x2 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\\n\\nexport namespace f32x4 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: f32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmin(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmax(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function demote_f64x2_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_min(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_max(a: v128, b: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f64x2(a: f64, b: f64): v128;\\n\\nexport namespace f64x2 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: f64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmin(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmax(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_low_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_low_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function promote_low_f32x4(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_min(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function relaxed_max(a: v128, b: v128): v128;\\n}\\n\\n@final\\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  static get(i31expr: i31ref): i32 { return unreachable(); }\\n}\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"abort\\\")\\n@external.js(\\\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\\\")\\ndeclare function abort(\\n  message?: string | null,\\n  fileName?: string | null,\\n  lineNumber?: u32,\\n  columnNumber?: u32\\n): void;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"trace\\\")\\n@external.js(\\\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\\\")\\ndeclare function trace(\\n  message: string,\\n  n?: i32,\\n  a0?: f64,\\n  a1?: f64,\\n  a2?: f64,\\n  a3?: f64,\\n  a4?: f64\\n): void;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"seed\\\")\\n@external.js(\\\"return Date.now() * Math.random();\\\")\\ndeclare function seed(): f64;\\n\\n/* eslint-enable @typescript-eslint/no-unused-vars */\\n\",\n  \"compat\": \"export type ReturnType<T> = returnof<T>;\\nexport type NonNullable<T> = nonnull<T>;\\n\",\n  \"console\": \"import {\\n  console as binding\\n} from \\\"./bindings/dom\\\";\\n\\nexport namespace console {\\n\\n  export function assert<T>(condition: T, message: string = \\\"\\\"): void {\\n    binding.assert(!!condition, message);\\n  }\\n\\n  export function log(message: string = \\\"\\\"): void {\\n    binding.log(message);\\n  }\\n\\n  export function debug(message: string = \\\"\\\"): void {\\n    binding.debug(message);\\n  }\\n\\n  export function info(message: string = \\\"\\\"): void {\\n    binding.info(message);\\n  }\\n\\n  export function warn(message: string = \\\"\\\"): void {\\n    binding.warn(message);\\n  }\\n\\n  export function error(message: string = \\\"\\\"): void {\\n    binding.error(message);\\n  }\\n\\n  export function time(label: string = \\\"default\\\"): void {\\n    binding.time(label);\\n  }\\n\\n  export function timeLog(label: string = \\\"default\\\"): void {\\n    binding.timeLog(label);\\n  }\\n\\n  export function timeEnd(label: string = \\\"default\\\"): void {\\n    binding.timeEnd(label);\\n  }\\n}\\n\",\n  \"crypto\": \"import {\\n  crypto as crypto_binding\\n} from \\\"bindings/dom\\\";\\n\\nexport namespace crypto {\\n  export function getRandomValues(array: Uint8Array): void {\\n    crypto_binding.getRandomValues(array);\\n  }\\n}\\n\",\n  \"dataview\": \"import { BLOCK_MAXSIZE } from \\\"./rt/common\\\";\\nimport { ArrayBuffer } from \\\"./arraybuffer\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \\\"./util/error\\\";\\n\\n// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte\\n\\nexport class DataView {\\n\\n  readonly buffer: ArrayBuffer;\\n  @unsafe readonly dataStart: usize;\\n  readonly byteLength: i32;\\n\\n  get byteOffset(): i32 {\\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\\n  }\\n\\n  constructor(\\n    buffer: ArrayBuffer,\\n    byteOffset: i32 = 0,\\n    byteLength: i32 = buffer.byteLength\\n  ) {\\n    if (\\n      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |\\n      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)\\n    ) throw new RangeError(E_INVALIDLENGTH);\\n    this.buffer = buffer; // links\\n    let dataStart = changetype<usize>(buffer) + <usize>byteOffset;\\n    this.dataStart = dataStart;\\n    this.byteLength = byteLength;\\n  }\\n\\n  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return littleEndian\\n      ? load<f32>(this.dataStart + <usize>byteOffset)\\n      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));\\n  }\\n\\n  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return littleEndian\\n      ? load<f64>(this.dataStart + <usize>byteOffset)\\n      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));\\n  }\\n\\n  getInt8(byteOffset: i32): i8 {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i8>(this.dataStart + <usize>byteOffset);\\n  }\\n\\n  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: i16 = load<i16>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u16>(result);\\n  }\\n\\n  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: i32 = load<i32>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u32>(result);\\n  }\\n\\n  getUint8(byteOffset: i32): u8 {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>byteOffset);\\n  }\\n\\n  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: u16 = load<u16>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u16>(result);\\n  }\\n\\n  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: u32 = load<u32>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u32>(result);\\n  }\\n\\n  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);\\n    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));\\n  }\\n\\n  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);\\n    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));\\n  }\\n\\n  setInt8(byteOffset: i32, value: i8): void {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i8>(this.dataStart + <usize>byteOffset, value);\\n  }\\n\\n  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\\n  }\\n\\n  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\\n  }\\n\\n  setUint8(byteOffset: i32, value: u8): void {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u8>(this.dataStart + <usize>byteOffset, value);\\n  }\\n\\n  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\\n  }\\n\\n  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\\n  }\\n\\n  // Non-standard additions that make sense in WebAssembly, but won't work in JS:\\n\\n  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: i64 = load<i64>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u64>(result);\\n  }\\n\\n  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result = load<u64>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u64>(result);\\n  }\\n\\n  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\\n  }\\n\\n  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\\n  }\\n\\n  toString(): string {\\n    return \\\"[object DataView]\\\";\\n  }\\n}\\n\",\n  \"date\": \"import { E_INVALIDDATE } from \\\"util/error\\\";\\nimport { Date as Date_binding } from \\\"./bindings/dom\\\";\\n\\n// @ts-ignore: decorator\\n@inline const\\n  MILLIS_PER_DAY    = 1000 * 60 * 60 * 24,\\n  MILLIS_PER_HOUR   = 1000 * 60 * 60,\\n  MILLIS_PER_MINUTE = 1000 * 60,\\n  MILLIS_PER_SECOND = 1000,\\n\\n  YEARS_PER_EPOCH = 400,\\n  DAYS_PER_EPOCH = 146097,\\n  EPOCH_OFFSET = 719468, // Jan 1, 1970\\n  MILLIS_LIMIT = 8640000000000000;\\n\\n// ymdFromEpochDays returns values via globals to avoid allocations\\n// @ts-ignore: decorator\\n@lazy let _month: i32, _day: i32;\\n\\nexport class Date {\\n  private year: i32 = 0;\\n  private month: i32 = 0;\\n  private day: i32 = 0;\\n\\n  @inline static UTC(\\n    year: i32,\\n    month: i32 = 0,\\n    day: i32 = 1,\\n    hour: i32 = 0,\\n    minute: i32 = 0,\\n    second: i32 = 0,\\n    millisecond: i32 = 0\\n  ): i64 {\\n    if (year >= 0 && year <= 99) year += 1900;\\n    let ms = epochMillis(year, month + 1, day, hour, minute, second, millisecond);\\n    if (invalidDate(ms)) throw new RangeError(E_INVALIDDATE);\\n    return ms;\\n  }\\n\\n  @inline static now(): i64 {\\n    return <i64>Date_binding.now();\\n  }\\n\\n  // It can parse only ISO 8601 inputs like YYYY-MM-DDTHH:MM:SS.000Z\\n  @inline static parse(dateString: string): Date {\\n    return this.fromString(dateString);\\n  }\\n\\n  static fromString(dateTimeString: string): Date {\\n    if (!dateTimeString.length) throw new RangeError(E_INVALIDDATE);\\n    var\\n      hour: i32 = 0,\\n      min: i32 = 0,\\n      sec: i32 = 0,\\n      ms: i32 = 0,\\n      offsetMs: i32 = 0;\\n\\n    let dateString = dateTimeString;\\n    let posT = dateTimeString.indexOf(\\\"T\\\");\\n    if (~posT) {\\n      // includes a time component\\n      let timeString: string;\\n      dateString = dateTimeString.substring(0, posT);\\n      timeString = dateTimeString.substring(posT + 1);\\n      \\n      // might end with an offset (\\\"Z\\\", \\\"+05:30\\\", \\\"-08:00\\\", etc.)\\n      for (let i = timeString.length - 1; i >= 0; i--) {\\n        let c = timeString.charCodeAt(i);\\n        if (c == 90) { // Z\\n          timeString = timeString.substring(0, i);\\n          break;\\n        } else if (c == 43 || c == 45) { // + or -\\n          if (i == timeString.length - 1) {\\n            throw new RangeError(E_INVALIDDATE);\\n          }\\n\\n          let posColon = timeString.indexOf(\\\":\\\", i + 1);\\n          if (~posColon) {\\n            let offsetHours = i32.parse(timeString.substring(i + 1, posColon));\\n            let offsetMinutes = i32.parse(timeString.substring(posColon + 1));\\n            offsetMs = (offsetHours * 60 + offsetMinutes) * MILLIS_PER_MINUTE;\\n          } else {\\n            let offsetHours = i32.parse(timeString.substring(i + 1));\\n            offsetMs = offsetHours * MILLIS_PER_HOUR;\\n          }    \\n    \\n          if (c == 45) offsetMs = -offsetMs; // negative offset\\n          timeString = timeString.substring(0, i);\\n          break;\\n        }\\n      }\\n\\n      // parse the HH:MM:SS component\\n      let timeParts = timeString.split(\\\":\\\");\\n      let len = timeParts.length;\\n      if (len <= 1) throw new RangeError(E_INVALIDDATE);\\n\\n      hour = i32.parse(timeParts[0]);\\n      min  = i32.parse(timeParts[1]);\\n      if (len >= 3) {\\n        let secAndFrac = timeParts[2];\\n        let posDot = secAndFrac.indexOf(\\\".\\\");\\n        if (~posDot) {\\n          // includes fractional seconds (truncate to milliseconds)\\n          sec = i32.parse(secAndFrac.substring(0, posDot));\\n          ms  = i32.parse(secAndFrac.substr(posDot + 1, 3).padEnd(3, \\\"0\\\"));\\n        } else {\\n          sec = i32.parse(secAndFrac);\\n        }\\n      }\\n    }\\n\\n    // parse the YYYY-MM-DD component\\n    let parts = dateString.split(\\\"-\\\");\\n    let year = i32.parse(parts[0]);\\n    let month = 1, day = 1;\\n    let len = parts.length;\\n    if (len >= 2) {\\n      month = i32.parse(parts[1]);\\n      if (len >= 3) {\\n        day = i32.parse(parts[2]);\\n      }\\n    }\\n\\n    return new Date(epochMillis(year, month, day, hour, min, sec, ms) - offsetMs);\\n  }\\n\\n  constructor(private epochMillis: i64) {\\n    // this differs from JavaScript which prefer return NaN or \\\"Invalid Date\\\" string\\n    // instead throwing exception.\\n    if (invalidDate(epochMillis)) throw new RangeError(E_INVALIDDATE);\\n\\n    this.year = dateFromEpoch(epochMillis);\\n    this.month = _month;\\n    this.day = _day;\\n  }\\n\\n  @inline getTime(): i64 {\\n    return this.epochMillis;\\n  }\\n\\n  setTime(time: i64): i64 {\\n    if (invalidDate(time)) throw new RangeError(E_INVALIDDATE);\\n\\n    this.epochMillis = time;\\n    this.year = dateFromEpoch(time);\\n    this.month = _month;\\n    this.day = _day;\\n\\n    return time;\\n  }\\n\\n  @inline getUTCFullYear(): i32 {\\n    return this.year;\\n  }\\n\\n  @inline getUTCMonth(): i32 {\\n    return this.month - 1;\\n  }\\n\\n  @inline getUTCDate(): i32 {\\n    return this.day;\\n  }\\n\\n  @inline getUTCDay(): i32 {\\n    return dayOfWeek(this.year, this.month, this.day);\\n  }\\n\\n  getUTCHours(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_DAY)) / MILLIS_PER_HOUR;\\n  }\\n\\n  getUTCMinutes(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_HOUR)) / MILLIS_PER_MINUTE;\\n  }\\n\\n  getUTCSeconds(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_MINUTE)) / MILLIS_PER_SECOND;\\n  }\\n\\n  getUTCMilliseconds(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_SECOND));\\n  }\\n\\n  setUTCMilliseconds(millis: i32): void {\\n    this.setTime(this.epochMillis + (millis - this.getUTCMilliseconds()));\\n  }\\n\\n  setUTCSeconds(seconds: i32): void {\\n    this.setTime(this.epochMillis + (seconds - this.getUTCSeconds()) * MILLIS_PER_SECOND);\\n  }\\n\\n  setUTCMinutes(minutes: i32): void {\\n    this.setTime(this.epochMillis + (minutes - this.getUTCMinutes()) * MILLIS_PER_MINUTE);\\n  }\\n\\n  setUTCHours(hours: i32): void {\\n    this.setTime(this.epochMillis + (hours - this.getUTCHours()) * MILLIS_PER_HOUR);\\n  }\\n\\n  setUTCDate(day: i32): void {\\n    if (this.day == day) return;\\n    this.setTime(join(this.year, this.month, day, this.epochMillis));\\n  }\\n\\n  setUTCMonth(month: i32, day: i32 = this.day): void {\\n    if (this.month == month + 1) return;\\n    this.setTime(join(this.year, month + 1, day, this.epochMillis));\\n  }\\n\\n  setUTCFullYear(year: i32): void {\\n    if (this.year == year) return;\\n    this.setTime(join(year, this.month, this.day, this.epochMillis));\\n  }\\n\\n  toISOString(): string {\\n    // TODO: add more low-level helper which combine toString and padStart without extra allocation\\n\\n    let yr = this.year;\\n    let isNeg = yr < 0;\\n    let year = (isNeg || yr >= 10000)\\n      ? (isNeg ? \\\"-\\\" : \\\"+\\\") + stringify(abs(yr), 6)\\n      : stringify(yr, 4);\\n    let month = stringify(this.month, 2);\\n    let day = stringify(this.day);\\n    let hours = stringify(this.getUTCHours());\\n    let mins = stringify(this.getUTCMinutes());\\n    let secs = stringify(this.getUTCSeconds());\\n    let ms = stringify(this.getUTCMilliseconds(), 3);\\n\\n    return `${year}-${month}-${day}T${hours}:${mins}:${secs}.${ms}Z`;\\n  }\\n\\n  toUTCString(): string {\\n    const\\n      weeks: StaticArray<string> = [\\n        \\\"Sun, \\\", \\\"Mon, \\\", \\\"Tue, \\\", \\\"Wed, \\\", \\\"Thu, \\\", \\\"Fri, \\\", \\\"Sat, \\\"\\n      ],\\n      months: StaticArray<string> = [\\n        \\\" Jan \\\", \\\" Feb \\\", \\\" Mar \\\", \\\" Apr \\\", \\\" May \\\", \\\" Jun \\\",\\n        \\\" Jul \\\", \\\" Aug \\\", \\\" Sep \\\", \\\" Oct \\\", \\\" Nov \\\", \\\" Dec \\\"\\n      ];\\n\\n    let mo = this.month;\\n    let da = this.day;\\n    let yr = this.year;\\n    let wd = dayOfWeek(yr, mo, da);\\n    let year = stringify(abs(yr), 4);\\n    let month = unchecked(months[mo - 1]);\\n    let week = unchecked(weeks[wd]);\\n    let day = stringify(da);\\n    let hours = stringify(this.getUTCHours());\\n    let mins = stringify(this.getUTCMinutes());\\n    let secs = stringify(this.getUTCSeconds());\\n\\n    return `${week}${day}${month}${yr < 0 ? \\\"-\\\" : \\\"\\\"}${year} ${hours}:${mins}:${secs} GMT`;\\n  }\\n\\n  toDateString(): string {\\n    // TODO: use u64 static data instead 4 chars\\n    // also use stream itoa variants.\\n    const\\n      weeks: StaticArray<string> = [\\n        \\\"Sun \\\", \\\"Mon \\\", \\\"Tue \\\", \\\"Wed \\\", \\\"Thu \\\", \\\"Fri \\\", \\\"Sat \\\"\\n      ],\\n      months: StaticArray<string> = [\\n        \\\"Jan \\\", \\\"Feb \\\", \\\"Mar \\\", \\\"Apr \\\", \\\"May \\\", \\\"Jun \\\",\\n        \\\"Jul \\\", \\\"Aug \\\", \\\"Sep \\\", \\\"Oct \\\", \\\"Nov \\\", \\\"Dec \\\"\\n      ];\\n\\n    let mo = this.month;\\n    let da = this.day;\\n    let yr = this.year;\\n    let wd = dayOfWeek(yr, mo, da);\\n    let year = stringify(abs(yr), 4);\\n    let month = unchecked(months[mo - 1]);\\n    let week = unchecked(weeks[wd]);\\n    let day = stringify(da);\\n\\n    return `${week}${month}${day}${yr < 0 ? \\\" -\\\" : \\\" \\\"}${year}`;\\n  }\\n\\n  // Note: it uses UTC time instead local time (without timezone offset)\\n  toTimeString(): string {\\n    let hours = stringify(this.getUTCHours());\\n    let mins = stringify(this.getUTCMinutes());\\n    let secs = stringify(this.getUTCSeconds());\\n    // TODO: add timezone\\n    return `${hours}:${mins}:${secs}`;\\n  }\\n\\n  // Note: it uses UTC datetime instead local datetime (without timezone offset)\\n  toString(): string {\\n    return `${this.toDateString()} ${this.toTimeString()}`;\\n  }\\n}\\n\\nfunction epochMillis(\\n  year: i32,\\n  month: i32,\\n  day: i32,\\n  hour: i32,\\n  minute: i32,\\n  second: i32,\\n  milliseconds: i32\\n): i64 {\\n  return (\\n    daysSinceEpoch(year, month, day) * MILLIS_PER_DAY +\\n    hour * MILLIS_PER_HOUR +\\n    minute * MILLIS_PER_MINUTE +\\n    second * MILLIS_PER_SECOND +\\n    milliseconds\\n  );\\n}\\n\\n// @ts-ignore: decorator\\n@inline function floorDiv<T extends number>(a: T, b: T): T {\\n  return (a - (a < 0 ? b - 1 : 0)) / b as T;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function euclidRem<T extends number>(a: T, b: T): T {\\n  let m = a % b;\\n  return m + (m < 0 ? b : 0) as T;\\n}\\n\\nfunction invalidDate(millis: i64): bool {\\n  // @ts-ignore\\n  return (millis < -MILLIS_LIMIT) | (millis > MILLIS_LIMIT);\\n}\\n\\n// Based on \\\"Euclidean Affine Functions and Applications to Calendar Algorithms\\\"\\n// Paper: https://arxiv.org/pdf/2102.06959.pdf\\nfunction dateFromEpoch(ms: i64): i32 {\\n  let da = (<i32>floorDiv(ms, MILLIS_PER_DAY) * 4 + EPOCH_OFFSET * 4) | 3;\\n  let q0 = floorDiv(da, DAYS_PER_EPOCH); // [0, 146096]\\n  let r1 = <u32>da - q0 * DAYS_PER_EPOCH;\\n  let u1 = u64(r1 | 3) * 2939745;\\n  let dm1 = <u32>u1 / 11758980;\\n  let n1 = 2141 * dm1 + 197913;\\n  let year = 100 * q0 + i32(u1 >>> 32);\\n  let mo = n1 >>> 16;\\n  _day = (n1 & 0xFFFF) / 2141 + 1; // [1, 31]\\n  if (dm1 >= 306) { mo -= 12; ++year; }\\n  _month = mo; // [1, 12]\\n  return year;\\n}\\n\\n// http://howardhinnant.github.io/date_algorithms.html#days_from_civil\\nfunction daysSinceEpoch(y: i32, m: i32, d: i32): i64 {\\n  y -= i32(m <= 2);\\n  let era = <u32>floorDiv(y, YEARS_PER_EPOCH);\\n  let yoe = <u32>y - era * YEARS_PER_EPOCH; // [0, 399]\\n  let doy = <u32>(153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1; // [0, 365]\\n  let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy; // [0, 146096]\\n  return <i64><i32>(era * 146097 + doe - EPOCH_OFFSET);\\n}\\n\\n// TomohikoSakamoto algorithm from https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week\\nfunction dayOfWeek(year: i32, month: i32, day: i32): i32 {\\n  const tab = memory.data<u8>([0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]);\\n\\n  year -= i32(month < 3);\\n  year += floorDiv(year, 4) - floorDiv(year, 100) + floorDiv(year, YEARS_PER_EPOCH);\\n  month = <i32>load<u8>(tab + month - 1);\\n  return euclidRem(year + month + day, 7);\\n}\\n\\nfunction stringify(value: i32, padding: i32 = 2): string {\\n  return value.toString().padStart(padding, \\\"0\\\");\\n}\\n\\nfunction join(year: i32, month: i32, day: i32, ms: i64): i64 {\\n  return daysSinceEpoch(year, month, day) * MILLIS_PER_DAY + euclidRem(ms, MILLIS_PER_DAY);\\n}\\n\",\n  \"diagnostics\": \"// @ts-ignore: decorator\\n@builtin\\nexport declare function ERROR(message?: string): void;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function WARNING(message?: string): void;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function INFO(message?: string): void;\\n\",\n  \"error\": \"export class Error {\\n\\n  name: string  = \\\"Error\\\";\\n  stack: string = \\\"\\\"; // TODO\\n\\n  constructor(\\n    public message: string = \\\"\\\"\\n  ) {}\\n\\n  toString(): string {\\n    let message = this.message;\\n    return message.length\\n      ? this.name + \\\": \\\" + message\\n      : this.name;\\n  }\\n}\\n\\nexport class RangeError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"RangeError\\\";\\n  }\\n}\\n\\nexport class TypeError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"TypeError\\\";\\n  }\\n}\\n\\nexport class SyntaxError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"SyntaxError\\\";\\n  }\\n}\\n\\nexport class URIError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"URIError\\\";\\n  }\\n}\\n\",\n  \"function\": \"type auto = i32;\\n\\n@final export abstract class Function<T> {\\n  private _index: u32;\\n  private _env: usize;\\n\\n  // @ts-ignore: this on getter\\n  get index(this: T): u32 {\\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\\\"_index\\\"));\\n  }\\n\\n  // @ts-ignore: this on getter\\n  get name(this: T): string {\\n    return \\\"\\\";\\n  }\\n\\n  // @ts-ignore: this on getter\\n  get length(this: T): i32 {\\n    // @ts-ignore: T is function\\n    return lengthof<T>();\\n  }\\n\\n  // @ts-ignore: T is function\\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\\n    return unreachable();\\n  }\\n\\n  toString(this: T): string {\\n    return \\\"function() { [native code] }\\\";\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    // Env is either `null` (nop) or compiler-generated\\n    __visit(this._env, cookie);\\n  }\\n}\\n\",\n  \"iterator\": \"export abstract class Iterable<T> {\\n  // ?\\n}\\n\\n@final\\nexport abstract class Iterator<T> {\\n\\n  // private constructor(iterable: Iterable<T>) {\\n  // }\\n\\n  // TODO: these need to evaluate the classId at the respective reference in order to obtain the\\n  // next value, i.e. arrays work differently than maps. we'd then have:\\n  //\\n  // \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Iterator layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n  //    3                   2                   1\\n  //  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n  // \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n  // \u2502                             index                             \u2502\\n  // \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2524\\n  // \u2502                           reference                     \u2502 0 \u2502D\u2502\\n  // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2518\\n  // D: Done flag\\n\\n  // get value(this: u64): T {\\n  //   ?\\n  // }\\n\\n  // next(this: u64): Iterator<T> {\\n  //   ?\\n  // }\\n\\n  done(this: u64): bool {\\n    return <bool>(this & 1);\\n  }\\n}\\n\",\n  \"map\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { HASH } from \\\"./util/hash\\\";\\nimport { E_KEYNOTFOUND } from \\\"./util/error\\\";\\n\\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\\n\\n// @ts-ignore: decorator\\n@inline const INITIAL_CAPACITY = 4;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_N = 8;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_D = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_N = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_D = 4;\\n\\n/** Structure of a map entry. */\\n@unmanaged class MapEntry<K,V> {\\n  key: K;\\n  value: V;\\n  taggedNext: usize; // LSB=1 indicates EMPTY\\n}\\n\\n/** Empty bit. */\\n// @ts-ignore: decorator\\n@inline const EMPTY: usize = 1 << 0;\\n\\n/** Size of a bucket. */\\n// @ts-ignore: decorator\\n@inline const BUCKET_SIZE = sizeof<usize>();\\n\\n/** Computes the alignment of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_ALIGN<K,V>(): usize {\\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\\n  return align;\\n}\\n\\n/** Computes the aligned size of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_SIZE<K,V>(): usize {\\n  const align = ENTRY_ALIGN<K,V>();\\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\\n  return size;\\n}\\n\\nexport class Map<K,V> {\\n\\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\\n\\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\\n  private entriesOffset: i32 = 0;\\n  private entriesCount: i32 = 0;\\n\\n  constructor() {\\n    /* nop */\\n  }\\n\\n  get size(): i32 {\\n    return this.entriesCount;\\n  }\\n\\n  clear(): void {\\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n    this.bucketsMask = INITIAL_CAPACITY - 1;\\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\\n    this.entriesCapacity = INITIAL_CAPACITY;\\n    this.entriesOffset = 0;\\n    this.entriesCount = 0;\\n  }\\n\\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\\n    let entry = load<MapEntry<K,V>>( // unmanaged!\\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\\n    );\\n    while (entry) {\\n      let taggedNext = entry.taggedNext;\\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\\n    }\\n    return null;\\n  }\\n\\n  has(key: K): bool {\\n    return this.find(key, HASH<K>(key)) != null;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  get(key: K): V {\\n    let entry = this.find(key, HASH<K>(key));\\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\\n    return entry.value;\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  set(key: K, value: V): this {\\n    let hashCode = HASH<K>(key);\\n    let entry = this.find(key, hashCode); // unmanaged!\\n    if (entry) {\\n      entry.value = value;\\n      if (isManaged<V>()) {\\n        __link(changetype<usize>(this), changetype<usize>(value), true);\\n      }\\n    } else {\\n      // check if rehashing is necessary\\n      if (this.entriesOffset == this.entriesCapacity) {\\n        this.rehash(\\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\\n        );\\n      }\\n      // append new entry\\n      let entries = this.entries;\\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\\n      // link with the map\\n      entry.key = key;\\n      if (isManaged<K>()) {\\n        __link(changetype<usize>(this), changetype<usize>(key), true);\\n      }\\n      entry.value = value;\\n      if (isManaged<V>()) {\\n        __link(changetype<usize>(this), changetype<usize>(value), true);\\n      }\\n      ++this.entriesCount;\\n      // link with previous entry in bucket\\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\\n      entry.taggedNext = load<usize>(bucketPtrBase);\\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\\n    }\\n    return this;\\n  }\\n\\n  delete(key: K): bool {\\n    let entry = this.find(key, HASH<K>(key));\\n    if (!entry) return false;\\n    entry.taggedNext |= EMPTY;\\n    --this.entriesCount;\\n    // check if rehashing is appropriate\\n    let halfBucketsMask = this.bucketsMask >> 1;\\n    if (\\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n    ) this.rehash(halfBucketsMask);\\n    return true;\\n  }\\n\\n  private rehash(newBucketsMask: u32): void {\\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\\n\\n    // copy old entries to new entries\\n    let oldPtr = changetype<usize>(this.entries);\\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\\n    let newPtr = changetype<usize>(newEntries);\\n    while (oldPtr != oldEnd) {\\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\\n      if (!(oldEntry.taggedNext & EMPTY)) {\\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\\n        let oldEntryKey = oldEntry.key;\\n        newEntry.key = oldEntryKey;\\n        newEntry.value = oldEntry.value;\\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\\n        store<usize>(newBucketPtrBase, newPtr);\\n        newPtr += ENTRY_SIZE<K,V>();\\n      }\\n      oldPtr += ENTRY_SIZE<K,V>();\\n    }\\n\\n    this.buckets = newBuckets;\\n    this.bucketsMask = newBucketsMask;\\n    this.entries = newEntries;\\n    this.entriesCapacity = newEntriesCapacity;\\n    this.entriesOffset = this.entriesCount;\\n  }\\n\\n  keys(): K[] {\\n    // FIXME: this is preliminary, needs iterators/closures\\n    let start = changetype<usize>(this.entries);\\n    let size = this.entriesOffset;\\n    let keys = new Array<K>(size);\\n    let length = 0;\\n    for (let i = 0; i < size; ++i) {\\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\\n      if (!(entry.taggedNext & EMPTY)) {\\n        unchecked(keys[length++] = entry.key);\\n      }\\n    }\\n    keys.length = length;\\n    return keys;\\n  }\\n\\n  values(): V[] {\\n    // FIXME: this is preliminary, needs iterators/closures\\n    let start = changetype<usize>(this.entries);\\n    let size = this.entriesOffset;\\n    let values = new Array<V>(size);\\n    let length = 0;\\n    for (let i = 0; i < size; ++i) {\\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\\n      if (!(entry.taggedNext & EMPTY)) {\\n        unchecked(values[length++] = entry.value);\\n      }\\n    }\\n    values.length = length;\\n    return values;\\n  }\\n\\n  toString(): string {\\n    return \\\"[object Map]\\\";\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    __visit(changetype<usize>(this.buckets), cookie);\\n    let entries = changetype<usize>(this.entries);\\n    if (isManaged<K>() || isManaged<V>()) {\\n      let cur = entries;\\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\\n      while (cur < end) {\\n        let entry = changetype<MapEntry<K,V>>(cur);\\n        if (!(entry.taggedNext & EMPTY)) {\\n          if (isManaged<K>()) {\\n            let val = changetype<usize>(entry.key);\\n            if (isNullable<K>()) {\\n              if (val) __visit(val, cookie);\\n            } else __visit(val, cookie);\\n          }\\n          if (isManaged<V>()) {\\n            let val = changetype<usize>(entry.value);\\n            if (isNullable<V>()) {\\n              if (val) __visit(val, cookie);\\n            } else __visit(val, cookie);\\n          }\\n        }\\n        cur += ENTRY_SIZE<K,V>();\\n      }\\n    }\\n    __visit(entries, cookie);\\n  }\\n}\\n\",\n  \"math\": \"import { Math as JSMath } from \\\"./bindings/dom\\\";\\nexport { JSMath };\\n\\nimport {\\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\\n} from \\\"./util/math\\\";\\n\\nimport {\\n  abs as builtin_abs,\\n  ceil as builtin_ceil,\\n  clz as builtin_clz,\\n  copysign as builtin_copysign,\\n  floor as builtin_floor,\\n  max as builtin_max,\\n  min as builtin_min,\\n  sqrt as builtin_sqrt,\\n  trunc as builtin_trunc\\n} from \\\"./builtins\\\";\\n\\n// SUN COPYRIGHT NOTICE\\n//\\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\\n// Developed at SunPro, a Sun Microsystems, Inc. business.\\n// Permission to use, copy, modify, and distribute this software\\n// is freely granted, provided that this notice is preserved.\\n//\\n// Applies to all functions marked with a comment referring here.\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\\n]);\\n\\n/** @internal */\\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\\n\\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\\n  return p / q;\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\\n  const                       // see: musl/src/math/__expo2.c\\n    k    = <u32>2043,\\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\\n  // in directed rounding correct sign before rounding or overflow is important\\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\\n}\\n\\n/** @internal */\\n/* Helper function to eventually get bits of \u03C0/2 * |x|\\n *\\n * y = \u03C0/4 * (frac << clz(frac) >> 11)\\n * return clz(frac)\\n *\\n * Right shift 11 bits to make upper half fit in `double`\\n */\\n// @ts-ignore: decorator\\n@inline\\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\\n  // Bits of \u03C0/4\\n  const p0: u64 = 0xC4C6628B80DC1CD1;\\n  const p1: u64 = 0xC90FDAA22168C234;\\n\\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\\n\\n  let shift = clz(q1);\\n\\n  q1 = q1 << shift | q0 >> (64 - shift);\\n  q0 <<= shift;\\n\\n  let lo = umuldi(p1, q1);\\n  let hi = res128_hi;\\n\\n  let ahi = hi >> 11;\\n  let alo = lo >> 11 | hi << 53;\\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\\n\\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\\n\\n  return shift;\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction umuldi(u: u64, v: u64): u64 {\\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\\n\\n  u1 = u & 0xFFFFFFFF;\\n  v1 = v & 0xFFFFFFFF;\\n\\n  u >>= 32;\\n  v >>= 32;\\n\\n  t  = u1 * v1;\\n  w0 = t & 0xFFFFFFFF;\\n  t  = u * v1 + (t >> 32);\\n  w1 = t >> 32;\\n  t  = u1 * v + (t & 0xFFFFFFFF);\\n\\n  res128_hi = u * v + w1 + (t >> 32);\\n  return (t << 32) + w0;\\n}\\n\\n/** @internal */\\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\\n  let offset = (magnitude >> 52) - 1045;\\n  let shift  = offset & 63;\\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\\n  let s0: u64, s1: u64, s2: u64;\\n\\n  let b0 = load<u64>(tblPtr, 0 << 3);\\n  let b1 = load<u64>(tblPtr, 1 << 3);\\n  let b2 = load<u64>(tblPtr, 2 << 3);\\n\\n  // Get 192 bits of 0x1p-31 / \u03C0 with `offset` bits skipped\\n  if (shift) {\\n    let rshift = 64 - shift;\\n    let b3 = load<u64>(tblPtr, 3 << 3);\\n    s0 = b1 >> rshift | b0 << shift;\\n    s1 = b2 >> rshift | b1 << shift;\\n    s2 = b3 >> rshift | b2 << shift;\\n  } else {\\n    s0 = b0;\\n    s1 = b1;\\n    s2 = b2;\\n  }\\n\\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\\n\\n  // First 128 bits of fractional part of x/(2\u03C0)\\n  let blo = umuldi(s1, significand);\\n  let bhi = res128_hi;\\n\\n  let ahi = s0 * significand;\\n  let clo = (s2 >> 32) * (significand >> 32);\\n  let plo = blo + clo;\\n  let phi = ahi + bhi + u64(plo < clo);\\n\\n  // r: u128 = p << 2\\n  let rlo = plo << 2;\\n  let rhi = phi << 2 | plo >> 62;\\n\\n  // s: i128 = r >> 127\\n  let slo = <i64>rhi >> 63;\\n  let shi = slo >> 1;\\n  let q   = (<i64>phi >> 62) - slo;\\n\\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\\n  let signbit = (u ^ rhi) & 0x8000000000000000;\\n  let coeff   = reinterpret<f64>(shifter | signbit);\\n\\n  rempio2_y0 *= coeff;\\n  rempio2_y1 *= coeff;\\n\\n  return <i32>q;\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\\n  const\\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\\n\\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\\n\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\\n      let q = 1, z: f64, y0: f64, y1: f64;\\n      if (!sign) {\\n        z = x - pio2_1;\\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\\n          y0 = z - pio2_1t;\\n          y1 = (z - y0) - pio2_1t;\\n        } else { // near pi/2, use 33+33+53 bit pi\\n          z -= pio2_2;\\n          y0 = z - pio2_2t;\\n          y1 = (z - y0) - pio2_2t;\\n        }\\n      } else { // negative x\\n        z = x + pio2_1;\\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\\n          y0 = z + pio2_1t;\\n          y1 = (z - y0) + pio2_1t;\\n        } else { // near pi/2, use 33+33+53 bit pi\\n          z += pio2_2;\\n          y0 = z + pio2_2t;\\n          y1 = (z - y0) + pio2_2t;\\n        }\\n        q = -1;\\n      }\\n      rempio2_y0 = y0;\\n      rempio2_y1 = y1;\\n      return q;\\n    }\\n  }\\n\\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\\n    // Use precise Cody Waite scheme\\n    let q  = nearest(x * invpio2);\\n    let r  = x - q * pio2_1;\\n    let w  = q * pio2_1t; // 1st round good to 85 bit\\n    let j  = ix >> 20;\\n    let y0 = r - w;\\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\\n    let i  = j - ((hi >> 20) & 0x7FF);\\n\\n    if (i > 16) { // 2nd iteration needed, good to 118\\n      let t = r;\\n      w  = q * pio2_2;\\n      r  = t - w;\\n      w  = q * pio2_2t - ((t - r) - w);\\n      y0 = r - w;\\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\\n      i = j - ((hi >> 20) & 0x7FF);\\n      if (i > 49) { // 3rd iteration need, 151 bits acc\\n        let t = r;\\n        w  = q * pio2_3;\\n        r  = t - w;\\n        w  = q * pio2_3t - ((t - r) - w);\\n        y0 = r - w;\\n      }\\n    }\\n    let y1 = (r - y0) - w;\\n    rempio2_y0 = y0;\\n    rempio2_y1 = y1;\\n    return <i32>q;\\n  }\\n  let q = pio2_large_quot(x, u);\\n  return select(-q, q, sign);\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\\n  const\\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\\n  let v = z * x;\\n  if (!iy) {\\n    return x + v * (S1 + z * r);\\n  } else {\\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\\n  }\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\\n  const\\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\\n  let hz = 0.5 * z;\\n  w = 1.0 - hz;\\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\\n}\\n\\n/** @internal */\\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\\n  const\\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\\n\\n  const\\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\\n\\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\\n  let big = ix >= 0x3FE59428;\\n  if (big) { // |x| >= 0.6744\\n    if (hx < 0) { x = -x, y = -y; }\\n    z = pio4 - x;\\n    w = pio4lo - y;\\n    x = z + w;\\n    y = 0.0;\\n  }\\n  z = x * x;\\n  w = z * z;\\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\\n  s = z * x;\\n  r = y + z * (s * (r + v) + y);\\n  r += T0 * s;\\n  w = x + r;\\n  if (big) {\\n    v = iy;\\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\\n  }\\n  if (iy == 1) return w;\\n  let a: f64, t: f64;\\n  z = w;\\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\\n  v = r - (z - x);  // z + v = r + x\\n  t = a = -one / w; // a = -1.0 / w\\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\\n  s = one + t * z;\\n  return t + a * (s + t * v);\\n}\\n\\n/** @internal */\\nfunction dtoi32(x: f64): i32 {\\n  if (ASC_SHRINK_LEVEL > 0) {\\n    const inv32 = 1.0 / 4294967296;\\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\\n  } else {\\n    let result = 0;\\n    let u = reinterpret<u64>(x);\\n    let e = (u >> 52) & 0x7FF;\\n    if (e <= 1023 + 30) {\\n      result = <i32>x;\\n    } else if (e <= 1023 + 30 + 53) {\\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\\n      v = v << e - 1023 - 52 + 32;\\n      result = <i32>(v >> 32);\\n      result = select<i32>(-result, result, <i64>u < 0);\\n    }\\n    return result;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let random_seeded = false;\\n\\n// @ts-ignore: decorator\\n@lazy let random_state0_64: u64, random_state1_64: u64;\\n\\n// @ts-ignore: decorator\\n@lazy let random_state0_32: u32, random_state1_32: u32;\\n\\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\\n  h *= 0xFF51AFD7ED558CCD;\\n  h ^= h >> 33;\\n  h *= 0xC4CEB9FE1A85EC53;\\n  h ^= h >> 33;\\n  return h;\\n}\\n\\nfunction splitMix32(h: u32): u32 {\\n  h += 0x6D2B79F5;\\n  h  = (h ^ (h >> 15)) * (h | 1);\\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\\n  return h ^ (h >> 14);\\n}\\n\\nexport namespace NativeMath {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_sin: f64 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_cos: f64 = 0;\\n\\n  // @ts-ignore: decorator\\n  @inline export function abs(x: f64): f64 {\\n    return builtin_abs<f64>(x);\\n  }\\n\\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\\n      Ox1p_120f = reinterpret<f32>(0x03800000);\\n\\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\\n    let ix = hx & 0x7FFFFFFF;\\n    if (ix >= 0x3FF00000) {\\n      let lx = <u32>reinterpret<u64>(x);\\n      if ((ix - 0x3FF00000 | lx) == 0) {\\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\\n        return 0;\\n      }\\n      return 0 / (x - x);\\n    }\\n    if (ix < 0x3FE00000) {\\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\\n    }\\n    let s: f64, w: f64, z: f64;\\n    if (<i32>hx < 0) {\\n      // z = (1.0 + x) * 0.5;\\n      z = 0.5 + x * 0.5;\\n      s = builtin_sqrt<f64>(z);\\n      w = R(z) * s - pio2_lo;\\n      return 2 * (pio2_hi - (s + w));\\n    }\\n    // z = (1.0 - x) * 0.5;\\n    z = 0.5 - x * 0.5;\\n    s = builtin_sqrt<f64>(z);\\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\\n    let c = (z - df * df) / (s + df);\\n    w = R(z) * s + c;\\n    return 2 * (df + w);\\n  }\\n\\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\\n    let u = reinterpret<u64>(x);\\n    // Prevent propagation for all input values less than 1.0.\\n    // Note musl lib didn't fix this yet.\\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\\n    let e = u >> 52 & 0x7FF;\\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\\n    return log(x) + s;\\n  }\\n\\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\\n      Ox1p_120f = reinterpret<f32>(0x03800000);\\n\\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\\n    let ix = hx & 0x7FFFFFFF;\\n    if (ix >= 0x3FF00000) {\\n      let lx = <u32>reinterpret<u64>(x);\\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\\n      return 0 / (x - x);\\n    }\\n    if (ix < 0x3FE00000) {\\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\\n      return x + x * R(x * x);\\n    }\\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\\n    let s = builtin_sqrt<f64>(z);\\n    let r = R(z);\\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\\n    else {\\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\\n      let c = (z - f * f) / (s + f);\\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\\n    }\\n    return select(-x, x, <i32>hx < 0);\\n  }\\n\\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\\n    let u = reinterpret<u64>(x);\\n    let e = u >> 52 & 0x7FF;\\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\\n    if (e >= 0x3FF + 26) y = log(y) + c;\\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\\n    return builtin_copysign(y, x);\\n  }\\n\\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\\n    const\\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\\n      Ox1p_120f = reinterpret<f32>(0x03800000);\\n\\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\\n    let sx = x;\\n    ix &= 0x7FFFFFFF;\\n    let z: f64;\\n    if (ix >= 0x44100000) {\\n      if (isNaN(x)) return x;\\n      z = atanhi3 + Ox1p_120f;\\n      return builtin_copysign<f64>(z, sx);\\n    }\\n    let id: i32;\\n    if (ix < 0x3FDC0000) {\\n      if (ix < 0x3E400000) return x;\\n      id = -1;\\n    } else {\\n      x = builtin_abs<f64>(x);\\n      if (ix < 0x3FF30000) {\\n        if (ix < 0x3FE60000) {\\n          id = 0;\\n          x = (2.0 * x - 1.0) / (2.0 + x);\\n        } else {\\n          id = 1;\\n          x = (x - 1.0) / (x + 1.0);\\n        }\\n      } else {\\n        if (ix < 0x40038000) {\\n          id = 2;\\n          x = (x - 1.5) / (1.0 + 1.5 * x);\\n        } else {\\n          id = 3;\\n          x = -1.0 / x;\\n        }\\n      }\\n    }\\n    z = x * x;\\n    let w = z * z;\\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\\n    let s3 = x * (s1 + s2);\\n    if (id < 0) return x - s3;\\n    switch (id) {\\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\\n      default: unreachable();\\n    }\\n    return builtin_copysign<f64>(z, sx);\\n  }\\n\\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\\n    let u = reinterpret<u64>(x);\\n    let e = u >> 52 & 0x7FF;\\n    let y = builtin_abs(x);\\n    if (e < 0x3FF - 1) {\\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\\n    } else {\\n      y = 0.5 * log1p(2 * (y / (1 - y)));\\n    }\\n    return builtin_copysign<f64>(y, x);\\n  }\\n\\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\\n    if (isNaN(x) || isNaN(y)) return x + y;\\n    let u = reinterpret<u64>(x);\\n    let ix = <u32>(u >> 32);\\n    let lx = <u32>u;\\n    u = reinterpret<u64>(y);\\n    let iy = <u32>(u >> 32);\\n    let ly = <u32>u;\\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\\n    ix = ix & 0x7FFFFFFF;\\n    iy = iy & 0x7FFFFFFF;\\n    if ((iy | ly) == 0) {\\n      switch (m) {\\n        case 0:\\n        case 1: return  y;\\n        case 2: return  PI;\\n        case 3: return -PI;\\n      }\\n    }\\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\\n    if (ix == 0x7FF00000) {\\n      if (iy == 0x7FF00000) {\\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\\n        return m & 1 ? -t : t;\\n      } else {\\n        let t = m & 2 ? PI : 0;\\n        return m & 1 ? -t : t;\\n      }\\n    }\\n    let z: f64;\\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\\n    else z = atan(builtin_abs<f64>(y / x));\\n    switch (m) {\\n      case 0: return  z;\\n      case 1: return -z;\\n      case 2: return PI - (z - pi_lo);\\n      case 3: return (z - pi_lo) - PI;\\n    }\\n    unreachable();\\n    return 0;\\n  }\\n\\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\\n    const\\n      B1     = <u32>715094163,\\n      B2     = <u32>696219795,\\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\\n    if (hx >= 0x7FF00000) return x + x;\\n    if (hx < 0x00100000) {\\n      u = reinterpret<u64>(x * Ox1p54);\\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\\n      if (hx == 0) return x;\\n      hx = hx / 3 + B2;\\n    } else {\\n      hx = hx / 3 + B1;\\n    }\\n    u &= 1 << 63;\\n    u |= <u64>hx << 32;\\n    let t = reinterpret<f64>(u);\\n    let r = (t * t) * (t / x);\\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\\n    let s = t * t;\\n    r = x / s;\\n    r = (r - t) / (2 * t + r);\\n    t = t + t * r;\\n    return t;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function ceil(x: f64): f64 {\\n    return builtin_ceil<f64>(x);\\n  }\\n\\n  export function clz32(x: f64): f64 {\\n    if (!isFinite(x)) return 32;\\n    /*\\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\\n     *\\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\\n     * our float-point arguments before actual convertion to integers.\\n     */\\n    return builtin_clz(dtoi32(x));\\n  }\\n\\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\\n    let u  = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >> 31;\\n\\n    ux &= 0x7FFFFFFF;\\n\\n    // |x| ~< pi/4\\n    if (ux <= 0x3FE921FB) {\\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\\n        return 1.0;\\n      }\\n      return cos_kern(x, 0);\\n    }\\n\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7FF00000) return x - x;\\n\\n    // argument reduction needed\\n    let n  = rempio2(x, u, sign);\\n    let y0 = rempio2_y0;\\n    let y1 = rempio2_y1;\\n\\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\\n    return (n + 1) & 2 ? -x : x;\\n  }\\n\\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\\n    let u = reinterpret<u64>(x);\\n    u &= 0x7FFFFFFFFFFFFFFF;\\n    x = reinterpret<f64>(u);\\n    let w = <u32>(u >> 32);\\n    let t: f64;\\n    if (w < 0x3FE62E42) {\\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\\n      t = expm1(x);\\n      // return 1 + t * t / (2 * (1 + t));\\n      return 1 + t * t / (2 + 2 * t);\\n    }\\n    if (w < 0x40862E42) {\\n      t = exp(x);\\n      return 0.5 * (t + 1 / t);\\n    }\\n    t = expo2(x, 1);\\n    return t;\\n  }\\n\\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return exp_lut(x);\\n    } else {\\n      const\\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\\n\\n      let hx = u32(reinterpret<u64>(x) >> 32);\\n      let sign = hx >> 31;\\n      hx &= 0x7FFFFFFF;\\n      if (hx >= 0x4086232B) {\\n        if (isNaN(x)) return x;\\n        if (x > overflow)  return x * Ox1p1023;\\n        if (x < underflow) return 0;\\n      }\\n      let hi: f64, lo: f64 = 0;\\n      let k = 0;\\n      if (hx > 0x3FD62E42) {\\n        if (hx >= 0x3FF0A2B2) {\\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\\n        } else {\\n          k = 1 - (sign << 1);\\n        }\\n        hi = x - k * ln2hi;\\n        lo = k * ln2lo;\\n        x = hi - lo;\\n      } else if (hx > 0x3E300000) {\\n        hi = x;\\n      } else return 1.0 + x;\\n      let xs = x * x;\\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\\n      let xq = xs * xs;\\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\\n      return k == 0 ? y : scalbn(y, k);\\n    }\\n  }\\n\\n  export function exp2(x: f64): f64 {\\n    return exp2_lut(x);\\n  }\\n\\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\\n    const\\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\\n    let sign = u32(u >> 63);\\n    let k = 0;\\n    if (hx >= 0x4043687A) {\\n      if (isNaN(x)) return x;\\n      if (sign) return -1;\\n      if (x > o_threshold) return x * Ox1p1023;\\n    }\\n    let c = 0.0, t: f64;\\n    if (hx > 0x3FD62E42) {\\n      k = select<i32>(\\n        1 - (sign << 1),\\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\\n        hx < 0x3FF0A2B2\\n      );\\n      t = <f64>k;\\n      let hi = x - t * ln2_hi;\\n      let lo = t * ln2_lo;\\n      x = hi - lo;\\n      c = (hi - x) - lo;\\n    } else if (hx < 0x3C900000) return x;\\n    let hfx = 0.5 * x;\\n    let hxs = x * hfx;\\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\\n    let hxq = hxs * hxs;\\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\\n    t = 3.0 - r1 * hfx;\\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\\n    if (k == 0) return x - (x * e - hxs);\\n    e = x * (e - c) - c;\\n    e -= hxs;\\n    if (k == -1) return 0.5 * (x - e) - 0.5;\\n    if (k == 1) {\\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\\n      return 1.0 + 2.0 * (x - e);\\n    }\\n    u = (0x3FF + k) << 52;\\n    let twopk = reinterpret<f64>(u);\\n    let y: f64;\\n    if (k < 0 || k > 56) {\\n      y = x - e + 1.0;\\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\\n      else y = y * twopk;\\n      return y - 1.0;\\n    }\\n    u = (0x3FF - k) << 52;\\n    y = reinterpret<f64>(u);\\n    if (k < 20) y = (1 - y) - e;\\n    else y = 1 - (e + y);\\n    return (x + y) * twopk;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function floor(x: f64): f64 {\\n    return builtin_floor<f64>(x);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function fround(x: f64): f64 {\\n    return <f32>x;\\n  }\\n\\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\\n    const\\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\\n\\n    let ux = reinterpret<u64>(x);\\n    let uy = reinterpret<u64>(y);\\n    ux &= 0x7FFFFFFFFFFFFFFF;\\n    uy &= 0x7FFFFFFFFFFFFFFF;\\n    if (ux < uy) {\\n      let ut = ux;\\n      ux = uy;\\n      uy = ut;\\n    }\\n    let ex = i32(ux >> 52);\\n    let ey = i32(uy >> 52);\\n    y = reinterpret<f64>(uy);\\n    if (ey == 0x7FF) return y;\\n    x = reinterpret<f64>(ux);\\n    if (ex == 0x7FF || uy == 0) return x;\\n    if (ex - ey > 64) return x + y;\\n    let z = 1.0;\\n    if (ex > 0x3FF + 510) {\\n      z  = Ox1p700;\\n      x *= Ox1p_700;\\n      y *= Ox1p_700;\\n    } else if (ey < 0x3FF - 450) {\\n      z  = Ox1p_700;\\n      x *= Ox1p700;\\n      y *= Ox1p700;\\n    }\\n    let c = x * SPLIT;\\n    let h = x - c + c;\\n    let l = x - h;\\n    let hx = x * x;\\n    let lx = h * h - hx + (2 * h + l) * l;\\n    c = y * SPLIT;\\n    h = y - c + c;\\n    l = y - h;\\n    let hy = y * y;\\n    let ly = h * h - hy + (2 * h + l) * l;\\n    return z * builtin_sqrt(ly + lx + hy + hx);\\n  }\\n\\n  export function imul(x: f64, y: f64): f64 {\\n    /*\\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\\n     *\\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\\n     * our float-point arguments before actual convertion to integers.\\n     */\\n    if (!isFinite(x + y)) return 0;\\n    return dtoi32(x) * dtoi32(y);\\n  }\\n\\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return log_lut(x);\\n    } else {\\n      const\\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\\n\\n      let u = reinterpret<u64>(x);\\n      let hx = u32(u >> 32);\\n      let k = 0;\\n      let sign = hx >> 31;\\n      if (sign || hx < 0x00100000) {\\n        if (u << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0.0;\\n        k -= 54;\\n        x *= Ox1p54;\\n        u = reinterpret<u64>(x);\\n        hx = u32(u >> 32);\\n      } else if (hx >= 0x7FF00000) {\\n        return x;\\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\\n        return 0;\\n      }\\n      hx += 0x3FF00000 - 0x3FE6A09E;\\n      k += (<i32>hx >> 20) - 0x3FF;\\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\\n      x = reinterpret<f64>(u);\\n      let f = x - 1.0;\\n      let hfsq = 0.5 * f * f;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n      let r = t2 + t1;\\n      let dk = <f64>k;\\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\\n    }\\n  }\\n\\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = u32(u >> 32);\\n    let k = 0;\\n    let sign = hx >> 31;\\n    if (sign || hx < 0x00100000) {\\n      if (u << 1 == 0) return -1 / (x * x);\\n      if (sign) return (x - x) / 0.0;\\n      k -= 54;\\n      x *= Ox1p54;\\n      u = reinterpret<u64>(x);\\n      hx = u32(u >> 32);\\n    } else if (hx >= 0x7FF00000) {\\n      return x;\\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\\n      return 0;\\n    }\\n    hx += 0x3FF00000 - 0x3FE6A09E;\\n    k += i32(hx >> 20) - 0x3FF;\\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\\n    x = reinterpret<f64>(u);\\n    let f = x - 1.0;\\n    let hfsq = 0.5 * f * f;\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n    let r = t2 + t1;\\n    let hi = f - hfsq;\\n    u = reinterpret<u64>(hi);\\n    u &= 0xFFFFFFFF00000000;\\n    hi = reinterpret<f64>(u);\\n    let lo = f - hi - hfsq + s * (hfsq + r);\\n    let val_hi = hi * ivln10hi;\\n    let dk = <f64>k;\\n    let y = dk * log10_2hi;\\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\\n    w = y + val_hi;\\n    val_lo += (y - w) + val_hi;\\n    return val_lo + w;\\n  }\\n\\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = u32(u >> 32);\\n    let k = 1;\\n    let c = 0.0, f = 0.0;\\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\\n      if (hx >= 0xBFF00000) {\\n        if (x == -1) return x / 0.0;\\n        return (x - x) / 0.0;\\n      }\\n      if (hx << 1 < 0x3CA00000 << 1) return x;\\n      if (hx <= 0xBFD2BEC4) {\\n        k = 0;\\n        c = 0;\\n        f = x;\\n      }\\n    } else if (hx >= 0x7FF00000) return x;\\n    if (k) {\\n      u = reinterpret<u64>(1 + x);\\n      let hu = u32(u >> 32);\\n      hu += 0x3FF00000 - 0x3FE6A09E;\\n      k = i32(hu >> 20) - 0x3FF;\\n      if (k < 54) {\\n        let uf = reinterpret<f64>(u);\\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\\n        c /= uf;\\n      } else c = 0;\\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\\n      f = reinterpret<f64>(u) - 1;\\n    }\\n    let hfsq = 0.5 * f * f;\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n    let r = t2 + t1;\\n    let dk = <f64>k;\\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\\n  }\\n\\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return log2_lut(x);\\n    } else {\\n      const\\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\\n\\n      let u = reinterpret<u64>(x);\\n      let hx = u32(u >> 32);\\n      let k = 0;\\n      let sign = hx >> 31;\\n      if (sign || hx < 0x00100000) {\\n        if (u << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0.0;\\n        k -= 54;\\n        x *= Ox1p54;\\n        u = reinterpret<u64>(x);\\n        hx = u32(u >> 32);\\n      } else if (hx >= 0x7FF00000) {\\n        return x;\\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\\n        return 0;\\n      }\\n      hx += 0x3FF00000 - 0x3FE6A09E;\\n      k += i32(hx >> 20) - 0x3FF;\\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\\n      x = reinterpret<f64>(u);\\n      let f = x - 1.0;\\n      let hfsq = 0.5 * f * f;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n      let r = t2 + t1;\\n      let hi = f - hfsq;\\n      u = reinterpret<u64>(hi);\\n      u &= 0xFFFFFFFF00000000;\\n      hi = reinterpret<f64>(u);\\n      let lo = f - hi - hfsq + s * (hfsq + r);\\n      let val_hi = hi * ivln2hi;\\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\\n      let y = <f64>k;\\n      w = y + val_hi;\\n      val_lo += (y - w) + val_hi;\\n      val_hi = w;\\n      return val_lo + val_hi;\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function max(value1: f64, value2: f64): f64 {\\n    return builtin_max<f64>(value1, value2);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function min(value1: f64, value2: f64): f64 {\\n    return builtin_min<f64>(value1, value2);\\n  }\\n\\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\\n    // TODO: remove this fast pathes after introduced own mid-end IR with \\\"stdlib call simplify\\\" transforms\\n    if (builtin_abs<f64>(y) <= 2) {\\n      if (y == 2.0) return x * x;\\n      if (y == 0.5) {\\n        return select<f64>(\\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\\n          Infinity,\\n          x != -Infinity\\n        );\\n      }\\n      if (y == -1.0) return 1 / x;\\n      if (y == 1.0) return x;\\n      if (y == 0.0) return 1.0;\\n    }\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return pow_lut(x, y);\\n    } else {\\n      const\\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\\n\\n      let u_ = reinterpret<u64>(x);\\n      let hx = i32(u_ >> 32);\\n      let lx = <u32>u_;\\n      u_ = reinterpret<u64>(y);\\n      let hy = i32(u_ >> 32);\\n      let ly = <u32>u_;\\n      let ix = hx & 0x7FFFFFFF;\\n      let iy = hy & 0x7FFFFFFF;\\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\\n      if ( // NaN if either arg is NaN\\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\\n      ) return x + y;\\n      let yisint = 0, k: i32;\\n      if (hx < 0) {\\n        if (iy >= 0x43400000) yisint = 2;\\n        else if (iy >= 0x3FF00000) {\\n          k = (iy >> 20) - 0x3FF;\\n          let offset = select<u32>(52, 20, k > 20) - k;\\n          let Ly = select<u32>(ly, iy, k > 20);\\n          let jj = Ly >> offset;\\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\\n        }\\n      }\\n      if (ly == 0) {\\n        if (iy == 0x7FF00000) { // y is +-inf\\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\\n        }\\n        if (iy == 0x3FF00000) {\\n          if (hy >= 0) return x;\\n          return 1 / x;\\n        }\\n        if (hy == 0x40000000) return x * x;\\n        if (hy == 0x3FE00000) {\\n          if (hx >= 0) return builtin_sqrt(x);\\n        }\\n      }\\n      let ax = builtin_abs<f64>(x), z: f64;\\n      if (lx == 0) {\\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\\n          z = ax;\\n          if (hy < 0) z = 1.0 / z;\\n          if (hx < 0) {\\n            if (((ix - 0x3FF00000) | yisint) == 0) {\\n              let d = z - z;\\n              z = d / d;\\n            } else if (yisint == 1) z = -z;\\n          }\\n          return z;\\n        }\\n      }\\n      let s = 1.0;\\n      if (hx < 0) {\\n        if (yisint == 0) {\\n          let d = x - x;\\n          return d / d;\\n        }\\n        if (yisint == 1) s = -1.0;\\n      }\\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\\n      let j: i32, n: i32;\\n      if (iy > 0x41E00000) {\\n        if (iy > 0x43F00000) {\\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\\n        }\\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\\n        t = ax - 1.0;\\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\\n        u = ivln2_h * t;\\n        v = t * ivln2_l - w * ivln2;\\n        t1 = u + v;\\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\\n        t2 = v - (t1 - u);\\n      } else {\\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\\n        n = 0;\\n        if (ix < 0x00100000) {\\n          ax *= two53;\\n          n -= 53;\\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\\n        }\\n        n += (ix >> 20) - 0x3FF;\\n        j = ix & 0x000FFFFF;\\n        ix = j | 0x3FF00000;\\n        if (j <= 0x3988E) k = 0;\\n        else if (j < 0xBB67A) k = 1;\\n        else {\\n          k = 0;\\n          n += 1;\\n          ix -= 0x00100000;\\n        }\\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\\n        u = ax - bp;\\n        v = 1.0 / (ax + bp);\\n        ss = u * v;\\n        s_h = ss;\\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\\n        t_l = ax - (t_h - bp);\\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\\n        s2 = ss * ss;\\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\\n        r += s_l * (s_h + ss);\\n        s2 = s_h * s_h;\\n        t_h = 3.0 + s2 + r;\\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\\n        t_l = r - ((t_h - 3.0) - s2);\\n        u = s_h * t_h;\\n        v = s_l * t_h + t_l * ss;\\n        p_h = u + v;\\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\\n        p_l = v - (p_h - u);\\n        let z_h = cp_h * p_h;\\n        let dp_l = select<f64>(dp_l1, 0.0, k);\\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\\n        t = <f64>n;\\n        let dp_h = select<f64>(dp_h1, 0.0, k);\\n        t1 = ((z_h + z_l) + dp_h) + t;\\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\\n      }\\n      let y1 = y;\\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\\n      p_l = (y - y1) * t1 + y * t2;\\n      p_h = y1 * t1;\\n      z = p_l + p_h;\\n      u_ = reinterpret<u64>(z);\\n      j = u32(u_ >> 32);\\n      let i = <i32>u_;\\n      if (j >= 0x40900000) {\\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\\n        if (p_l + ovt > z - p_h) return s * huge * huge;\\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\\n        if (p_l <= z - p_h) return s * tiny * tiny;\\n      }\\n      i = j & 0x7FFFFFFF;\\n      k = (i >> 20) - 0x3FF;\\n      n = 0;\\n      if (i > 0x3FE00000) {\\n        n = j + (0x00100000 >> (k + 1));\\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\\n        t = 0.0;\\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\\n        if (j < 0) n = -n;\\n        p_h -= t;\\n      }\\n      t = p_l + p_h;\\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\\n      u = t * lg2_h;\\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\\n      z = u + v;\\n      w = v - (z - u);\\n      t = z * z;\\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\\n      z = 1.0 - (r - z);\\n      j = u32(reinterpret<u64>(z) >> 32);\\n      j += n << 20;\\n      if ((j >> 20) <= 0) z = scalbn(z, n);\\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\\n      return s * z;\\n    }\\n  }\\n\\n  export function seedRandom(value: i64): void {\\n    // Instead zero seed use golden ratio:\\n    // phi = (1 + sqrt(5)) / 2\\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\\n    if (value == 0) value = 0x9e3779b97f4a7c15;\\n    random_state0_64 = murmurHash3(value);\\n    random_state1_64 = murmurHash3(~random_state0_64);\\n    random_state0_32 = splitMix32(<u32>value);\\n    random_state1_32 = splitMix32(random_state0_32);\\n    random_seeded = true;\\n  }\\n\\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\\n    let s1 = random_state0_64;\\n    let s0 = random_state1_64;\\n    random_state0_64 = s0;\\n    s1 ^= s1 << 23;\\n    s1 ^= s1 >> 17;\\n    s1 ^= s0;\\n    s1 ^= s0 >> 26;\\n    random_state1_64 = s1;\\n    let r = (s0 >> 12) | 0x3FF0000000000000;\\n    return reinterpret<f64>(r) - 1;\\n  }\\n\\n  export function round(x: f64): f64 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\\n    } else {\\n      let roundUp = builtin_ceil<f64>(x);\\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\\n    }\\n  }\\n\\n  export function sign(x: f64): f64 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\\n    } else {\\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function signbit(x: f64): bool {\\n    return bool(reinterpret<u64>(x) >>> 63);\\n  }\\n\\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\\n    let u  = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >> 31;\\n\\n    ux &= 0x7FFFFFFF;\\n\\n    // |x| ~< pi/4\\n    if (ux <= 0x3FE921FB) {\\n      if (ux < 0x3E500000) { // |x| < 2**-26\\n        return x;\\n      }\\n      return sin_kern(x, 0.0, 0);\\n    }\\n\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7FF00000) return x - x;\\n\\n    // argument reduction needed\\n    let n  = rempio2(x, u, sign);\\n    let y0 = rempio2_y0;\\n    let y1 = rempio2_y1;\\n\\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\\n    return n & 2 ? -x : x;\\n  }\\n\\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\\n    let a = reinterpret<f64>(u);\\n    let w = u32(u >> 32);\\n    let h = builtin_copysign(0.5, x);\\n    if (w < 0x40862E42) {\\n      let t = expm1(a);\\n      if (w < 0x3FF00000) {\\n        if (w < 0x3FF00000 - (26 << 20)) return x;\\n        return h * (2 * t - t * t / (t + 1));\\n      }\\n      return h * (t + t / (t + 1));\\n    }\\n    return expo2(a, 2 * h);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function sqrt(x: f64): f64 {\\n    return builtin_sqrt<f64>(x);\\n  }\\n\\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\\n    let u = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >>> 31;\\n\\n    ux &= 0x7FFFFFFF;\\n\\n    // |x| ~< pi/4\\n    if (ux <= 0x3FE921FB) {\\n      if (ux < 0x3E400000) { // |x| < 2**-27\\n        return x;\\n      }\\n      return tan_kern(x, 0.0, 1);\\n    }\\n\\n    // tan(Inf or NaN) is NaN\\n    if (ux >= 0x7FF00000) return x - x;\\n\\n    let n = rempio2(x, u, sign);\\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\\n  }\\n\\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\\n    let u = reinterpret<u64>(x);\\n    u &= 0x7FFFFFFFFFFFFFFF;\\n    let y = reinterpret<f64>(u);\\n    let w = u32(u >> 32);\\n    let t: f64;\\n    if (w > 0x3FE193EA) {\\n      if (w > 0x40340000) {\\n        t = 1 - 0 / y;\\n      } else {\\n        t = expm1(2 * y);\\n        t = 1 - 2 / (t + 2);\\n      }\\n    } else if (w > 0x3FD058AE) {\\n      t = expm1(2 * y);\\n      t = t / (t + 2);\\n    } else if (w >= 0x00100000) {\\n      t = expm1(-2 * y);\\n      t = -t / (t + 2);\\n    } else t = y;\\n    return builtin_copysign<f64>(t, x);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function trunc(x: f64): f64 {\\n    return builtin_trunc<f64>(x);\\n  }\\n\\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\\n    const\\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\\n\\n    let y = x;\\n    if (n > 1023) {\\n      y *= Ox1p1023;\\n      n -= 1023;\\n      if (n > 1023) {\\n        y *= Ox1p1023;\\n        n = builtin_min<i32>(n - 1023, 1023);\\n      }\\n    } else if (n < -1022) {\\n      // make sure final n < -53 to avoid double\\n      // rounding in the subnormal range\\n      y *= Ox1p_1022 * Ox1p53;\\n      n += 1022 - 53;\\n      if (n < -1022) {\\n        y *= Ox1p_1022 * Ox1p53;\\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\\n      }\\n    }\\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\\n  }\\n\\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\\n    if (builtin_abs<f64>(y) == 1.0) {\\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\\n      // TODO: move this rule to compiler's optimization pass.\\n      // It could be apply for any x % C_pot, where \\\"C_pot\\\" is pow of two const.\\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\\n    }\\n    let ux = reinterpret<u64>(x);\\n    let uy = reinterpret<u64>(y);\\n    let ex = i64(ux >> 52 & 0x7FF);\\n    let ey = i64(uy >> 52 & 0x7FF);\\n    let sx = ux >> 63;\\n    let uy1 = uy << 1;\\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\\n      let m = x * y;\\n      return m / m;\\n    }\\n    let ux1 = ux << 1;\\n    if (ux1 <= uy1) {\\n      return x * f64(ux1 != uy1);\\n    }\\n    if (!ex) {\\n      ex -= builtin_clz<i64>(ux << 12);\\n      ux <<= 1 - ex;\\n    } else {\\n      ux &= u64(-1) >> 12;\\n      ux |= 1 << 52;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<i64>(uy << 12);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u64(-1) >> 12;\\n      uy |= 1 << 52;\\n    }\\n    while (ex > ey) {\\n      if (ux >= uy) {\\n        if (ux == uy) return 0 * x;\\n        ux -= uy;\\n      }\\n      ux <<= 1;\\n      --ex;\\n    }\\n    if (ux >= uy) {\\n      if (ux == uy) return 0 * x;\\n      ux -= uy;\\n    }\\n    // for (; !(ux >> 52); ux <<= 1) --ex;\\n    let shift = builtin_clz<i64>(ux << 11);\\n    ex -= shift;\\n    ux <<= shift;\\n    if (ex > 0) {\\n      ux -= 1 << 52;\\n      ux |= ex << 52;\\n    } else {\\n      ux >>= -ex + 1;\\n    }\\n    return reinterpret<f64>(ux | (sx << 63));\\n  }\\n\\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\\n    let ux = reinterpret<u64>(x);\\n    let uy = reinterpret<u64>(y);\\n    let ex = i64(ux >> 52 & 0x7FF);\\n    let ey = i64(uy >> 52 & 0x7FF);\\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\\n      let m = x * y;\\n      return m / m;\\n    }\\n    if (ux << 1 == 0) return x;\\n    let uxi = ux;\\n    if (!ex) {\\n      ex -= builtin_clz<i64>(uxi << 12);\\n      uxi <<= 1 - ex;\\n    } else {\\n      uxi &= u64(-1) >> 12;\\n      uxi |= 1 << 52;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<i64>(uy << 12);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u64(-1) >> 12;\\n      uy |= 1 << 52;\\n    }\\n    let q: u32 = 0;\\n    do {\\n      if (ex < ey) {\\n        if (ex + 1 == ey) break; // goto end\\n        return x;\\n      }\\n      while (ex > ey) {\\n        if (uxi >= uy) {\\n          uxi -= uy;\\n          ++q;\\n        }\\n        uxi <<= 1;\\n        q <<= 1;\\n        --ex;\\n      }\\n      if (uxi >= uy) {\\n        uxi -= uy;\\n        ++q;\\n      }\\n      if (uxi == 0) ex = -60;\\n      else {\\n        let shift = builtin_clz<i64>(uxi << 11);\\n        ex -= shift;\\n        uxi <<= shift;\\n      }\\n      break;\\n    } while (false);\\n    // end:\\n    if (ex > 0) {\\n      uxi -= 1 << 52;\\n      uxi |= ex << 52;\\n    } else {\\n      uxi >>= -ex + 1;\\n    }\\n    x = reinterpret<f64>(uxi);\\n    y = builtin_abs<f64>(y);\\n    let x2 = x + x;\\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\\n      x -= y;\\n      // ++q;\\n    }\\n    return <i64>ux < 0 ? -x : x;\\n  }\\n\\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\\n    let u = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3FE921FB) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\\n        sincos_sin = x;\\n        sincos_cos = 1;\\n        return;\\n      }\\n      sincos_sin = sin_kern(x, 0, 0);\\n      sincos_cos = cos_kern(x, 0);\\n      return;\\n    }\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) {\\n      let xx = x - x;\\n      sincos_sin = xx;\\n      sincos_cos = xx;\\n      return;\\n    }\\n    // general argument reduction needed\\n    let n = rempio2(x, u, sign);\\n    let y0 = rempio2_y0;\\n    let y1 = rempio2_y1;\\n    let s = sin_kern(y0, y1, 1);\\n    let c = cos_kern(y0, y1);\\n    let sin = s, cos = c;\\n    if (n & 1) {\\n      sin =  c;\\n      cos = -s;\\n    }\\n    if (n & 2) {\\n      sin = -sin;\\n      cos = -cos;\\n    }\\n    sincos_sin = sin;\\n    sincos_cos = cos;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let rempio2f_y: f64;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\\n  0xA2F9836E4E441529,\\n  0xFC2757D1F534DDC0,\\n  0xDB6295993C439041,\\n  0xFE5163ABDEBBC561\\n]);\\n\\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\\n\\n  let p = z * (pS0 + z * (pS1 + z * pS2));\\n  let q: f32 = 1 + z * qS1;\\n  return p / q;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\\n  const                                // see: musl/src/math/__expo2f.c\\n    k    = <u32>235,\\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\\n  // in directed rounding correct sign before rounding or overflow is important\\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // \u03C0 * 0x1p-65 = 8.51530395021638647334e-20\\n\\n  let offset = (u >> 23) - 152;\\n  let shift  = u64(offset & 63);\\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\\n\\n  let b0 = load<u64>(tblPtr, 0 << 3);\\n  let b1 = load<u64>(tblPtr, 1 << 3);\\n  let lo: u64;\\n\\n  if (shift > 32) {\\n    let b2 = load<u64>(tblPtr, 2 << 3);\\n    lo  = b2 >> (96 - shift);\\n    lo |= b1 << (shift - 32);\\n  } else {\\n    lo = b1 >> (32 - shift);\\n  }\\n\\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\\n  let product = mantissa * hi + (mantissa * lo >> 32);\\n  let r: i64 = product << 2;\\n  let q = i32((product >> 62) + (r >>> 63));\\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\\n  return q;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\\n  const\\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\\n\\n  if (u < 0x4DC90FDB) { // \u03C0 * 0x1p28\\n    let q = nearest(x * _2_pi);\\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\\n    return <i32>q;\\n  }\\n\\n  let q = pio2f_large_quot(x, u);\\n  return select(-q, q, sign);\\n}\\n\\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\\n// @ts-ignore: decorator\\n@inline\\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\\n  const\\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = S3 + z * S4;\\n  let s = z * x;\\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\\n}\\n\\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\\n// @ts-ignore: decorator\\n@inline\\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\\n  const\\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = C2 + z * C3;\\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\\n}\\n\\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\\n// @ts-ignore: decorator\\n@inline\\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\\n  const\\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\\n\\n  let z = x * x;\\n  let r = T4 + z * T5;\\n  let t = T2 + z * T3;\\n  let w = z * z;\\n  let s = z * x;\\n  let u = T0 + z * T1;\\n\\n  r = (x + s * u) + (s * w) * (t + w * r);\\n  return f32(odd ? -1 / r : r);\\n}\\n\\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\\n// @ts-ignore: decorator\\n@inline\\nfunction log2f(x: f64): f64 {\\n  const\\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\\n\\n  let i = reinterpret<i64>(x);\\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\\n  x = reinterpret<f64>(i - (exponent << 52));\\n  x = (x - 1) / (x + 1);\\n  let xx = x * x;\\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\\n  return (2 * log2e) * y + <f64>exponent;\\n}\\n\\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\\n// @ts-ignore: decorator\\n@inline\\nfunction exp2f(x: f64): f64 {\\n  const\\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\\n\\n  if (x < -1022) return 0;\\n  if (x >= 1024) return Infinity;\\n\\n  let n = nearest(x);\\n  x -= n;\\n  let xx = x * x;\\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\\n}\\n\\nexport namespace NativeMathf {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const E       = <f32>NativeMath.E;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN2     = <f32>NativeMath.LN2;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN10    = <f32>NativeMath.LN10;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG2E   = <f32>NativeMath.LOG2E;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG10E  = <f32>NativeMath.LOG10E;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const PI      = <f32>NativeMath.PI;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT2   = <f32>NativeMath.SQRT2;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_sin: f32 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_cos: f32 = 0;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function abs(x: f32): f32 {\\n    return builtin_abs<f32>(x);\\n  }\\n\\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\\n\\n    let hx = reinterpret<u32>(x);\\n    let ix = hx & 0x7FFFFFFF;\\n    if (ix >= 0x3F800000) {\\n      if (ix == 0x3F800000) {\\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\\n      }\\n      return 0 / (x - x);\\n    }\\n    if (ix < 0x3F000000) {\\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\\n    }\\n    let z: f32, w: f32, s: f32;\\n    if (<i32>hx < 0) {\\n      // z = (1 + x) * 0.5;\\n      z = 0.5 + x * 0.5;\\n      s = builtin_sqrt<f32>(z);\\n      w = Rf(z) * s - pio2_lo;\\n      return 2 * (pio2_hi - (s + w));\\n    }\\n    // z = (1 - x) * 0.5;\\n    z = 0.5 - x * 0.5;\\n    s = builtin_sqrt<f32>(z);\\n    hx = reinterpret<u32>(s);\\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\\n    let c = (z - df * df) / (s + df);\\n    w = Rf(z) * s + c;\\n    return 2 * (df + w);\\n  }\\n\\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\\n    let u = reinterpret<u32>(x);\\n    let a = u & 0x7FFFFFFF;\\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\\n      let xm1 = x - 1;\\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\\n    }\\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\\n    }\\n    // x >= 0x1p12 or x <= -2 or NaN\\n    return log(x) + s;\\n  }\\n\\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\\n\\n    let sx = x;\\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\\n    if (hx >= 0x3F800000) {\\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\\n      return 0 / (x - x);\\n    }\\n    if (hx < 0x3F000000) {\\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\\n      return x + x * Rf(x * x);\\n    }\\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\\n    let s = builtin_sqrt<f64>(z); // sic\\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\\n    return builtin_copysign(x, sx);\\n  }\\n\\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\\n    let y = reinterpret<f32>(u);\\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\\n    return builtin_copysign(y, x);\\n  }\\n\\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\\n\\n    let ix = reinterpret<u32>(x);\\n    let sx = x;\\n    ix &= 0x7FFFFFFF;\\n    let z: f32;\\n    if (ix >= 0x4C800000) {\\n      if (isNaN(x)) return x;\\n      z = atanhi3 + Ox1p_120f;\\n      return builtin_copysign(z, sx);\\n    }\\n    let id: i32;\\n    if (ix < 0x3EE00000) {\\n      if (ix < 0x39800000) return x;\\n      id = -1;\\n    } else {\\n      x = builtin_abs<f32>(x);\\n      if (ix < 0x3F980000) {\\n        if (ix < 0x3F300000) {\\n          id = 0;\\n          x = (2.0 * x - 1.0) / (2.0 + x);\\n        } else {\\n          id = 1;\\n          x = (x - 1.0) / (x + 1.0);\\n        }\\n      } else {\\n        if (ix < 0x401C0000) {\\n          id = 2;\\n          x = (x - 1.5) / (1.0 + 1.5 * x);\\n        } else {\\n          id = 3;\\n          x = -1.0 / x;\\n        }\\n      }\\n    }\\n    z = x * x;\\n    let w = z * z;\\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\\n    let s2 = w * (aT1 + w * aT3);\\n    let s3 = x * (s1 + s2);\\n    if (id < 0) return x - s3;\\n    switch (id) {\\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\\n      default: unreachable();\\n    }\\n    return builtin_copysign(z, sx);\\n  }\\n\\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\\n    let u = reinterpret<u32>(x);\\n    let y = builtin_abs(x);\\n    if (u < 0x3F800000 - (1 << 23)) {\\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\\n    return builtin_copysign(y, x);\\n  }\\n\\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\\n\\n    if (isNaN(x) || isNaN(y)) return x + y;\\n    let ix = reinterpret<u32>(x);\\n    let iy = reinterpret<u32>(y);\\n    if (ix == 0x3F800000) return atan(y);\\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\\n    ix &= 0x7FFFFFFF;\\n    iy &= 0x7FFFFFFF;\\n    if (iy == 0) {\\n      switch (m) {\\n        case 0:\\n        case 1: return  y;\\n        case 2: return  pi;\\n        case 3: return -pi;\\n      }\\n    }\\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\\n    if (ix == 0x7F800000) {\\n      if (iy == 0x7F800000) {\\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\\n        return m & 1 ? -t : t;\\n      } else {\\n        let t: f32 = m & 2 ? pi : 0.0;\\n        return m & 1 ? -t : t;\\n      }\\n    }\\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\\n    let z: f32;\\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\\n    else z = atan(builtin_abs<f32>(y / x));\\n    switch (m) {\\n      case 0: return  z;\\n      case 1: return -z;\\n      case 2: return pi - (z - pi_lo);\\n      case 3: return (z - pi_lo) - pi;\\n    }\\n    unreachable();\\n    return 0;\\n  }\\n\\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      B1      = <u32>709958130,\\n      B2      = <u32>642849266,\\n      Ox1p24f = reinterpret<f32>(0x4B800000);\\n\\n    let u = reinterpret<u32>(x);\\n    let hx = u & 0x7FFFFFFF;\\n    if (hx >= 0x7F800000) return x + x;\\n    if (hx < 0x00800000) {\\n      if (hx == 0) return x;\\n      u = reinterpret<u32>(x * Ox1p24f);\\n      hx = u & 0x7FFFFFFF;\\n      hx = hx / 3 + B2;\\n    } else {\\n      hx = hx / 3 + B1;\\n    }\\n    u &= 0x80000000;\\n    u |= hx;\\n    let t = <f64>reinterpret<f32>(u);\\n    let r = t * t * t;\\n    t = t * (<f64>x + x + r) / (x + r + r);\\n    r = t * t * t;\\n    t = t * (<f64>x + x + r) / (x + r + r);\\n    return <f32>t;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function ceil(x: f32): f32 {\\n    return builtin_ceil<f32>(x);\\n  }\\n\\n  export function clz32(x: f32): f32 {\\n    if (!isFinite(x)) return 32;\\n    return <f32>builtin_clz(dtoi32(x));\\n  }\\n\\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\\n    const\\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        // raise inexact if x != 0\\n        return 1;\\n      }\\n      return cos_kernf(x);\\n    }\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5\u03C0/4\\n        if (ux > 0x4016CBE3) { // |x|  ~> 3\u03C0/4\\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\\n        } else {\\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\\n        }\\n      }\\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9\u03C0/4\\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7\u03C0/4\\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\\n        } else {\\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\\n        }\\n      }\\n    }\\n\\n    // cos(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) return x - x;\\n\\n    // general argument reduction needed\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n\\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\\n    return (n + 1) & 2 ? -t : t;\\n  }\\n\\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\\n    let u = reinterpret<u32>(x);\\n    u &= 0x7FFFFFFF;\\n    x = reinterpret<f32>(u);\\n    if (u < 0x3F317217) {\\n      if (u < 0x3F800000 - (12 << 23)) return 1;\\n      let t = expm1(x);\\n      // return 1 + t * t / (2 * (1 + t));\\n      return 1 + t * t / (2 + 2 * t);\\n    }\\n    if (u < 0x42B17217) {\\n      let t = exp(x);\\n      // return 0.5 * (t + 1 / t);\\n      return 0.5 * t + 0.5 / t;\\n    }\\n    return expo2f(x, 1);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function floor(x: f32): f32 {\\n    return builtin_floor<f32>(x);\\n  }\\n\\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return expf_lut(x);\\n    } else {\\n      const\\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\\n\\n      let hx = reinterpret<u32>(x);\\n      let sign = hx >> 31;\\n      hx &= 0x7FFFFFFF;\\n      if (hx >= 0x42AEAC50) {\\n        if (hx > 0x7F800000) return x; // NaN\\n        if (hx >= 0x42B17218) {\\n          if (!sign) return x * Ox1p127f;\\n          else if (hx >= 0x42CFF1B5) return 0;\\n        }\\n      }\\n      let hi: f32, lo: f32;\\n      let k: i32;\\n      if (hx > 0x3EB17218) {\\n        if (hx > 0x3F851592) {\\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\\n        } else {\\n          k = 1 - (sign << 1);\\n        }\\n        hi = x - <f32>k * ln2hi;\\n        lo = <f32>k * ln2lo;\\n        x = hi - lo;\\n      } else if (hx > 0x39000000) {\\n        k = 0;\\n        hi = x;\\n        lo = 0;\\n      } else {\\n        return 1 + x;\\n      }\\n      let xx = x * x;\\n      let c = x - xx * (P1 + xx * P2);\\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\\n      return k == 0 ? y : scalbn(y, k);\\n    }\\n  }\\n\\n  export function exp2(x: f32): f32 {\\n    return exp2f_lut(x);\\n  }\\n\\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\\n\\n    let u = reinterpret<u32>(x);\\n    let hx = u & 0x7FFFFFFF;\\n    let sign = u >> 31;\\n    if (hx >= 0x4195B844) {\\n      if (hx > 0x7F800000) return x;\\n      if (sign) return -1;\\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\\n        x *= Ox1p127f;\\n        return x;\\n      }\\n    }\\n    let c: f32 = 0.0, t: f32, k: i32;\\n    if (hx > 0x3EB17218) {\\n      k = select<i32>(\\n        1 - (sign << 1),\\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\\n        hx < 0x3F851592\\n      );\\n      t = <f32>k;\\n      let hi = x - t * ln2_hi;\\n      let lo = t * ln2_lo;\\n      x = hi - lo;\\n      c = (hi - x) - lo;\\n    } else if (hx < 0x33000000) {\\n      return x;\\n    } else k = 0;\\n    let hfx: f32 = 0.5 * x;\\n    let hxs: f32 = x * hfx;\\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\\n    t  = 3.0 - r1 * hfx;\\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\\n    if (k == 0) return x - (x * e - hxs);\\n    e  = x * (e - c) - c;\\n    e -= hxs;\\n    if (k == -1) return 0.5 * (x - e) - 0.5;\\n    if (k == 1) {\\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\\n      return 1.0 + 2.0 * (x - e);\\n    }\\n    u = (0x7F + k) << 23;\\n    let twopk = reinterpret<f32>(u);\\n    let y: f32;\\n    if (k < 0 || k > 56) {\\n      y = x - e + 1.0;\\n      if (k == 128) y = y * 2.0 * Ox1p127f;\\n      else y = y * twopk;\\n      return y - 1.0;\\n    }\\n    u = (0x7F - k) << 23;\\n    y = reinterpret<f32>(u);\\n    if (k < 20) y = (1 - y) - e;\\n    else y = 1 - (e + y);\\n    return (x + y) * twopk;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function fround(x: f32): f32 {\\n    return x;\\n  }\\n\\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\\n    const\\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\\n      Ox1p_90f = reinterpret<f32>(0x12800000);\\n\\n    let ux = reinterpret<u32>(x);\\n    let uy = reinterpret<u32>(y);\\n    ux &= 0x7FFFFFFF;\\n    uy &= 0x7FFFFFFF;\\n    if (ux < uy) {\\n      let ut = ux;\\n      ux = uy;\\n      uy = ut;\\n    }\\n    x = reinterpret<f32>(ux);\\n    y = reinterpret<f32>(uy);\\n    if (uy == 0xFF << 23) return y;\\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\\n    let z: f32 = 1;\\n    if (ux >= (0x7F + 60) << 23) {\\n      z  = Ox1p90f;\\n      x *= Ox1p_90f;\\n      y *= Ox1p_90f;\\n    } else if (uy < (0x7F - 60) << 23) {\\n      z  = Ox1p_90f;\\n      x *= Ox1p90f;\\n      y *= Ox1p90f;\\n    }\\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function imul(x: f32, y: f32): f32 {\\n    /*\\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\\n     *\\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\\n     * our float-point arguments before actual convertion to integers.\\n     */\\n    if (!isFinite(x + y)) return 0;\\n    return <f32>(dtoi32(x) * dtoi32(y));\\n  }\\n\\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return logf_lut(x);\\n    } else {\\n      const\\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\\n        Ox1p25f = reinterpret<f32>(0x4C000000);\\n\\n      let u = reinterpret<u32>(x);\\n      let k = 0;\\n      let sign = u >> 31;\\n      if (sign || u < 0x00800000) {\\n        if (u << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0;\\n        k -= 25;\\n        x *= Ox1p25f;\\n        u = reinterpret<u32>(x);\\n      } else if (u >= 0x7F800000) {\\n        return x;\\n      } else if (u == 0x3F800000) {\\n        return 0;\\n      }\\n      u += 0x3F800000 - 0x3F3504F3;\\n      k += i32(u >> 23) - 0x7F;\\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\\n      x = reinterpret<f32>(u);\\n      let f = x - 1.0;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * Lg4);\\n      let t2 = z * (Lg1 + w * Lg3);\\n      let r = t2 + t1;\\n      let hfsq = <f32>0.5 * f * f;\\n      let dk = <f32>k;\\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\\n    }\\n  }\\n\\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\\n\\n    let ux = reinterpret<u32>(x);\\n    let k = 0;\\n    let sign = ux >> 31;\\n    if (sign || ux < 0x00800000) {\\n      if (ux << 1 == 0) return -1 / (x * x);\\n      if (sign) return (x - x) / 0.0;\\n      k -= 25;\\n      x *= Ox1p25f;\\n      ux = reinterpret<u32>(x);\\n    } else if (ux >= 0x7F800000) {\\n      return x;\\n    } else if (ux == 0x3F800000) {\\n      return 0;\\n    }\\n    ux += 0x3F800000 - 0x3F3504F3;\\n    k += i32(ux >> 23) - 0x7F;\\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\\n    x = reinterpret<f32>(ux);\\n    let f = x - 1.0;\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * Lg4);\\n    let t2 = z * (Lg1 + w * Lg3);\\n    let r = t2 + t1;\\n    let hfsq: f32 = 0.5 * f * f;\\n    let hi = f - hfsq;\\n    ux = reinterpret<u32>(hi);\\n    ux &= 0xFFFFF000;\\n    hi = reinterpret<f32>(ux);\\n    let lo = f - hi - hfsq + s * (hfsq + r);\\n    let dk = <f32>k;\\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\\n  }\\n\\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\\n\\n    let ix = reinterpret<u32>(x);\\n    let c: f32 = 0;\\n    let f: f32 = 0;\\n    let k = 1;\\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\\n      if (ix >= 0xBF800000) {\\n        if (x == -1) return x / 0.0;\\n        return (x - x) / 0.0;\\n      }\\n      if (ix << 1 < 0x33800000 << 1) return x;\\n      if (ix <= 0xBE95F619) {\\n        k = 0;\\n        c = 0;\\n        f = x;\\n      }\\n    } else if (ix >= 0x7F800000) return x;\\n    if (k) {\\n      let uf: f32 = 1 + x;\\n      let iu = reinterpret<u32>(uf);\\n      iu += 0x3F800000 - 0x3F3504F3;\\n      k = i32(iu >> 23) - 0x7F;\\n      if (k < 25) {\\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\\n        c /= uf;\\n      } else c = 0;\\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\\n      f = reinterpret<f32>(iu) - 1;\\n    }\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * Lg4);\\n    let t2 = z * (Lg1 + w * Lg3);\\n    let r = t2 + t1;\\n    let hfsq: f32 = 0.5 * f * f;\\n    let dk = <f32>k;\\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\\n  }\\n\\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return log2f_lut(x);\\n    } else {\\n      const\\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\\n\\n      let ux = reinterpret<u32>(x);\\n      let k = 0;\\n      let sign = ux >> 31;\\n      if (sign || ux < 0x00800000) {\\n        if (ux << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0.0;\\n        k -= 25;\\n        x *= Ox1p25f;\\n        ux = reinterpret<u32>(x);\\n      } else if (ux >= 0x7F800000) {\\n        return x;\\n      } else if (ux == 0x3F800000) {\\n        return 0;\\n      }\\n      ux += 0x3F800000 - 0x3F3504F3;\\n      k += i32(ux >> 23) - 0x7F;\\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\\n      x = reinterpret<f32>(ux);\\n      let f = x - 1.0;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * Lg4);\\n      let t2 = z * (Lg1 + w * Lg3);\\n      let r = t2 + t1;\\n      let hfsq: f32 = 0.5 * f * f;\\n      let hi = f - hfsq;\\n      let u = reinterpret<u32>(hi);\\n      u &= 0xFFFFF000;\\n      hi = reinterpret<f32>(u);\\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\\n      let dk = <f32>k;\\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function max(value1: f32, value2: f32): f32 {\\n    return builtin_max<f32>(value1, value2);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function min(value1: f32, value2: f32): f32 {\\n    return builtin_min<f32>(value1, value2);\\n  }\\n\\n  export function pow(x: f32, y: f32): f32 {\\n    // TODO: remove this fast pathes after introduced own mid-end IR with \\\"stdlib call simplify\\\" transforms\\n    if (builtin_abs<f32>(y) <= 2) {\\n      if (y == 2.0) return x * x;\\n      if (y == 0.5) {\\n        return select<f32>(\\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\\n          Infinity,\\n          x != -Infinity\\n        );\\n      }\\n      if (y == -1.0) return 1 / x;\\n      if (y == 1.0) return x;\\n      if (y == 0.0) return 1.0;\\n    }\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      // see: musl/src/math/powf.c\\n      return powf_lut(x, y);\\n    } else {\\n      // based on:  jdh8/metallic/src/math/float/powf.c\\n      if (y == 0) return 1;\\n      // @ts-ignore: cast\\n      if (isNaN(x) | isNaN(y)) {\\n        return NaN;\\n      }\\n      let sign: u32 = 0;\\n      let uy = reinterpret<u32>(y);\\n      let ux = reinterpret<u32>(x);\\n      let sx = ux >> 31;\\n      ux &= 0x7FFFFFFF;\\n      if (sx && nearest(y) == y) {\\n        x = -x;\\n        sx = 0;\\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\\n      }\\n      let m: u32;\\n      if (ux == 0x3F800000) { // x == 1\\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\\n      } else if (ux == 0) {\\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\\n      } else if (ux == 0x7F800000) {\\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\\n      } else if (sx) {\\n        m = 0x7FC00000;\\n      } else {\\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\\n      }\\n      return reinterpret<f32>(m | sign);\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function seedRandom(value: i64): void {\\n    NativeMath.seedRandom(value);\\n  }\\n\\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\\n  export function random(): f32 {\\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\\n\\n    let s0 = random_state0_32;\\n    let s1 = random_state1_32;\\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\\n\\n    s1 ^= s0;\\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\\n    random_state1_32 = rotl<u32>(s1, 13);\\n\\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\\n  }\\n\\n  export function round(x: f32): f32 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\\n    } else {\\n      let roundUp = builtin_ceil<f32>(x);\\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\\n    }\\n  }\\n\\n  export function sign(x: f32): f32 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\\n    } else {\\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function signbit(x: f32): bool {\\n    return <bool>(reinterpret<u32>(x) >>> 31);\\n  }\\n\\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\\n    const\\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        return x;\\n      }\\n      return sin_kernf(x);\\n    }\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4\\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4\\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\\n        }\\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\\n      }\\n\\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4\\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4\\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\\n        }\\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\\n      }\\n    }\\n\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) return x - x;\\n\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n\\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\\n    return n & 2 ? -t : t;\\n  }\\n\\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\\n    let a = reinterpret<f32>(u);\\n    let h = builtin_copysign<f32>(0.5, x);\\n    if (u < 0x42B17217) {\\n      let t = expm1(a);\\n      if (u < 0x3F800000) {\\n        if (u < 0x3F800000 - (12 << 23)) return x;\\n        return h * (2 * t - t * t / (t + 1));\\n      }\\n      return h * (t + t / (t + 1));\\n    }\\n    return expo2f(a, 2 * h);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function sqrt(x: f32): f32 {\\n    return builtin_sqrt<f32>(x);\\n  }\\n\\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\\n    const\\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        return x;\\n      }\\n      return tan_kernf(x, 0);\\n    }\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4\\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4\\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\\n        } else {\\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\\n        }\\n      }\\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4\\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4\\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\\n        } else {\\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\\n        }\\n      }\\n    }\\n\\n    // tan(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) return x - x;\\n\\n    // argument reduction\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n    return tan_kernf(y, n & 1);\\n  }\\n\\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\\n    let u = reinterpret<u32>(x);\\n    u &= 0x7FFFFFFF;\\n    let y = reinterpret<f32>(u);\\n    let t: f32;\\n    if (u > 0x3F0C9F54) {\\n      if (u > 0x41200000) t = 1 + 0 / y;\\n      else {\\n        t = expm1(2 * y);\\n        t = 1 - 2 / (t + 2);\\n      }\\n    } else if (u > 0x3E82C578) {\\n      t = expm1(2 * y);\\n      t = t / (t + 2);\\n    } else if (u >= 0x00800000) {\\n      t = expm1(-2 * y);\\n      t = -t / (t + 2);\\n    } else t = y;\\n    return builtin_copysign<f32>(t, x);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function trunc(x: f32): f32 {\\n    return builtin_trunc<f32>(x);\\n  }\\n\\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\\n    const\\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\\n      Ox1p_126f = reinterpret<f32>(0x00800000);\\n\\n    let y = x;\\n    if (n > 127) {\\n      y *= Ox1p127f;\\n      n -= 127;\\n      if (n > 127) {\\n        y *= Ox1p127f;\\n        n = builtin_min<i32>(n - 127, 127);\\n      }\\n    } else if (n < -126) {\\n      y *= Ox1p_126f * Ox1p24f;\\n      n += 126 - 24;\\n      if (n < -126) {\\n        y *= Ox1p_126f * Ox1p24f;\\n        n = builtin_max<i32>(n + 126 - 24, -126);\\n      }\\n    }\\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\\n  }\\n\\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\\n    if (builtin_abs<f32>(y) == 1.0) {\\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\\n      // TODO: move this rule to compiler's optimization pass.\\n      // It could be apply for any x % C_pot, where \\\"C_pot\\\" is pow of two const.\\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\\n    }\\n    let ux = reinterpret<u32>(x);\\n    let uy = reinterpret<u32>(y);\\n    let ex = i32(ux >> 23 & 0xFF);\\n    let ey = i32(uy >> 23 & 0xFF);\\n    let sm = ux & 0x80000000;\\n    let uy1 = uy << 1;\\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\\n      let m = x * y;\\n      return m / m;\\n    }\\n    let ux1 = ux << 1;\\n    if (ux1 <= uy1) {\\n      return x * f32(ux1 != uy1);\\n    }\\n    if (!ex) {\\n      ex -= builtin_clz<u32>(ux << 9);\\n      ux <<= 1 - ex;\\n    } else {\\n      ux &= <u32>-1 >> 9;\\n      ux |= 1 << 23;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<u32>(uy << 9);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u32(-1) >> 9;\\n      uy |= 1 << 23;\\n    }\\n    while (ex > ey) {\\n      if (ux >= uy) {\\n        if (ux == uy) return 0 * x;\\n        ux -= uy;\\n      }\\n      ux <<= 1;\\n      --ex;\\n    }\\n    if (ux >= uy) {\\n      if (ux == uy) return 0 * x;\\n      ux -= uy;\\n    }\\n    // for (; !(ux >> 23); ux <<= 1) --ex;\\n    let shift = <i32>builtin_clz<u32>(ux << 8);\\n    ex -= shift;\\n    ux <<= shift;\\n    if (ex > 0) {\\n      ux -= 1 << 23;\\n      ux |= <u32>ex << 23;\\n    } else {\\n      ux >>= -ex + 1;\\n    }\\n    return reinterpret<f32>(ux | sm);\\n  }\\n\\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\\n    let ux = reinterpret<u32>(x);\\n    let uy = reinterpret<u32>(y);\\n    let ex = i32(ux >> 23 & 0xFF);\\n    let ey = i32(uy >> 23 & 0xFF);\\n    let uxi = ux;\\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\\n    if (ux << 1 == 0) return x;\\n    if (!ex) {\\n      ex -= builtin_clz<u32>(uxi << 9);\\n      uxi <<= 1 - ex;\\n    } else {\\n      uxi &= u32(-1) >> 9;\\n      uxi |= 1 << 23;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<u32>(uy << 9);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u32(-1) >> 9;\\n      uy |= 1 << 23;\\n    }\\n    let q = 0;\\n    do {\\n      if (ex < ey) {\\n        if (ex + 1 == ey) break; // goto end\\n        return x;\\n      }\\n      while (ex > ey) {\\n        if (uxi >= uy) {\\n          uxi -= uy;\\n          ++q;\\n        }\\n        uxi <<= 1;\\n        q <<= 1;\\n        --ex;\\n      }\\n      if (uxi >= uy) {\\n        uxi -= uy;\\n        ++q;\\n      }\\n      if (uxi == 0) ex = -30;\\n      else {\\n        let shift = builtin_clz<i32>(uxi << 8);\\n        ex -= shift;\\n        uxi <<= shift;\\n      }\\n      break;\\n    } while (false);\\n    // end:\\n    if (ex > 0) {\\n      uxi -= 1 << 23;\\n      uxi |= <u32>ex << 23;\\n    } else {\\n      uxi >>= -ex + 1;\\n    }\\n    x = reinterpret<f32>(uxi);\\n    y = builtin_abs<f32>(y);\\n    let x2 = x + x;\\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\\n      x -= y;\\n      // q++;\\n    }\\n    return <i32>ux < 0 ? -x : x;\\n  }\\n\\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\\n    const\\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        sincos_sin = x;\\n        sincos_cos = 1;\\n        return;\\n      }\\n      sincos_sin = sin_kernf(x);\\n      sincos_cos = cos_kernf(x);\\n      return;\\n    }\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4\\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4\\n          if (sign) {\\n            sincos_sin = -cos_kernf(x + s1pio2);\\n            sincos_cos =  sin_kernf(x + s1pio2);\\n          } else {\\n            sincos_sin = cos_kernf(s1pio2 - x);\\n            sincos_cos = sin_kernf(s1pio2 - x);\\n          }\\n          return;\\n        }\\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\\n        return;\\n      }\\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4\\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4\\n          if (sign) {\\n            sincos_sin =  cos_kernf(x + s3pio2);\\n            sincos_cos = -sin_kernf(x + s3pio2);\\n          } else {\\n            sincos_sin = -cos_kernf(x - s3pio2);\\n            sincos_cos =  sin_kernf(x - s3pio2);\\n          }\\n          return;\\n        }\\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\\n        return;\\n      }\\n    }\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) {\\n      let xx = x - x;\\n      sincos_sin = xx;\\n      sincos_cos = xx;\\n      return;\\n    }\\n    // general argument reduction needed\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n    let s = sin_kernf(y);\\n    let c = cos_kernf(y);\\n    let sin = s, cos = c;\\n    if (n & 1) {\\n      sin =  c;\\n      cos = -s;\\n    }\\n    if (n & 2) {\\n      sin = -sin;\\n      cos = -cos;\\n    }\\n    sincos_sin = sin;\\n    sincos_cos = cos;\\n  }\\n}\\n\\nexport function ipow32(x: i32, e: i32): i32 {\\n  let out = 1;\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (x == 2) {\\n      return select<i32>(1 << e, 0, <u32>e < 32);\\n    }\\n    if (e <= 0) {\\n      if (x == -1) return select<i32>(-1, 1, e & 1);\\n      return i32(e == 0) | i32(x == 1);\\n    }\\n    else if (e == 1) return x;\\n    else if (e == 2) return x * x;\\n    else if (e < 32) {\\n      let log = 32 - clz(e);\\n      // 32 = 2 ^ 5, so need only five cases.\\n      // But some extra cases needs for properly overflowing\\n      switch (log) {\\n        case 5: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 4: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 3: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 2: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 1: {\\n          if (e & 1) out *= x;\\n        }\\n      }\\n      return out;\\n    }\\n  }\\n  while (e) {\\n    if (e & 1) out *= x;\\n    e >>>= 1;\\n    x *= x;\\n  }\\n  return out;\\n}\\n\\nexport function ipow64(x: i64, e: i64): i64 {\\n  let out: i64 = 1;\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (x == 2) {\\n      return select<i64>(1 << e, 0, <u64>e < 64);\\n    }\\n    if (e <= 0) {\\n      if (x == -1) return select<i64>(-1, 1, e & 1);\\n      return i64(e == 0) | i64(x == 1);\\n    }\\n    else if (e == 1) return x;\\n    else if (e == 2) return x * x;\\n    else if (e < 64) {\\n      let log = 64 - <i32>clz(e);\\n      // 64 = 2 ^ 6, so need only six cases.\\n      // But some extra cases needs for properly overflowing\\n      switch (log) {\\n        case 6: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 5: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 4: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 3: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 2: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 1: {\\n          if (e & 1) out *= x;\\n        }\\n      }\\n      return out;\\n    }\\n  }\\n  while (e) {\\n    if (e & 1) out *= x;\\n    e >>>= 1;\\n    x *= x;\\n  }\\n  return out;\\n}\\n\\n/*\\nTODO:\\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\\nwhich usually faster than exponentiation by squaring\\n\\nfor ipow32 and e < 32:\\n\\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\\nswitch (e) {\\n  case  1: return x;\\n  case  2: return x * x;\\n  case  3: return x * x * x;\\n  case  4: return (b = x * x) * b;\\n  case  5: return (b = x * x) * b * x;\\n  case  6: return (b = x * x) * b * b;\\n  case  7: return (b = x * x) * b * b * x;\\n  case  8: return (d = (b = x * x) * b) * d;\\n  case  9: return (c = x * x * x) * c * c;\\n  case 10: return (d = (b = x * x) * b) * d * b;\\n  case 11: return (d = (b = x * x) * b) * d * b * x;\\n  case 12: return (d = (b = x * x) * b) * d * d;\\n  case 13: return (d = (b = x * x) * b) * d * d * x;\\n  case 14: return (d = (b = x * x) * b) * d * d * b;\\n  case 15: return (k = (b = x * x) * b * x) * k * k;\\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\\n}\\n\\nfor ipow64: TODO\\nswitch (e) {\\n  case 32:\\n  ...\\n  case 63:\\n}\\n*/\\n\",\n  \"memory\": \"import { memcmp, memmove, memset } from \\\"./util/memory\\\";\\nimport { E_NOTIMPLEMENTED } from \\\"./util/error\\\";\\n\\n/** Memory manager interface. */\\nexport namespace memory {\\n\\n  /** Gets the size of the memory in pages. */\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function size(): i32;\\n\\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function grow(pages: i32): i32;\\n\\n  /** Fills a section in memory with the specified byte value. */\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export function fill(dst: usize, c: u8, n: usize): void {\\n    memset(dst, c, n); // fallback if \\\"bulk-memory\\\" isn't enabled\\n  }\\n\\n  /** Copies a section of memory to another. Has move semantics. */\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export function copy(dst: usize, src: usize, n: usize): void {\\n    memmove(dst, src, n); // fallback if \\\"bulk-memory\\\" isn't enabled\\n  }\\n\\n  export namespace atomic {\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function wait32(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function wait64(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\\n  }\\n\\n  /** Initializes a memory segment. */\\n  // @ts-ignore: decorator\\n  @unsafe\\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  /** Drops a memory segment. */\\n  // @ts-ignore: decorator\\n  @unsafe\\n  export function drop(segmentIndex: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  /** Repeats a section of memory at a specific address. */\\n  // @ts-ignore: decorator\\n  @unsafe\\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\\n    let index: usize = 0;\\n    let total = srcLength * count;\\n    while (index < total) {\\n      memory.copy(dst + index, src, srcLength);\\n      index += srcLength;\\n    }\\n  }\\n\\n  /** Compares a section of memory to another. */\\n  // @ts-ignore: decorator\\n  @inline\\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\\n    return memcmp(vl, vr, n);\\n  }\\n\\n  /** Gets a pointer to a static chunk of memory of the given size. */\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function data<T>(size: T, align?: i32): usize;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare const __data_end: usize;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare let __stack_pointer: usize;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare const __heap_base: usize;\\n\\n/** Heap memory interface. */\\nexport namespace heap {\\n\\n  /** Allocates a chunk of memory of at least the specified size. */\\n  // @ts-ignore: decorator\\n  @unsafe export function alloc(size: usize): usize {\\n    return __alloc(size);\\n  }\\n\\n  /** Reallocates a chunk of memory to have at least the specified size. */\\n  // @ts-ignore: decorator\\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\\n    return __realloc(ptr, size);\\n  }\\n\\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\\n  // @ts-ignore: decorator\\n  @unsafe export function free(ptr: usize): void {\\n    __free(ptr);\\n  }\\n\\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\\n  // @ts-ignore: decorator\\n  @unsafe export function reset(): void {\\n    if (isDefined(__reset)) {\\n      __reset();\\n    } else {\\n      throw new Error(E_NOTIMPLEMENTED);\\n    }\\n  }\\n}\\n\",\n  \"number\": \"import { itoa32, utoa32, itoa64, utoa64, dtoa } from \\\"./util/number\\\";\\nimport { strtol, strtod } from \\\"./util/string\\\";\\n\\n// @ts-ignore: decorator\\n@builtin @inline\\nexport const NaN: f64 = 0 / 0; // context-aware\\n\\n// @ts-ignore: decorator\\n@builtin @inline\\nexport const Infinity: f64 = 1 / 0; // context-aware\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isNaN<T extends number>(value: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isFinite<T extends number>(value: T): bool;\\n\\n@final @unmanaged\\nexport abstract class I8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i8 {\\n    return <i8>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: i8, radix: i32 = 10): String {\\n    return itoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class I16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i16 {\\n    return <i16>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: i16, radix: i32 = 10): String {\\n    return itoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class I32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i32 {\\n    return <i32>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: i32, radix: i32 = 10): String {\\n    return itoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class I64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i64 {\\n    return strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: i64, radix: i32 = 10): String {\\n    return itoa64(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class Isize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): isize {\\n    return <isize>strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: isize, radix: i32 = 10): String {\\n    if (sizeof<isize>() == 4) {\\n      return itoa32(<i32>this, radix);\\n    } else {\\n      return itoa64(<i64>this, radix);\\n    }\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u8 {\\n    return <u8>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: u8, radix: i32 = 10): String {\\n    return utoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u16 {\\n    return <u16>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: u16, radix: i32 = 10): String {\\n    return utoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u32 {\\n    return <u32>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: u32, radix: i32 = 10): String {\\n    return utoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u64 {\\n    return <u64>strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: u64, radix: i32 = 10): String {\\n    return utoa64(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class Usize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): usize {\\n    return <usize>strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: usize, radix: i32 = 10): String {\\n    if (sizeof<usize>() == 4) {\\n      return utoa32(<u32>this, radix);\\n    } else {\\n      return utoa64(<u64>this, radix);\\n    }\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class Bool {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\\n\\n  toString(this: bool, radix: i32 = 0): String {\\n    return this ? \\\"true\\\" : \\\"false\\\";\\n  }\\n}\\n\\nexport { Bool as Boolean };\\n\\n@final @unmanaged\\nexport abstract class F32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly EPSILON: f32 = f32.EPSILON;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NaN: f32 = f32.NaN;\\n\\n  static isNaN(value: f32): bool {\\n    return isNaN<f32>(value);\\n  }\\n\\n  static isFinite(value: f32): bool {\\n    return isFinite<f32>(value);\\n  }\\n\\n  static isSafeInteger(value: f32): bool {\\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\\n  }\\n\\n  static isInteger(value: f32): bool {\\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\\n  }\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): f32 {\\n    return <f32>strtol<f64>(value, radix);\\n  }\\n\\n  /** @deprecated */\\n  static parseFloat(value: string): f32 {\\n    return <f32>strtod(value);\\n  }\\n\\n  toString(this: f32, radix: i32 = 0): String {\\n    return dtoa(this);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class F64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly EPSILON: f64 = f64.EPSILON;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NaN: f64 = f64.NaN;\\n\\n  static isNaN(value: f64): bool {\\n    return isNaN<f64>(value);\\n  }\\n\\n  static isFinite(value: f64): bool {\\n    return isFinite<f64>(value);\\n  }\\n\\n  static isSafeInteger(value: f64): bool {\\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\\n  }\\n\\n  static isInteger(value: f64): bool {\\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\\n  }\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): f64 {\\n    return strtol<f64>(value, radix);\\n  }\\n\\n  /** @deprecated */\\n  static parseFloat(value: string): f64 {\\n    return strtod(value);\\n  }\\n\\n  toString(this: f64, radix: i32 = 0): String {\\n    return dtoa(this);\\n  }\\n}\\n\\nexport { F64 as Number };\\n\",\n  \"object\": \"export abstract class Object {\\n  static is<T>(x: T, y: T): bool {\\n    if (isFloat<T>()) {\\n      // Float pointing is special we shoulr presere following identities:\\n      // 0.0 !=-0.0\\n      // NaN == NaN\\n      if (sizeof<T>() == 8) {\\n        return (\\n          bool(u32(x != x) & u32(y != y) |\\n          u32(reinterpret<u64>(f64(x)) == reinterpret<u64>(f64(y))))\\n        );\\n      } else {\\n        return (\\n          bool(u32(x != x) & u32(y != y) |\\n          u32(reinterpret<u32>(f32(x)) == reinterpret<u32>(f32(y))))\\n        );\\n      }\\n    }\\n    // For references, strings, integers and booleans\\n    return x == y;\\n  }\\n\\n  // TODO: Wrapper classes like `Function<T>` override the `this` type of\\n  // `toString`, which is covariant and hence fails to overload. Wrapper classes\\n  // might need a different mechanism to indicate such special `this` types.\\n  // toString(): string {\\n  //   return \\\"[object Object]\\\";\\n  // }\\n}\\n\\n// TODO: The types `Object` and `object` differ in TypeScript, in that the\\n// latter indicates any non-primitive type, not including `string` for example.\\n// The `object` type hence remains reserved for now, also to potentially address\\n// the above `toString` TODO in alternative ways.\\n// @ts-ignore: nolib\\n// export type object = Object;\\n\",\n  \"performance\": \"import {\\n  performance as performance_binding\\n} from \\\"bindings/dom\\\";\\n\\nexport namespace performance {\\n  export function now(): f64 {\\n    return performance_binding.now();\\n  }\\n}\\n\",\n  \"polyfills\": \"export function bswap<T extends number>(value: T): T {\\n  if (isInteger<T>()) {\\n    if (sizeof<T>() == 1) {\\n      return value;\\n    }\\n    if (sizeof<T>() == 2) {\\n      return <T>(<u16>value << 8 | (<u16>value >> 8));\\n    }\\n    if (sizeof<T>() == 4) {\\n      return <T>(\\n        rotl(<u32>value & 0xFF00FF00, 8) |\\n        rotr(<u32>value & 0x00FF00FF, 8)\\n      );\\n    }\\n    if (sizeof<T>() == 8) {\\n      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\\n      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;\\n      let v = a | b;\\n\\n      a = (v >>> 16) & 0x0000FFFF0000FFFF;\\n      b = (v & 0x0000FFFF0000FFFF) << 16;\\n\\n      return <T>rotr(a | b, 32);\\n    }\\n  }\\n  ERROR(\\\"Unsupported generic type\\\");\\n}\\n\",\n  \"process\": \"import {\\n  Date as Date_binding,\\n  performance as performance_binding\\n} from \\\"bindings/dom\\\";\\n\\nimport {\\n  process as process_binding\\n} from \\\"bindings/node\\\";\\n\\nexport namespace process {\\n\\n  // @ts-ignore: decorator\\n  @lazy export const arch = sizeof<usize>() == 4 ? \\\"wasm32\\\" : \\\"wasm64\\\";\\n\\n  // @ts-ignore: decorator\\n  @lazy export const platform = \\\"wasm\\\";\\n\\n  // @ts-ignore: decorator\\n  @lazy export const argv = lazyArgv();\\n\\n  // @ts-ignore: decorator\\n  @lazy export const env = lazyEnv();\\n\\n  // @ts-ignore: decorator\\n  @lazy export let exitCode = 0;\\n\\n  export function exit(code: i32 = exitCode): void {\\n    process_binding.exit(code);\\n  }\\n\\n  export function time(): i64 {\\n    return <i64>Date_binding.now();\\n  }\\n\\n  export function hrtime(): u64 {\\n    let now = performance_binding.now();\\n    let millis = <u64>now;\\n    let fraction = now - <f64>millis;\\n    return millis * 1000000 + <u64>(fraction * 1000000);\\n  }\\n}\\n\\nfunction lazyArgv(): string[] {\\n  return process_binding.argv;\\n}\\n\\nfunction lazyEnv(): Map<string,string> {\\n  // TODO: What about Node?\\n  return new Map();\\n}\\n\",\n  \"reference\": \"// Canonical aliases\\nexport type funcref = ref_func | null;\\nexport type externref = ref_extern | null;\\nexport type anyref = ref_any | null;\\nexport type eqref = ref_eq | null;\\nexport type i31ref = ref_i31 | null;\\nexport type structref = ref_struct | null;\\nexport type arrayref = ref_array | null;\\nexport type stringref = ref_string | null;\\nexport type stringview_wtf8 = ref_stringview_wtf8 | null;\\nexport type stringview_wtf16 = ref_stringview_wtf16 | null;\\nexport type stringview_iter = ref_stringview_iter | null;\\n\\n@unmanaged\\nabstract class Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefFunc extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefExtern extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefAny extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefEq extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefI31 extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefStruct extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefArray extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class RefString extends Ref {\\n}\\n\",\n  \"regexp\": \"export class RegExp {\\n\\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\\n  constructor(pattern: string, flags: string = \\\"\\\") { throw new Error(\\\"unreachable\\\"); }\\n\\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\\n  test(search: string): bool { throw new Error(\\\"unreachable\\\"); }\\n\\n  // @binding(CALL_THIS, [], STRING)\\n  toString(): string { throw new Error(\\\"unreachable\\\"); }\\n\\n}\\n\",\n  \"rt\": \"import { Typeinfo, TypeinfoFlags } from \\\"./shared/typeinfo\\\";\\nimport { E_INDEXOUTOFRANGE } from \\\"./util/error\\\";\\nimport { ArrayBufferView } from \\\"./arraybuffer\\\";\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare const __rtti_base: usize;\\n\\n// @ts-ignore: decorator\\n@builtin @unsafe\\nexport declare function __visit_globals(cookie: u32): void;\\n\\n// @ts-ignore: decorator\\n@builtin @unsafe\\nexport declare function __visit_members(ref: usize, cookie: u32): void;\\n\\n// @ts-ignore: decorator\\n@unsafe\\nexport function __typeinfo(id: u32): TypeinfoFlags {\\n  let ptr = __rtti_base;\\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe\\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\\n  let buffer = __new(size, id);\\n  if (data) memory.copy(buffer, data, size);\\n  return buffer;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe\\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\\n  let bufferSize = <usize>length << alignLog2;\\n  // make sure `buffer` is tracked by the shadow stack\\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\\n  // ...since allocating the array may trigger GC steps\\n  let array = __new(offsetof<i32[]>(), id);\\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\\\"buffer\\\"));\\n  __link(array, changetype<usize>(buffer), false);\\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\\\"dataStart\\\"));\\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\\\"byteLength\\\"));\\n  store<i32>(array, length, offsetof<i32[]>(\\\"length_\\\"));\\n  return array;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\\n  return ptr;\\n}\\n\\n// These are provided by the respective implementation, included as another entry file by asc:\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __alloc(size: usize): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __realloc(ptr: usize, size: usize): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __free(ptr: usize): void;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __new(size: usize, id: u32): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __renew(ptr: usize, size: usize): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __collect(): void;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __visit(ptr: usize, cookie: u32): void;\\n\",\n  \"rt/common\": \"// Alignment guarantees\\n\\n// @ts-ignore: decorator\\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\\n// @ts-ignore: decorator\\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\\n// @ts-ignore: decorator\\n@inline export const AL_MASK: usize = AL_SIZE - 1;\\n\\n// Extra debugging\\n\\n// @ts-ignore: decorator\\n@inline export const DEBUG = true;\\n// @ts-ignore: decorator\\n@inline export const TRACE = false;\\n// @ts-ignore: decorator\\n@inline export const RTRACE = isDefined(ASC_RTRACE);\\n// @ts-ignore: decorator\\n@inline export const PROFILE = isDefined(ASC_PROFILE);\\n\\n// Memory manager\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Memory manager block layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                           MM info                             \u2502 -4\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                              ...                              \u2502\\n@unmanaged export class BLOCK {\\n  /** Memory manager info. */\\n  mmInfo: usize;\\n}\\n\\n/** Overhead of a memory manager block. */\\n// @ts-ignore: decorator\\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\\n\\n/** Maximum size of a memory manager block's payload. */\\n// @ts-ignore: decorator\\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\\n\\n// Garbage collector\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Garbage collector object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                     Memory manager block                      \u2502 -20\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                            GC info                            \u2502 -16\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                            GC info                            \u2502 -12\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                            RT id                              \u2502 -8\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                            RT size                            \u2502 -4\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                              ...                              \u2502\\n@unmanaged export class OBJECT extends BLOCK {\\n  /** Garbage collector info. */\\n  gcInfo: u32;\\n  /** Garbage collector info. */\\n  gcInfo2: u32;\\n  /** Runtime class id. */\\n  rtId: u32;\\n  /** Runtime object size. */\\n  rtSize: u32;\\n}\\n\\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\\n// @ts-ignore: decorator\\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\\n\\n/** Maximum size of a garbage collector object's payload. */\\n// @ts-ignore: decorator\\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\\n\\n/** Total of memory manager and garbage collector overhead. */\\n// @ts-ignore: decorator\\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\\n\",\n  \"rt/index-incremental\": \"import \\\"rt/tlsf\\\";\\nimport \\\"rt/itcms\\\";\\n\",\n  \"rt/index-minimal\": \"import \\\"rt/tlsf\\\";\\nimport \\\"rt/tcms\\\";\\n\",\n  \"rt/index-stub\": \"import \\\"rt/stub\\\";\\n\",\n  \"rt/itcms\": \"import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \\\"./common\\\";\\nimport { onvisit, oncollect, oninterrupt, onyield } from \\\"./rtrace\\\";\\nimport { TypeinfoFlags } from \\\"../shared/typeinfo\\\";\\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \\\"../util/error\\\";\\n\\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\\n// Adapted from Bach Le's \u03BCgc, see: https://github.com/bullno1/ugc\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Colors \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n// \u2502 Color       \u2502 Meaning                                         \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502 WHITE*      \u2502 Unprocessed                                     \u2502\\n// \u2502 BLACK*      \u2502 Processed                                       \u2502\\n// \u2502 GRAY        \u2502 Processed with unprocessed children             \u2502\\n// \u2502 TRANSPARENT \u2502 Manually pinned (always reachable)              \u2502\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n// * flipped between cycles\\n\\n// @ts-ignore: decorator\\n@lazy let white = 0;\\n// @ts-ignore: decorator\\n@inline const gray = 2;\\n// @ts-ignore: decorator\\n@inline const transparent = 3;\\n// @ts-ignore: decorator\\n@inline const COLOR_MASK = 3;\\n\\n/** Size in memory of all objects currently managed by the GC. */\\n// @ts-ignore: decorator\\n@lazy let total: usize = 0;\\n\\n/** Currently transitioning from SWEEP to MARK state. */\\n// @ts-ignore: decorator\\n@inline const STATE_IDLE = 0;\\n/** Currently marking reachable objects. */\\n// @ts-ignore: decorator\\n@inline const STATE_MARK = 1;\\n/** Currently sweeping unreachable objects. */\\n// @ts-ignore: decorator\\n@inline const STATE_SWEEP = 2;\\n/** Current collector state. */\\n// @ts-ignore: decorator\\n@lazy let state = STATE_IDLE;\\n\\n// @ts-ignore: decorator\\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\\n\\nfunction initLazy(space: Object): Object {\\n  space.nextWithColor = changetype<usize>(space);\\n  space.prev = space;\\n  return space;\\n}\\n\\n/** Visit cookie indicating scanning of an object. */\\n// @ts-ignore: decorator\\n@inline const VISIT_SCAN = 0;\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Managed object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                      Memory manager block                     \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2561\\n// \u2502                              next                         \u2502 C \u2502 = nextWithColor\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524\\n// \u2502                              prev                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtId                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtSize                           \u2502\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                               ...                             \u2502\\n// C: color\\n\\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\\n@unmanaged class Object extends BLOCK {\\n  /** Pointer to the next object with color flags stored in the alignment bits. */\\n  nextWithColor: usize; // *u32\\n  /** Pointer to the previous object. */\\n  prev: Object; // *u32\\n  /** Runtime id. */\\n  rtId: u32;\\n  /** Runtime size. */\\n  rtSize: u32;\\n\\n  /** Gets the pointer to the next object. */\\n  get next(): Object {\\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\\n  }\\n\\n  /** Sets the pointer to the next object. */\\n  set next(obj: Object) {\\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Gets this object's color. */\\n  get color(): i32 {\\n    return i32(this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Sets this object's color. */\\n  set color(color: i32) {\\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\\n  }\\n\\n  /** Gets the size of this object in memory. */\\n  get size(): usize {\\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\\n  }\\n\\n  /** Tests if this object is pointerfree. */\\n  get isPointerfree(): bool {\\n    let rtId = this.rtId;\\n    // 0: Object, 1: ArrayBuffer, 2: String\\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\\n  }\\n\\n  /** Unlinks this object from its list. */\\n  unlink(): void {\\n    let next = this.next;\\n    if (next == null) {\\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\\n      return; // static data not yet linked\\n    }\\n    let prev = this.prev;\\n    if (DEBUG) assert(prev);\\n    next.prev = prev;\\n    prev.next = next;\\n  }\\n\\n  /** Links this object to the specified list, with the given color. */\\n  linkTo(list: Object, withColor: i32): void {\\n    let prev = list.prev;\\n    this.nextWithColor = changetype<usize>(list) | withColor;\\n    this.prev = prev;\\n    prev.next = this;\\n    list.prev = this;\\n  }\\n\\n  /** Marks this object as gray, that is reachable with unscanned children. */\\n  makeGray(): void {\\n    if (this == iter) iter = assert(this.prev);\\n    this.unlink();\\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\\n  }\\n}\\n\\n/** Visits all objects considered to be program roots. */\\nfunction visitRoots(cookie: u32): void {\\n  __visit_globals(cookie);\\n  let pn = pinSpace;\\n  let iter = pn.next;\\n  while (iter != pn) {\\n    if (DEBUG) assert(iter.color == transparent);\\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\\n    iter = iter.next;\\n  }\\n}\\n\\n/** Visits all objects on the stack. */\\nfunction visitStack(cookie: u32): void {\\n  let ptr = __stack_pointer;\\n  while (ptr < __heap_base) {\\n    __visit(load<usize>(ptr), cookie);\\n    ptr += sizeof<usize>();\\n  }\\n}\\n\\n/** Performs a single step according to the current state. */\\nfunction step(): usize {\\n  // Magic constants responsible for pause times. Obtained experimentally\\n  // using the compiler compiling itself. 2048 budget pro run by default.\\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\\n  let obj: Object;\\n  switch (state) {\\n    case STATE_IDLE: {\\n      state = STATE_MARK;\\n      visitCount = 0;\\n      visitRoots(VISIT_SCAN);\\n      iter = toSpace;\\n      return visitCount * MARKCOST;\\n    }\\n    case STATE_MARK: {\\n      let black = i32(!white);\\n      obj = iter.next;\\n      while (obj != toSpace) {\\n        iter = obj;\\n        if (obj.color != black) { // skip already-blacks (pointerfree)\\n          obj.color = black;\\n          visitCount = 0;\\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\\n          return visitCount * MARKCOST;\\n        }\\n        obj = obj.next;\\n      }\\n      visitCount = 0;\\n      visitRoots(VISIT_SCAN);\\n      obj = iter.next;\\n      if (obj == toSpace) {\\n        visitStack(VISIT_SCAN);\\n        obj = iter.next;\\n        while (obj != toSpace) {\\n          if (obj.color != black) {\\n            obj.color = black;\\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\\n          }\\n          obj = obj.next;\\n        }\\n        let from = fromSpace;\\n        fromSpace = toSpace;\\n        toSpace = from;\\n        white = black;\\n        iter = from.next;\\n        state = STATE_SWEEP;\\n      }\\n      return visitCount * MARKCOST;\\n    }\\n    case STATE_SWEEP: {\\n      obj = iter;\\n      if (obj != toSpace) {\\n        iter = obj.next;\\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\\n        free(obj);\\n        return SWEEPCOST;\\n      }\\n      toSpace.nextWithColor = changetype<usize>(toSpace);\\n      toSpace.prev = toSpace;\\n      state = STATE_IDLE;\\n      break;\\n    }\\n  }\\n  return 0;\\n}\\n\\n/** Frees an object. */\\nfunction free(obj: Object): void {\\n  if (changetype<usize>(obj) < __heap_base) {\\n    obj.nextWithColor = 0; // may become linked again\\n    obj.prev = changetype<Object>(0);\\n  } else {\\n    total -= obj.size;\\n    if (isDefined(__finalize)) {\\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\\n    }\\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\\n  }\\n}\\n\\n// Garbage collector interface\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __new(size: usize, id: i32): usize {\\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  if (total >= threshold) interrupt();\\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\\n  obj.rtId = id;\\n  obj.rtSize = <u32>size;\\n  obj.linkTo(fromSpace, white); // inits next/prev\\n  total += obj.size;\\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\\n  // may be visited before being fully initialized, so must fill\\n  memory.fill(ptr, 0, size);\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __renew(oldPtr: usize, size: usize): usize {\\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\\n  // Update object size if its block is large enough\\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\\n    oldObj.rtSize = <u32>size;\\n    return oldPtr;\\n  }\\n  // If not the same object anymore, we have to move it move it due to the\\n  // shadow stack potentially still referencing the old object\\n  let newPtr = __new(size, oldObj.rtId);\\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\\n  return newPtr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\\n  // Write barrier is unnecessary if non-incremental\\n  if (!childPtr) return;\\n  if (DEBUG) assert(parentPtr);\\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\\n  if (child.color == white) {\\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\\n    let parentColor = parent.color;\\n    if (parentColor == i32(!white)) {\\n      // Maintain the invariant that no black object may point to a white object.\\n      if (expectMultiple) {\\n        // Move the barrier \\\"backward\\\". Suitable for containers receiving multiple stores.\\n        // Avoids a barrier for subsequent objects stored into the same container.\\n        parent.makeGray();\\n      } else {\\n        // Move the barrier \\\"forward\\\". Suitable for objects receiving isolated stores.\\n        child.makeGray();\\n      }\\n    } else if (parentColor == transparent && state == STATE_MARK) {\\n      // Pinned objects are considered 'black' during the mark phase.\\n      child.makeGray();\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let visitCount = 0;\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __visit(ptr: usize, cookie: i32): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (RTRACE) if (!onvisit(obj)) return;\\n  if (obj.color == white) {\\n    obj.makeGray();\\n    ++visitCount;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __pin(ptr: usize): usize {\\n  if (ptr) {\\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n    if (obj.color == transparent) {\\n      throw new Error(E_ALREADY_PINNED);\\n    }\\n    obj.unlink(); // from fromSpace\\n    obj.linkTo(pinSpace, transparent);\\n  }\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __unpin(ptr: usize): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (obj.color != transparent) {\\n    throw new Error(E_NOT_PINNED);\\n  }\\n  if (state == STATE_MARK) {\\n    // We may be right at the point after marking roots for the second time and\\n    // entering the sweep phase, in which case the object would be missed if it\\n    // is not only pinned but also a root. Make sure it isn't missed.\\n    obj.makeGray();\\n  } else {\\n    obj.unlink();\\n    obj.linkTo(fromSpace, white);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __collect(): void {\\n  if (TRACE) trace(\\\"GC (full) at\\\", 1, total);\\n  if (state > STATE_IDLE) {\\n    // finish current cycle\\n    while (state != STATE_IDLE) step();\\n  }\\n  // perform a full cycle\\n  step();\\n  while (state != STATE_IDLE) step();\\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\\n  if (TRACE) trace(\\\"GC (full) done at cur/max\\\", 2, total, memory.size() << 16);\\n  if (RTRACE || PROFILE) oncollect(total);\\n}\\n\\n// Garbage collector automation\\n\\n/** How often to interrupt. The default of 1024 means \\\"interrupt each 1024 bytes allocated\\\". */\\n// @ts-ignore: decorator\\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\\n/** How long to interrupt. The default of 200% means \\\"run at double the speed of allocations\\\". */\\n// @ts-ignore: decorator\\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\\n/** How long to idle. The default of 200% means \\\"wait for memory to double before kicking in again\\\". */\\n// @ts-ignore: decorator\\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\\n\\n/** Threshold of memory used by objects to exceed before interrupting again. */\\n// @ts-ignore: decorator\\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\\n\\n/** Performs a reasonable amount of incremental GC steps. */\\nfunction interrupt(): void {\\n  if (PROFILE) oninterrupt(total);\\n  if (TRACE) trace(\\\"GC (auto) at\\\", 1, total);\\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\\n  do {\\n    budget -= step();\\n    if (state == STATE_IDLE) {\\n      if (TRACE) trace(\\\"\u2514 GC (auto) done at cur/max\\\", 2, total, memory.size() << 16);\\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\\n      if (PROFILE) onyield(total);\\n      return;\\n    }\\n  } while (budget > 0);\\n  if (TRACE) trace(\\\"\u2514 GC (auto) ongoing at\\\", 1, total);\\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\\n  if (PROFILE) onyield(total);\\n}\\n\",\n  \"rt/rtrace\": \"import { BLOCK } from \\\"./common\\\";\\n\\nexport declare function oninit(heapBase: usize): void;\\n\\n// Memory Allocator\\nexport declare function onalloc(block: BLOCK): void;\\nexport declare function onresize(block: BLOCK, oldSizeInclOverhead: usize): void;\\nexport declare function onmove(oldBlock: BLOCK, newBlock: BLOCK): void;\\nexport declare function onfree(block: BLOCK): void;\\n\\n// Garbage collector\\nexport declare function onvisit(block: BLOCK): bool;\\nexport declare function oncollect(total: usize): void;\\nexport declare function oninterrupt(total: usize): void;\\nexport declare function onyield(total: usize): void;\\n\",\n  \"rt/stub\": \"import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from \\\"./common\\\";\\nimport { E_ALLOCATION_TOO_LARGE } from \\\"../util/error\\\";\\n\\n// === A minimal runtime stub ===\\n\\n// @ts-ignore: decorator\\n@lazy let startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n// @ts-ignore: decorator\\n@lazy let offset: usize = startOffset;\\n\\nfunction maybeGrowMemory(newOffset: usize): void {\\n  // assumes newOffset is aligned\\n  let pagesBefore = memory.size();\\n  let maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\\n  if (newOffset > maxOffset) {\\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\\n    if (memory.grow(pagesWanted) < 0) {\\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\\n    }\\n  }\\n  offset = newOffset;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function computeSize(size: usize): usize {\\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __alloc(size: usize): usize {\\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  let block = changetype<BLOCK>(offset);\\n  let ptr = offset + BLOCK_OVERHEAD;\\n  let payloadSize = computeSize(size);\\n  maybeGrowMemory(ptr + payloadSize);\\n  block.mmInfo = payloadSize;\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __realloc(ptr: usize, size: usize): usize {\\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\\n  let actualSize = block.mmInfo;\\n  let isLast = ptr + actualSize == offset;\\n  let payloadSize = computeSize(size);\\n  if (size > actualSize) {\\n    if (isLast) { // last block: grow\\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n      maybeGrowMemory(ptr + payloadSize);\\n      block.mmInfo = payloadSize;\\n    } else { // copy to new block at least double the size\\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\\n      memory.copy(newPtr, ptr, actualSize);\\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\\n    }\\n  } else if (isLast) { // last block: shrink\\n    offset = ptr + payloadSize;\\n    block.mmInfo = payloadSize;\\n  }\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __free(ptr: usize): void {\\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\\n  if (ptr + block.mmInfo == offset) { // last block: discard\\n    offset = changetype<usize>(block);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __reset(): void { // special\\n  offset = startOffset;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __new(size: usize, id: u32): usize {\\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  let ptr = __alloc(OBJECT_OVERHEAD + size);\\n  let object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\\n  object.gcInfo = 0;\\n  object.gcInfo2 = 0;\\n  object.rtId = id;\\n  object.rtSize = <u32>size;\\n  return ptr + OBJECT_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __renew(oldPtr: usize, size: usize): usize {\\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\\n  return newPtr + OBJECT_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __pin(ptr: usize): usize {\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __unpin(ptr: usize): void {\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __collect(): void {\\n  // nop\\n}\\n\",\n  \"rt/tcms\": \"import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE } from \\\"./common\\\";\\nimport { onvisit, oncollect } from \\\"./rtrace\\\";\\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \\\"../util/error\\\";\\n\\n// === TCMS: A Two-Color Mark & Sweep garbage collector ===\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Colors \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n// \u2502 Color       \u2502 Meaning                                         \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502 WHITE*      \u2502 Unreachable                                     \u2502\\n// \u2502 BLACK*      \u2502 Reachable                                       \u2502\\n// \u2502 TRANSPARENT \u2502 Manually pinned (always reachable)              \u2502\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n// * flipped between cycles\\n\\n// @ts-ignore: decorator\\n@lazy let white = 0;\\n// @ts-ignore: decorator\\n@inline const transparent = 3;\\n// @ts-ignore: decorator\\n@inline const COLOR_MASK = 3;\\n\\n/** Size in memory of all objects currently managed by the GC. */\\n// @ts-ignore: decorator\\n@lazy let total: usize = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n\\nfunction initLazy(space: Object): Object {\\n  space.nextWithColor = changetype<usize>(space);\\n  space.prev = space;\\n  return space;\\n}\\n\\n/** Visit cookie indicating scanning of an object. */\\n// @ts-ignore: decorator\\n@inline const VISIT_SCAN = 0;\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Managed object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                      Memory manager block                     \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2561\\n// \u2502                              next                         \u2502 C \u2502 = nextWithColor\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524\\n// \u2502                              prev                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtId                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtSize                           \u2502\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                               ...                             \u2502\\n// C: color\\n\\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\\n@unmanaged class Object extends BLOCK {\\n  /** Pointer to the next object with color flags stored in the alignment bits. */\\n  nextWithColor: usize; // *u32\\n  /** Pointer to the previous object. */\\n  prev: Object; // *u32\\n  /** Runtime id. */\\n  rtId: u32;\\n  /** Runtime size. */\\n  rtSize: u32;\\n\\n  /** Gets the pointer to the next object. */\\n  get next(): Object {\\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\\n  }\\n\\n  /** Sets the pointer to the next object. */\\n  set next(obj: Object) {\\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Gets this object's color. */\\n  get color(): i32 {\\n    return i32(this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Sets this object's color. */\\n  set color(color: i32) {\\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\\n  }\\n\\n  /** Gets the size of this object in memory. */\\n  get size(): usize {\\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\\n  }\\n\\n  /** Unlinks this object from its list. */\\n  unlink(): void {\\n    let next = this.next;\\n    if (next == null) {\\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\\n      return; // static data not yet linked\\n    }\\n    let prev = this.prev;\\n    if (DEBUG) assert(prev);\\n    next.prev = prev;\\n    prev.next = next;\\n  }\\n\\n  /** Links this object to the specified list, with the given color. */\\n  linkTo(list: Object, withColor: i32): void {\\n    let prev = list.prev;\\n    this.nextWithColor = changetype<usize>(list) | withColor;\\n    this.prev = prev;\\n    prev.next = this;\\n    list.prev = this;\\n  }\\n}\\n\\n// Garbage collector interface\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __new(size: usize, id: i32): usize {\\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\\n  obj.rtId = id;\\n  obj.rtSize = <u32>size;\\n  obj.linkTo(fromSpace, white);\\n  total += obj.size;\\n  return changetype<usize>(obj) + TOTAL_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __renew(oldPtr: usize, size: usize): usize {\\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\\n  if (oldPtr < __heap_base) { // move to heap for simplicity\\n    let newPtr = __new(size, oldObj.rtId);\\n    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\\n    return newPtr;\\n  }\\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  total -= oldObj.size;\\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;\\n  let newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);\\n  newObj.rtSize = <u32>size;\\n\\n  // Replace with new object\\n  newObj.next.prev = newObj;\\n  newObj.prev.next = newObj;\\n\\n  total += newObj.size;\\n  return newPtr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __visit(ptr: usize, cookie: i32): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (RTRACE) if (!onvisit(obj)) return;\\n  if (obj.color == white) {\\n    obj.unlink(); // from fromSpace\\n    obj.linkTo(toSpace, i32(!white));\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __pin(ptr: usize): usize {\\n  if (ptr) {\\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n    if (obj.color == transparent) {\\n      throw new Error(E_ALREADY_PINNED);\\n    }\\n    obj.unlink(); // from fromSpace\\n    obj.linkTo(pinSpace, transparent);\\n  }\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __unpin(ptr: usize): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (obj.color != transparent) {\\n    throw new Error(E_NOT_PINNED);\\n  }\\n  obj.unlink(); // from pinSpace\\n  obj.linkTo(fromSpace, white);\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __collect(): void {\\n  if (TRACE) trace(\\\"GC at\\\", 1, total);\\n\\n  // Mark roots (add to toSpace)\\n  __visit_globals(VISIT_SCAN);\\n\\n  // Mark direct members of pinned objects (add to toSpace)\\n  let pn = pinSpace;\\n  let iter = pn.next;\\n  while (iter != pn) {\\n    if (DEBUG) assert(iter.color == transparent);\\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\\n    iter = iter.next;\\n  }\\n\\n  // Mark what's reachable from toSpace\\n  let black = i32(!white);\\n  let to = toSpace;\\n  iter = to.next;\\n  while (iter != to) {\\n    if (DEBUG) assert(iter.color == black);\\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\\n    iter = iter.next;\\n  }\\n\\n  // Sweep what's left in fromSpace\\n  let from = fromSpace;\\n  iter = from.next;\\n  while (iter != from) {\\n    if (DEBUG) assert(iter.color == white);\\n    let newNext = iter.next;\\n    if (changetype<usize>(iter) < __heap_base) {\\n      iter.nextWithColor = 0; // may become linked again\\n      iter.prev = changetype<Object>(0);\\n    } else {\\n      total -= iter.size;\\n      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);\\n      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);\\n    }\\n    iter = newNext;\\n  }\\n  from.nextWithColor = changetype<usize>(from);\\n  from.prev = from;\\n\\n  // Flip spaces and colors\\n  fromSpace = to;\\n  toSpace = from;\\n  white = black;\\n\\n  if (TRACE) trace(\\\"GC done at\\\", 1, total);\\n  if (RTRACE) oncollect(total);\\n}\\n\",\n  \"rt/tlsf\": \"import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \\\"./common\\\";\\nimport { oninit, onalloc, onresize, onmove, onfree } from \\\"./rtrace\\\";\\nimport { E_ALLOCATION_TOO_LARGE } from \\\"../util/error\\\";\\n\\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\\n// see: http://www.gii.upv.es/tlsf/\\n\\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block size interpretation (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u256B\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502 |                    FL                       \u2502 SB = SL + AL  \u2502 \u25C4\u2500 usize\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n// FL: first level, SL: second level, AL: alignment, SB: small block\\n\\n// @ts-ignore: decorator\\n@inline const SL_BITS: u32 = 4;\\n// @ts-ignore: decorator\\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\\n\\n// @ts-ignore: decorator\\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\\n// @ts-ignore: decorator\\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\\n\\n// @ts-ignore: decorator\\n@inline const FL_BITS: u32 = 31 - SB_BITS;\\n\\n// [00]: < 256B (SB)  [12]: < 1M\\n// [01]: < 512B       [13]: < 2M\\n// [02]: < 1K         [14]: < 4M\\n// [03]: < 2K         [15]: < 8M\\n// [04]: < 4K         [16]: < 16M\\n// [05]: < 8K         [17]: < 32M\\n// [06]: < 16K        [18]: < 64M\\n// [07]: < 32K        [19]: < 128M\\n// [08]: < 64K        [20]: < 256M\\n// [09]: < 128K       [21]: < 512M\\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\\n// [11]: < 512K\\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\\n\\n// Tags stored in otherwise unused alignment bits\\n\\n// @ts-ignore: decorator\\n@inline const FREE: usize = 1 << 0;\\n// @ts-ignore: decorator\\n@inline const LEFTFREE: usize = 1 << 1;\\n// @ts-ignore: decorator\\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u253C\u2500\u2524            \u2510\\n// \u2502                          size                             \u2502L\u2502F\u2502 \u25C4\u2500\u2510 info   overhead\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2567\u2550\u2561   \u2502        \u2518\\n// \u2502                        if free: \u25C4 prev                        \u2502 \u25C4\u2500\u2524 usize\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\\n// \u2502                        if free: next \u25BA                        \u2502 \u25C4\u2500\u2524\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\\n// \u2502                             ...                               \u2502   \u2502 >= 0\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\\n// \u2502                        if free: back \u25B2                        \u2502 \u25C4\u2500\u2518\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 >= MIN SIZE\\n// F: FREE, L: LEFTFREE\\n@unmanaged export class Block extends BLOCK {\\n\\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\\n  prev: Block | null;\\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\\n  next: Block | null;\\n\\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\\n}\\n\\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\\n// `next` and `back` if free.\\n\\n// @ts-ignore: decorator\\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\\n// @ts-ignore: decorator\\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\\n\\n/** Gets the left block of a block. Only valid if the left block is free. */\\n// @ts-ignore: decorator\\n@inline function GETFREELEFT(block: Block): Block {\\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\\n}\\n\\n/** Gets the right block of a block by advancing to the right by its size. */\\n// @ts-ignore: decorator\\n@inline function GETRIGHT(block: Block): Block {\\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\\n}\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Root layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524          \u2510\\n// \u2502        0        |           flMap                            S\u2502 \u25C4\u2500\u2500\u2500\u2500\u2510\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502\\n// \u2502                           slMap[0] S                          \u2502 \u25C4\u2500\u2510  \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502  \u2502\\n// \u2502                           slMap[1]                            \u2502 \u25C4\u2500\u2524  \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  u32 \u2502\\n// \u2502                           slMap[22]                           \u2502 \u25C4\u2500\u2518  \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561    usize\\n// \u2502                            head[0]                            \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\\n// \u2502                              ...                              \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\\n// \u2502                           head[367]                           \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502\\n// \u2502                             tail                              \u2502 \u25C4\u2500\u2500\u2500\u2500\u2518\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   SIZE   \u2518\\n// S: Small blocks map\\n@unmanaged class Root {\\n  /** First level bitmap. */\\n  flMap: usize;\\n}\\n\\n// Root constants. Where stuff is stored inside of the root structure.\\n\\n// @ts-ignore: decorator\\n@inline const SL_START: usize = sizeof<usize>();\\n// @ts-ignore: decorator\\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\\n// @ts-ignore: decorator\\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\\n// @ts-ignore: decorator\\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\\n// @ts-ignore: decorator\\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\\n\\n// @ts-ignore: decorator\\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\\n\\n/** Gets the second level map of the specified first level. */\\n// @ts-ignore: decorator\\n@inline function GETSL(root: Root, fl: usize): u32 {\\n  return load<u32>(\\n    changetype<usize>(root) + (fl << alignof<u32>()),\\n    SL_START\\n  );\\n}\\n\\n/** Sets the second level map of the specified first level. */\\n// @ts-ignore: decorator\\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\\n  store<u32>(\\n    changetype<usize>(root) + (fl << alignof<u32>()),\\n    slMap,\\n    SL_START\\n  );\\n}\\n\\n/** Gets the head of the free list for the specified combination of first and second level. */\\n// @ts-ignore: decorator\\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\\n  return load<Block>(\\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\\n    HL_START\\n  );\\n}\\n\\n/** Sets the head of the free list for the specified combination of first and second level. */\\n// @ts-ignore: decorator\\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\\n  store<Block | null>(\\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\\n    head,\\n    HL_START\\n  );\\n}\\n\\n/** Gets the tail block.. */\\n// @ts-ignore: decorator\\n@inline function GETTAIL(root: Root): Block {\\n  return load<Block>(\\n    changetype<usize>(root),\\n    HL_END\\n  );\\n}\\n\\n/** Sets the tail block. */\\n// @ts-ignore: decorator\\n@inline function SETTAIL(root: Root, tail: Block): void {\\n  store<Block>(\\n    changetype<usize>(root),\\n    tail,\\n    HL_END\\n  );\\n}\\n\\n/** Inserts a previously used block back into the free list. */\\nfunction insertBlock(root: Root, block: Block): void {\\n  if (DEBUG) assert(block); // cannot be null\\n  let blockInfo = block.mmInfo;\\n  if (DEBUG) assert(blockInfo & FREE); // must be free\\n\\n  let right = GETRIGHT(block);\\n  let rightInfo = right.mmInfo;\\n\\n  // merge with right block if also free\\n  if (rightInfo & FREE) {\\n    removeBlock(root, right);\\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\\n    right = GETRIGHT(block);\\n    rightInfo = right.mmInfo;\\n    // 'back' is set below\\n  }\\n\\n  // merge with left block if also free\\n  if (blockInfo & LEFTFREE) {\\n    let left = GETFREELEFT(block);\\n    let leftInfo = left.mmInfo;\\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\\n    removeBlock(root, left);\\n    block = left;\\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\\n    // 'back' is set below\\n  }\\n\\n  right.mmInfo = rightInfo | LEFTFREE;\\n  // reference to right is no longer used now, hence rightInfo is not synced\\n\\n  // we now know the size of the block\\n  let size = blockInfo & ~TAGS_MASK;\\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\\n\\n  // set 'back' to itself at the end of block\\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\\n\\n  // mapping_insert\\n  let fl: usize, sl: u32;\\n  if (size < SB_SIZE) {\\n    fl = 0;\\n    sl = <u32>(size >> AL_BITS);\\n  } else {\\n    const inv: usize = sizeof<usize>() * 8 - 1;\\n    let boundedSize = min(size, BLOCK_MAXSIZE);\\n    fl = inv - clz<usize>(boundedSize);\\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\\n    fl -= SB_BITS - 1;\\n  }\\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\\n\\n  // perform insertion\\n  let head = GETHEAD(root, fl, sl);\\n  block.prev = null;\\n  block.next = head;\\n  if (head) head.prev = block;\\n  SETHEAD(root, fl, sl, block);\\n\\n  // update first and second level maps\\n  root.flMap |= (1 << fl);\\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\\n}\\n\\n/** Removes a free block from internal lists. */\\nfunction removeBlock(root: Root, block: Block): void {\\n  let blockInfo = block.mmInfo;\\n  if (DEBUG) assert(blockInfo & FREE); // must be free\\n  let size = blockInfo & ~TAGS_MASK;\\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\\n\\n  // mapping_insert\\n  let fl: usize, sl: u32;\\n  if (size < SB_SIZE) {\\n    fl = 0;\\n    sl = <u32>(size >> AL_BITS);\\n  } else {\\n    const inv: usize = sizeof<usize>() * 8 - 1;\\n    let boundedSize = min(size, BLOCK_MAXSIZE);\\n    fl = inv - clz<usize>(boundedSize);\\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\\n    fl -= SB_BITS - 1;\\n  }\\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\\n\\n  // link previous and next free block\\n  let prev = block.prev;\\n  let next = block.next;\\n  if (prev) prev.next = next;\\n  if (next) next.prev = prev;\\n\\n  // update head if we are removing it\\n  if (block == GETHEAD(root, fl, sl)) {\\n    SETHEAD(root, fl, sl, next);\\n\\n    // clear second level map if head is empty now\\n    if (!next) {\\n      let slMap = GETSL(root, fl);\\n      SETSL(root, fl, slMap &= ~(1 << sl));\\n\\n      // clear first level map if second level is empty now\\n      if (!slMap) root.flMap &= ~(1 << fl);\\n    }\\n  }\\n  // note: does not alter left/back because it is likely that splitting\\n  // is performed afterwards, invalidating those changes. so, the caller\\n  // must perform those updates.\\n}\\n\\nfunction roundSize(size: usize): usize {\\n  const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\\n  const inv: usize = sizeof<usize>() * 8 - 1;\\n  const invRound = inv - SL_BITS;\\n  return size < halfMaxSize\\n    ? size + (1 << (invRound - clz<usize>(size))) - 1\\n    : size;\\n}\\n\\n/** Searches for a free block of at least the specified size. */\\nfunction searchBlock(root: Root, size: usize): Block | null {\\n  // size was already asserted by caller\\n\\n  // mapping_search\\n  let fl: usize, sl: u32;\\n  if (size < SB_SIZE) {\\n    fl = 0;\\n    sl = <u32>(size >> AL_BITS);\\n  } else {\\n    const requestSize = roundSize(size);\\n    fl = sizeof<usize>() * 8 - 1 - clz<usize>(requestSize);\\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\\n    fl -= SB_BITS - 1;\\n  }\\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\\n\\n  // search second level\\n  let slMap = GETSL(root, fl) & (~0 << sl);\\n  let head: Block | null = null;\\n  if (!slMap) {\\n    // search next larger first level\\n    let flMap = root.flMap & (~0 << (fl + 1));\\n    if (!flMap) {\\n      head = null;\\n    } else {\\n      fl = ctz<usize>(flMap);\\n      slMap = GETSL(root, fl);\\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\\n    }\\n  } else {\\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\\n  }\\n  return head;\\n}\\n\\n/** Prepares the specified block before (re-)use, possibly splitting it. */\\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\\n  // size was already asserted by caller\\n\\n  let blockInfo = block.mmInfo;\\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\\n\\n  // split if the block can hold another MINSIZE block incl. overhead\\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\\n\\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\\n    insertBlock(root, spare); // also sets 'back'\\n\\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\\n  } else {\\n    block.mmInfo = blockInfo & ~FREE;\\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\\n  }\\n}\\n\\n/** Adds more memory to the pool. */\\nfunction addMemory(root: Root, start: usize, endU64: u64): bool {\\n  let end = <usize>endU64;\\n  if (DEBUG) assert(<u64>start <= endU64); // must be valid\\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n  end &= ~AL_MASK;\\n\\n  let tail = GETTAIL(root);\\n  let tailInfo: usize = 0;\\n  if (tail) { // more memory\\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\\n\\n    // merge with current tail if adjacent\\n    const offsetToTail = AL_SIZE;\\n    if (start - offsetToTail == changetype<usize>(tail)) {\\n      start -= offsetToTail;\\n      tailInfo = tail.mmInfo;\\n    } else {\\n      // We don't do this, but a user might `memory.grow` manually\\n      // leading to non-adjacent pages managed by TLSF.\\n    }\\n\\n  } else if (DEBUG) { // first memory\\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\\n  }\\n\\n  // check if size is large enough for a free block and the tail block\\n  let size = end - start;\\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\\n    return false;\\n  }\\n\\n  // left size is total minus its own and the zero-length tail's header\\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\\n  let left = changetype<Block>(start);\\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\\n  left.prev = null;\\n  left.next = null;\\n\\n  // tail is a zero-length used block\\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\\n  tail.mmInfo = 0 | LEFTFREE;\\n  SETTAIL(root, tail);\\n\\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\\n\\n  return true;\\n}\\n\\n/** Grows memory to fit at least another block of the specified size. */\\nfunction growMemory(root: Root, size: usize): void {\\n  if (ASC_LOW_MEMORY_LIMIT) {\\n    unreachable();\\n    return;\\n  }\\n  // Here, both rounding performed in searchBlock ...\\n  if (size >= SB_SIZE) {\\n    size = roundSize(size);\\n  }\\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\\n  // to merge with the tail block, that's one time, otherwise it's two times.\\n  let pagesBefore = memory.size();\\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\\n  if (memory.grow(pagesWanted) < 0) {\\n    if (memory.grow(pagesNeeded) < 0) unreachable();\\n  }\\n  let pagesAfter = memory.size();\\n  addMemory(root, <usize>pagesBefore << 16, <u64>pagesAfter << 16);\\n}\\n\\n/** Computes the size (excl. header) of a block. */\\nfunction computeSize(size: usize): usize {\\n  // Size must be large enough and aligned minus preceeding overhead\\n  return size <= BLOCK_MINSIZE\\n    ? BLOCK_MINSIZE\\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n}\\n\\n/** Prepares and checks an allocation size. */\\nfunction prepareSize(size: usize): usize {\\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  return computeSize(size);\\n}\\n\\n/** Initializes the root structure. */\\nfunction initialize(): void {\\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\\n  let pagesBefore = memory.size();\\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\\n  let root = changetype<Root>(rootOffset);\\n  root.flMap = 0;\\n  SETTAIL(root, changetype<Block>(0));\\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\\n    SETSL(root, fl, 0);\\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\\n      SETHEAD(root, fl, sl, null);\\n    }\\n  }\\n  let memStart = rootOffset + ROOT_SIZE;\\n  if (ASC_LOW_MEMORY_LIMIT) {\\n    const memEnd = <u64>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\\n    else unreachable(); // low memory limit already exceeded\\n  } else {\\n    addMemory(root, memStart, <u64>memory.size() << 16);\\n  }\\n  ROOT = root;\\n}\\n\\n/** Allocates a block of the specified size. */\\nexport function allocateBlock(root: Root, size: usize): Block {\\n  let payloadSize = prepareSize(size);\\n  let block = searchBlock(root, payloadSize);\\n  if (!block) {\\n    growMemory(root, payloadSize);\\n    block = changetype<Block>(searchBlock(root, payloadSize));\\n    if (DEBUG) assert(block); // must be found now\\n  }\\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\\n  removeBlock(root, block);\\n  prepareBlock(root, block, payloadSize);\\n  if (isDefined(ASC_RTRACE)) onalloc(block);\\n  return block;\\n}\\n\\n/** Reallocates a block to the specified size. */\\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\\n  let payloadSize = prepareSize(size);\\n  let blockInfo = block.mmInfo;\\n  let blockSize = blockInfo & ~TAGS_MASK;\\n\\n  // possibly split and update runtime size if it still fits\\n  if (payloadSize <= blockSize) {\\n    prepareBlock(root, block, payloadSize);\\n    if (isDefined(ASC_RTRACE)) {\\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\\n    }\\n    return block;\\n  }\\n\\n  // merge with right free block if merger is large enough\\n  let right = GETRIGHT(block);\\n  let rightInfo = right.mmInfo;\\n  if (rightInfo & FREE) {\\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\\n    if (mergeSize >= payloadSize) {\\n      removeBlock(root, right);\\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\\n      prepareBlock(root, block, payloadSize);\\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\\n      return block;\\n    }\\n  }\\n\\n  // otherwise move the block\\n  return moveBlock(root, block, size);\\n}\\n\\n/** Moves a block to a new one of the specified size. */\\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\\n  let newBlock = allocateBlock(root, newSize);\\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\\n  if (changetype<usize>(block) >= __heap_base) {\\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\\n    freeBlock(root, block);\\n  }\\n  return newBlock;\\n}\\n\\n/** Frees a block. */\\nexport function freeBlock(root: Root, block: Block): void {\\n  if (isDefined(ASC_RTRACE)) onfree(block);\\n  block.mmInfo = block.mmInfo | FREE;\\n  insertBlock(root, block);\\n}\\n\\n/** Checks that a used block is valid to be freed or reallocated. */\\nfunction checkUsedBlock(ptr: usize): Block {\\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\\n  assert(\\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\\n    !(block.mmInfo & FREE)           // must be used\\n  );\\n  return block;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __alloc(size: usize): usize {\\n  if (!ROOT) initialize();\\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __realloc(ptr: usize, size: usize): usize {\\n  if (!ROOT) initialize();\\n  return (ptr < __heap_base\\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\\n  ) + BLOCK_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __free(ptr: usize): void {\\n  if (ptr < __heap_base) return;\\n  if (!ROOT) initialize();\\n  freeBlock(ROOT, checkUsedBlock(ptr));\\n}\\n\",\n  \"set\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { HASH } from \\\"./util/hash\\\";\\n\\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\\n\\n// @ts-ignore: decorator\\n@inline const INITIAL_CAPACITY = 4;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_N = 8;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_D = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_N = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_D = 4;\\n\\n/** Structure of a set entry. */\\n@unmanaged class SetEntry<K> {\\n  key: K;\\n  taggedNext: usize; // LSB=1 indicates EMPTY\\n}\\n\\n/** Empty bit. */\\n// @ts-ignore: decorator\\n@inline const EMPTY: usize = 1 << 0;\\n\\n/** Size of a bucket. */\\n// @ts-ignore: decorator\\n@inline const BUCKET_SIZE = sizeof<usize>();\\n\\n/** Computes the alignment of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_ALIGN<T>(): usize {\\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\\n  return align;\\n}\\n\\n/** Computes the aligned size of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_SIZE<T>(): usize {\\n  const align = ENTRY_ALIGN<T>();\\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\\n  return size;\\n}\\n\\nexport class Set<T> {\\n\\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\\n\\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\\n  private entriesOffset: i32 = 0;\\n  private entriesCount: i32 = 0;\\n\\n  constructor() {\\n    /* nop */\\n  }\\n\\n  get size(): i32 {\\n    return this.entriesCount;\\n  }\\n\\n  clear(): void {\\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n    this.bucketsMask = INITIAL_CAPACITY - 1;\\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\\n    this.entriesCapacity = INITIAL_CAPACITY;\\n    this.entriesOffset = 0;\\n    this.entriesCount = 0;\\n  }\\n\\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\\n    let entry = load<SetEntry<T>>( // unmanaged!\\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\\n    );\\n    while (entry) {\\n      let taggedNext = entry.taggedNext;\\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\\n    }\\n    return null;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  has(key: T): bool {\\n    return this.find(key, HASH<T>(key)) != null;\\n  }\\n\\n  add(key: T): this {\\n    let hashCode = HASH<T>(key);\\n    let entry = this.find(key, hashCode); // unmanaged!\\n    if (!entry) {\\n      // check if rehashing is necessary\\n      if (this.entriesOffset == this.entriesCapacity) {\\n        this.rehash(\\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\\n        );\\n      }\\n      // append new entry\\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\\n      entry.key = key;\\n      if (isManaged<T>()) {\\n        __link(changetype<usize>(this), changetype<usize>(key), true);\\n      }\\n      ++this.entriesCount;\\n      // link with previous entry in bucket\\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\\n      entry.taggedNext = load<usize>(bucketPtrBase);\\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\\n    }\\n    return this;\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(key: T, value: bool): void {\\n    if (value) this.add(key);\\n    else this.delete(key);\\n  }\\n\\n  delete(key: T): bool {\\n    let entry = this.find(key, HASH<T>(key)); // unmanaged!\\n    if (!entry) return false;\\n    entry.taggedNext |= EMPTY;\\n    --this.entriesCount;\\n    // check if rehashing is appropriate\\n    let halfBucketsMask = this.bucketsMask >> 1;\\n    if (\\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n    ) this.rehash(halfBucketsMask);\\n    return true;\\n  }\\n\\n  private rehash(newBucketsMask: u32): void {\\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\\n\\n    // copy old entries to new entries\\n    let oldPtr = changetype<usize>(this.entries);\\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\\n    let newPtr = changetype<usize>(newEntries);\\n    while (oldPtr != oldEnd) {\\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\\n      if (!(oldEntry.taggedNext & EMPTY)) {\\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\\n        let oldEntryKey = oldEntry.key;\\n        newEntry.key = oldEntryKey;\\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\\n        store<usize>(newBucketPtrBase, newPtr);\\n        newPtr += ENTRY_SIZE<T>();\\n      }\\n      oldPtr += ENTRY_SIZE<T>();\\n    }\\n\\n    this.buckets = newBuckets;\\n    this.bucketsMask = newBucketsMask;\\n    this.entries = newEntries;\\n    this.entriesCapacity = newEntriesCapacity;\\n    this.entriesOffset = this.entriesCount;\\n  }\\n\\n  values(): T[] {\\n    // FIXME: this is preliminary, needs iterators/closures\\n    let start = changetype<usize>(this.entries);\\n    let size = this.entriesOffset;\\n    let values = new Array<T>(size);\\n    let length = 0;\\n    for (let i = 0; i < size; ++i) {\\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\\n      if (!(entry.taggedNext & EMPTY)) {\\n        unchecked(values[length++] = entry.key);\\n      }\\n    }\\n    values.length = length;\\n    return values;\\n  }\\n\\n  toString(): string {\\n    return \\\"[object Set]\\\";\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    __visit(changetype<usize>(this.buckets), cookie);\\n    let entries = changetype<usize>(this.entries);\\n    if (isManaged<T>()) {\\n      let cur = entries;\\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\\n      while (cur < end) {\\n        let entry = changetype<SetEntry<T>>(cur);\\n        if (!(entry.taggedNext & EMPTY)) {\\n          let val = changetype<usize>(entry.key);\\n          if (isNullable<T>()) {\\n            if (val) __visit(val, cookie);\\n          } else __visit(val, cookie);\\n        }\\n        cur += ENTRY_SIZE<T>();\\n      }\\n    }\\n    __visit(entries, cookie);\\n  }\\n}\\n\",\n  \"shared/feature\": \"// This file is shared with the compiler and must remain portable\\n\\n/** Indicates specific features to activate. */\\nexport const enum Feature {\\n  /** No additional features. */\\n  None = 0,\\n  /** Sign extension operations. */\\n  SignExtension = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\\n  /** Mutable global imports and exports. */\\n  MutableGlobals = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\\n  /** Non-trapping float to integer operations. */\\n  NontrappingF2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\\n  /** Bulk memory operations. */\\n  BulkMemory = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\\n  /** SIMD types and operations. */\\n  Simd = 1 << 4, // see: https://github.com/WebAssembly/simd\\n  /** Threading and atomic operations. */\\n  Threads = 1 << 5, // see: https://github.com/WebAssembly/threads\\n  /** Exception handling operations. */\\n  ExceptionHandling = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\\n  /** Tail call operations. */\\n  TailCalls = 1 << 7, // see: https://github.com/WebAssembly/tail-call\\n  /** Reference types. */\\n  ReferenceTypes = 1 << 8, // see: https://github.com/WebAssembly/reference-types\\n  /** Multi value types. */\\n  MultiValue = 1 << 9, // see: https://github.com/WebAssembly/multi-value\\n  /** Garbage collection. */\\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\\n  /** Memory64. */\\n  Memory64 = 1 << 11, // see: https://github.com/WebAssembly/memory64\\n  /** Relaxed SIMD. */\\n  RelaxedSimd = 1 << 12, // see: https://github.com/WebAssembly/relaxed-simd\\n  /** Extended const expressions. */\\n  ExtendedConst = 1 << 13, // see: https://github.com/WebAssembly/extended-const\\n  /** Reference typed strings. */\\n  Stringref = 1 << 14, // see: https://github.com/WebAssembly/stringref\\n  /** All features. */\\n  All = (1 << 15) - 1\\n}\\n\\n/** Gets the name of the specified feature one would specify on the command line. */\\nexport function featureToString(feature: Feature): string {\\n  switch (feature) {\\n    case Feature.SignExtension: return \\\"sign-extension\\\";\\n    case Feature.MutableGlobals: return \\\"mutable-globals\\\";\\n    case Feature.NontrappingF2I: return \\\"nontrapping-f2i\\\";\\n    case Feature.BulkMemory: return \\\"bulk-memory\\\";\\n    case Feature.Simd: return \\\"simd\\\";\\n    case Feature.Threads: return \\\"threads\\\";\\n    case Feature.ExceptionHandling: return \\\"exception-handling\\\";\\n    case Feature.TailCalls: return \\\"tail-calls\\\";\\n    case Feature.ReferenceTypes: return \\\"reference-types\\\";\\n    case Feature.MultiValue: return \\\"multi-value\\\";\\n    case Feature.GC: return \\\"gc\\\";\\n    case Feature.Memory64: return \\\"memory64\\\";\\n    case Feature.RelaxedSimd: return \\\"relaxed-simd\\\";\\n    case Feature.ExtendedConst: return \\\"extended-const\\\";\\n    case Feature.Stringref: return \\\"stringref\\\";\\n  }\\n  assert(false);\\n  return \\\"\\\";\\n}\\n\",\n  \"shared/runtime\": \"// This file is shared with the compiler and must remain portable\\n\\n/** Runtime types. */\\nexport enum Runtime {\\n  /** Simple bump allocator without GC. */\\n  Stub = 0,\\n  /** Stop the world semi-automatic GC. */\\n  Minimal = 1,\\n  /** incremental GC. */\\n  Incremental = 2,\\n}\\n\",\n  \"shared/target\": \"// This file is shared with the compiler and must remain portable\\n\\n/** Compilation target. */\\nexport enum Target {\\n  /** Portable. */\\n  Js = 0,\\n  /** WebAssembly with 32-bit pointers. */\\n  Wasm32 = 1,\\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\\n  Wasm64 = 2,\\n}\\n\",\n  \"shared/typeinfo\": \"// This file is shared with the compiler and must remain portable\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Typeinfo interpretation \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524 \u25C4\u2500 __rtti_base\\n// \u2502                             count                             \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2510\\n// \u2502                      Typeinfo#flags [id=0]                    \u2502 id < count\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              ...                              \u2502\\n\\n/** Runtime type information data structure. */\\n@unmanaged\\nexport class Typeinfo {\\n  /** Flags describing the shape of this class type. */\\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\\n}\\n\\n/** Runtime type information flags. */\\nexport const enum TypeinfoFlags {\\n  /** No specific flags. */\\n  NONE = 0,\\n  /** Type is an `ArrayBufferView`. */\\n  ARRAYBUFFERVIEW = 1 << 0,\\n  /** Type is an `Array`. */\\n  ARRAY = 1 << 1,\\n  /** Type is a `StaticArray`. */\\n  STATICARRAY = 1 << 2,\\n  /** Type is a `Set`. */\\n  SET = 1 << 3,\\n  /** Type is a `Map`. */\\n  MAP = 1 << 4,\\n  /** Type has no outgoing pointers. */\\n  POINTERFREE = 1 << 5,\\n  /** Value alignment of 1 byte. */\\n  VALUE_ALIGN_0 = 1 << 6,\\n  /** Value alignment of 2 bytes. */\\n  VALUE_ALIGN_1 = 1 << 7,\\n  /** Value alignment of 4 bytes. */\\n  VALUE_ALIGN_2 = 1 << 8,\\n  /** Value alignment of 8 bytes. */\\n  VALUE_ALIGN_3 = 1 << 9,\\n  /** Value alignment of 16 bytes. */\\n  VALUE_ALIGN_4 = 1 << 10,\\n  /** Value is a signed type. */\\n  VALUE_SIGNED = 1 << 11,\\n  /** Value is a float type. */\\n  VALUE_FLOAT = 1 << 12,\\n  /** Value type is nullable. */\\n  VALUE_NULLABLE = 1 << 13,\\n  /** Value type is managed. */\\n  VALUE_MANAGED = 1 << 14,\\n  /** Key alignment of 1 byte. */\\n  KEY_ALIGN_0 = 1 << 15,\\n  /** Key alignment of 2 bytes. */\\n  KEY_ALIGN_1 = 1 << 16,\\n  /** Key alignment of 4 bytes. */\\n  KEY_ALIGN_2 = 1 << 17,\\n  /** Key alignment of 8 bytes. */\\n  KEY_ALIGN_3 = 1 << 18,\\n  /** Key alignment of 16 bytes. */\\n  KEY_ALIGN_4 = 1 << 19,\\n  /** Key is a signed type. */\\n  KEY_SIGNED = 1 << 20,\\n  /** Key is a float type. */\\n  KEY_FLOAT = 1 << 21,\\n  /** Key type is nullable. */\\n  KEY_NULLABLE = 1 << 22,\\n  /** Key type is managed. */\\n  KEY_MANAGED = 1 << 23\\n}\\n\",\n  \"staticarray\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \\\"./rt/common\\\";\\nimport { Runtime } from \\\"shared/runtime\\\";\\nimport { COMPARATOR, SORT } from \\\"./util/sort\\\";\\nimport { REVERSE, FILL } from \\\"./util/bytes\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { Array } from \\\"./array\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \\\"./util/error\\\";\\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \\\"./util/string\\\";\\n\\n@final\\nexport class StaticArray<T> {\\n  [key: number]: T;\\n\\n  // Note that the interface of StaticArray instances must be a semantically\\n  // compatible subset of Array<T> in order for syntax highlighting to work\\n  // properly, for instance when creating static arrays from array literals.\\n  // The additionally provided static methods take care of dealing with static\\n  // arrays exclusively, without having to convert to Array<T> first.\\n\\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\\n    let length = source.length;\\n    let outSize = <usize>length << alignof<T>();\\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\\n    if (isManaged<T>()) {\\n      let sourcePtr = source.dataStart;\\n      for (let i = 0; i < length; ++i) {\\n        let off = <usize>i << alignof<T>();\\n        let ref = load<usize>(sourcePtr + off);\\n        store<usize>(changetype<usize>(out) + off, ref);\\n        __link(changetype<usize>(out), ref, true);\\n      }\\n    } else {\\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\\n    }\\n    return out;\\n  }\\n\\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\\n    return source.concat<StaticArray<T>>(other);\\n  }\\n\\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\\n    return source.slice<StaticArray<T>>(start, end);\\n  }\\n\\n  constructor(length: i32) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\\n    let outSize = <usize>length << alignof<T>();\\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(out), 0, outSize);\\n    }\\n    return out;\\n  }\\n\\n  get length(): i32 {\\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\\n  }\\n\\n  at(index: i32): T {\\n    let len = this.length;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  @operator(\\\"[]\\\") private __get(index: i32): T {\\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\") private __uget(index: i32): T {\\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\\n  }\\n\\n  @operator(\\\"[]=\\\") private __set(index: i32, value: T): void {\\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\\n    this.__uset(index, value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\") private __uset(index: i32, value: T): void {\\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\\n    if (isManaged<T>()) {\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    }\\n  }\\n\\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\\n    if (isManaged<T>()) {\\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\\n      __link(changetype<usize>(this), changetype<usize>(value), false);\\n    } else {\\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\\n    }\\n    return this;\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\\n    let ptr = changetype<usize>(this);\\n    let len = this.length;\\n\\n    end = min<i32>(end, len);\\n\\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\\n    let count = min(last - from, len - to);\\n\\n    memory.copy( // is memmove\\n      ptr + (<usize>to << alignof<T>()),\\n      ptr + (<usize>from << alignof<T>()),\\n      <usize>count << alignof<T>()\\n    );\\n    return this;\\n  }\\n\\n  includes(value: T, fromIndex: i32 = 0): bool {\\n    if (isFloat<T>()) {\\n      let length = this.length;\\n      if (length == 0 || fromIndex >= length) return false;\\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\\n      while (fromIndex < length) {\\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\\n        // @ts-ignore\\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\\n        ++fromIndex;\\n      }\\n      return false;\\n    } else {\\n      return this.indexOf(value, fromIndex) >= 0;\\n    }\\n  }\\n\\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\\n    let length = this.length;\\n    if (length == 0 || fromIndex >= length) return -1;\\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\\n    while (fromIndex < length) {\\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      ++fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\\n    let length = this.length;\\n    if (length == 0) return -1;\\n    if (fromIndex < 0) fromIndex = length + fromIndex;\\n    else if (fromIndex >= length) fromIndex = length - 1;\\n    while (fromIndex >= 0) {\\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      --fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\\n    let sourceLen = this.length;\\n    let otherLen = other.length;\\n    let outLen = sourceLen + otherLen;\\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\\n      throw new Error(E_INVALIDLENGTH);\\n    }\\n    let sourceSize = <usize>sourceLen << alignof<T>();\\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\\n\\n    if (out instanceof Array<T>) {\\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\\n      let outStart = changetype<Array<T>>(out).dataStart;\\n      let otherStart = changetype<Array<T>>(other).dataStart;\\n      let thisStart = changetype<usize>(this);\\n\\n      if (isManaged<T>()) {\\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(thisStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(changetype<usize>(out), ref, true);\\n        }\\n        outStart += sourceSize;\\n        let otherSize = <usize>otherLen << alignof<T>();\\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(otherStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(changetype<usize>(out), ref, true);\\n        }\\n      } else {\\n        memory.copy(outStart, thisStart, sourceSize);\\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\\n      }\\n    } else if (out instanceof StaticArray<T>) {\\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\\n      let outStart = changetype<usize>(out);\\n      let otherStart = changetype<usize>(other);\\n      let thisStart = changetype<usize>(this);\\n\\n      if (isManaged<T>()) {\\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(thisStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(changetype<usize>(out), ref, true);\\n        }\\n        outStart += sourceSize;\\n        let otherSize = <usize>otherLen << alignof<T>();\\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(otherStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(changetype<usize>(out), ref, true);\\n        }\\n      } else {\\n        memory.copy(outStart, thisStart, sourceSize);\\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\\n      }\\n    } else {\\n      ERROR(\\\"Only Array<T> and StaticArray<T> accept for 'U' parameter\\\");\\n    }\\n    return out;\\n  }\\n\\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\\n    let length = this.length;\\n    start = start < 0 ? max(start + length, 0) : min(start, length);\\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\\n    length = max(end - start, 0);\\n\\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\\n    let size = <usize>length << alignof<T>();\\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\\n\\n    if (out instanceof Array<T>) {\\n      // return Array\\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\\n      let outStart = changetype<Array<T>>(out).dataStart;\\n      if (isManaged<T>()) {\\n        let off: usize = 0;\\n        while (off < size) {\\n          let ref = load<usize>(sourceStart + off);\\n          store<usize>(outStart + off, ref);\\n          __link(changetype<usize>(out), ref, true);\\n          off += sizeof<usize>();\\n        }\\n      } else {\\n        memory.copy(outStart, sourceStart, size);\\n      }\\n    } else if (out instanceof StaticArray<T>) {\\n      // return StaticArray\\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\\n      let outStart = changetype<usize>(out);\\n      if (isManaged<T>()) {\\n        let off: usize = 0;\\n        while (off < size) {\\n          let ref = load<usize>(sourceStart + off);\\n          store<usize>(outStart + off, ref);\\n          __link(outStart, ref, true);\\n          off += sizeof<usize>();\\n        }\\n      } else {\\n        memory.copy(outStart, sourceStart, size);\\n      }\\n    } else {\\n      ERROR(\\\"Only Array<T> and StaticArray<T> accept for 'U' parameter\\\");\\n    }\\n    return out;\\n  }\\n\\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\\n    for (let i = this.length - 1; i >= 0; --i) {\\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n    }\\n  }\\n\\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\\n    let len = this.length;\\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\\n    let outStart = out.dataStart;\\n    for (let i = 0; i < len; ++i) {\\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\\n      if (isManaged<U>()) {\\n        __link(changetype<usize>(out), changetype<usize>(result), true);\\n      }\\n    }\\n    return out;\\n  }\\n\\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\\n      if (fn(value, i, this)) result.push(value);\\n    }\\n    return result;\\n  }\\n\\n  reduce<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  reduceRight<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = this.length - 1; i >= 0; --i) {\\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\\n    }\\n    return true;\\n  }\\n\\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\\n    }\\n    return false;\\n  }\\n\\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\\n    SORT<T>(changetype<usize>(this), this.length, comparator);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\\n    }\\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\\n    ERROR(\\\"unspported element type\\\");\\n    return <string>unreachable();\\n  }\\n\\n  reverse(): StaticArray<T> {\\n    REVERSE<T>(changetype<usize>(this), this.length);\\n    return this;\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    if (isManaged<T>()) {\\n      let cur = changetype<usize>(this);\\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\\n      while (cur < end) {\\n        let val = load<usize>(cur);\\n        if (val) __visit(val, cookie);\\n        cur += sizeof<usize>();\\n      }\\n    }\\n  }\\n}\\n\",\n  \"string\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \\\"./rt/common\\\";\\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \\\"./util/string\\\";\\nimport { SPECIALS_UPPER, casemap, bsearch } from \\\"./util/casemap\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \\\"./util/error\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { Array } from \\\"./array\\\";\\n\\n@final export abstract class String {\\n\\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\\n\\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\\n    let hasSur = surr > 0;\\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\\n    store<u16>(changetype<usize>(out), <u16>unit);\\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\\n    return out;\\n  }\\n\\n  static fromCharCodes(units: Array<i32>): String {\\n    let length = units.length;\\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\\n    let ptr = units.dataStart;\\n    for (let i = 0; i < length; ++i) {\\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\\n    }\\n    return out;\\n  }\\n\\n  static fromCodePoint(code: i32): String {\\n    let hasSur = <u32>code > 0xFFFF;\\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\\n    if (!hasSur) {\\n      store<u16>(changetype<usize>(out), <u16>code);\\n    } else {\\n      // Checks valid code point range\\n      assert(<u32>code <= 0x10FFFF);\\n      code -= 0x10000;\\n      let hi = (code & 0x03FF) | 0xDC00;\\n      let lo = code >>> 10 | 0xD800;\\n      store<u32>(changetype<usize>(out), lo | hi << 16);\\n    }\\n    return out;\\n  }\\n\\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\\n\\n  get length(): i32 {\\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\\n  }\\n\\n  at(pos: i32): String {\\n    let len = this.length;\\n    pos += select(0, len, pos >= 0);\\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let out = __new(2, idof<String>());\\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\\n    return changetype<String>(out); // retains\\n  }\\n\\n  @operator(\\\"[]\\\") charAt(pos: i32): String {\\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(2, idof<String>()));\\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\\n    return out;\\n  }\\n\\n  charCodeAt(pos: i32): i32 {\\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\\n  }\\n\\n  codePointAt(pos: i32): i32 {\\n    let len = this.length;\\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\\n    if ((second & 0xFC00) != 0xDC00) return first;\\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\\n  }\\n\\n  @operator(\\\"+\\\") private static __concat(left: String, right: String): String {\\n    return left.concat(right);\\n  }\\n\\n  concat(other: String): String {\\n    let thisSize: isize = this.length << 1;\\n    let otherSize: isize = other.length << 1;\\n    let outSize: usize = thisSize + otherSize;\\n    if (outSize == 0) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(outSize, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\\n    return out;\\n  }\\n\\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\\n    end = min(max(end, 0), this.length);\\n    let searchLength = <isize>search.length;\\n    let searchStart = <isize>end - searchLength;\\n    if (searchStart < 0) return false;\\n    // @ts-ignore: string <-> String\\n    return !compareImpl(this, searchStart, search, 0, searchLength);\\n  }\\n\\n  @operator(\\\"==\\\") private static __eq(left: String | null, right: String | null): bool {\\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\\n    let leftLength = changetype<string>(left).length;\\n    if (leftLength != changetype<string>(right).length) return false;\\n    // @ts-ignore: string <-> String\\n    return !compareImpl(left, 0, right, 0, leftLength);\\n  }\\n\\n  @operator.prefix(\\\"!\\\")\\n  private static __not(str: String | null): bool {\\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\\n  }\\n\\n  @operator(\\\"!=\\\")\\n  private static __ne(left: String | null, right: String | null): bool {\\n    return !this.__eq(left, right);\\n  }\\n\\n  @operator(\\\">\\\") private static __gt(left: String, right: String): bool {\\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\\n    let leftLength  = left.length;\\n    if (!leftLength) return false;\\n    let rightLength = right.length;\\n    if (!rightLength) return true;\\n    // @ts-ignore: string <-> String\\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\\n    return res ? res > 0 : leftLength > rightLength;\\n  }\\n\\n  @operator(\\\">=\\\") private static __gte(left: String, right: String): bool {\\n    return !this.__lt(left, right);\\n  }\\n\\n  @operator(\\\"<\\\") private static __lt(left: String, right: String): bool {\\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\\n    let rightLength = right.length;\\n    if (!rightLength) return false;\\n    let leftLength  = left.length;\\n    if (!leftLength) return true;\\n    // @ts-ignore: string <-> String\\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\\n    return res ? res < 0 : leftLength < rightLength;\\n  }\\n\\n  @operator(\\\"<=\\\") private static __lte(left: String, right: String): bool {\\n    return !this.__gt(left, right);\\n  }\\n\\n  includes(search: String, start: i32 = 0): bool {\\n    return this.indexOf(search, start) != -1;\\n  }\\n\\n  indexOf(search: String, start: i32 = 0): i32 {\\n    let searchLen = <isize>search.length;\\n    if (!searchLen) return 0;\\n    let len = <isize>this.length;\\n    if (!len) return -1;\\n    let searchStart = min(max(<isize>start, 0), len);\\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\\n      // @ts-ignore: string <-> String\\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\\n    }\\n    return -1;\\n  }\\n\\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\\n    let searchLen = <isize>search.length;\\n    if (!searchLen) return this.length;\\n    let len = this.length;\\n    if (!len) return -1;\\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\\n    for (; searchStart >= 0; --searchStart) {\\n      // @ts-ignore: string <-> String\\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\\n    }\\n    return -1;\\n  }\\n\\n  // TODO: implement full locale comparison with locales and Collator options\\n  localeCompare(other: String): i32 {\\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\\n    let alen = this.length;\\n    let blen = other.length;\\n    // @ts-ignore: string <-> String\\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\\n    res = res ? res : alen - blen;\\n    // normalize to [-1, 1] range\\n    return i32(res > 0) - i32(res < 0);\\n  }\\n\\n  startsWith(search: String, start: i32 = 0): bool {\\n    let len = <isize>this.length;\\n    let searchStart = min(max(<isize>start, 0), len);\\n    let searchLength = <isize>search.length;\\n    if (searchLength + searchStart > len) return false;\\n    // @ts-ignore: string <-> String\\n    return !compareImpl(this, searchStart, search, 0, searchLength);\\n  }\\n\\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\\n    let intStart: isize = start;\\n    let end: isize = length;\\n    let len: isize = this.length;\\n    if (intStart < 0) intStart = max(len + intStart, 0);\\n    let size = min(max(end, 0), len - intStart) << 1;\\n    if (size <= 0) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\\n    return out;\\n  }\\n\\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\\n    let len: isize = this.length;\\n    let finalStart = min<isize>(max(start, 0), len);\\n    let finalEnd = min<isize>(max(end, 0), len);\\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\\n    let size = toPos - fromPos;\\n    if (!size) return changetype<String>(\\\"\\\");\\n    if (!fromPos && toPos == len << 1) return this;\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\\n    return out;\\n  }\\n\\n  trim(): String {\\n    let len = this.length;\\n    let size: usize = len << 1;\\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\\n      size -= 2;\\n    }\\n    let offset: usize = 0;\\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\\n      offset += 2; size -= 2;\\n    }\\n    if (!size) return changetype<String>(\\\"\\\");\\n    if (!offset && size == len << 1) return this;\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\\n    return out;\\n  }\\n\\n  @inline\\n  trimLeft(): String {\\n    return this.trimStart();\\n  }\\n\\n  @inline\\n  trimRight(): String {\\n    return this.trimEnd();\\n  }\\n\\n  trimStart(): String {\\n    let size = <usize>this.length << 1;\\n    let offset: usize = 0;\\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\\n      offset += 2;\\n    }\\n    if (!offset) return this;\\n    size -= offset;\\n    if (!size) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\\n    return out;\\n  }\\n\\n  trimEnd(): String {\\n    let originalSize = <usize>this.length << 1;\\n    let size = originalSize;\\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\\n      size -= 2;\\n    }\\n    if (!size) return changetype<String>(\\\"\\\");\\n    if (size == originalSize) return this;\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\\n    return out;\\n  }\\n\\n  padStart(length: i32, pad: string = \\\" \\\"): String {\\n    let thisSize = <usize>this.length << 1;\\n    let targetSize = <usize>length << 1;\\n    let padSize = <usize>pad.length << 1;\\n    if (targetSize < thisSize || !padSize) return this;\\n    let prependSize = targetSize - thisSize;\\n    let out = changetype<String>(__new(targetSize, idof<String>()));\\n    if (prependSize > padSize) {\\n      let repeatCount = (prependSize - 2) / padSize;\\n      let restBase = repeatCount * padSize;\\n      let restSize = prependSize - restBase;\\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\\n    } else {\\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\\n    }\\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\\n    return out;\\n  }\\n\\n  padEnd(length: i32, pad: string = \\\" \\\"): String {\\n    let thisSize = <usize>this.length << 1;\\n    let targetSize = <usize>length << 1;\\n    let padSize = <usize>pad.length << 1;\\n    if (targetSize < thisSize || !padSize) return this;\\n    let appendSize = targetSize - thisSize;\\n    let out = changetype<String>(__new(targetSize, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\\n    if (appendSize > padSize) {\\n      let repeatCount = (appendSize - 2) / padSize;\\n      let restBase = repeatCount * padSize;\\n      let restSize = appendSize - restBase;\\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\\n    } else {\\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\\n    }\\n    return out;\\n  }\\n\\n  repeat(count: i32 = 0): String {\\n    let length = this.length;\\n\\n    // Most browsers can't handle strings 1 << 28 chars or longer\\n    if (count < 0 || <u64>length * count > (1 << 28)) {\\n      throw new RangeError(E_INVALIDLENGTH);\\n    }\\n\\n    if (count == 0 || !length) return changetype<String>(\\\"\\\");\\n    if (count == 1) return this;\\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\\n    return out;\\n  }\\n\\n  replace(search: String, replacement: String): String {\\n    let len: usize = this.length;\\n    let slen: usize = search.length;\\n    if (len <= slen) {\\n      return len < slen ? this : select<String>(replacement, this, search == this);\\n    }\\n    let index: isize = this.indexOf(search);\\n    if (~index) {\\n      let rlen: usize = replacement.length;\\n      len -= slen;\\n      let olen = len + rlen;\\n      if (olen) {\\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\\n        memory.copy(\\n          changetype<usize>(out) + (index << 1),\\n          changetype<usize>(replacement),\\n          rlen << 1\\n        );\\n        memory.copy(\\n          changetype<usize>(out) + ((index + rlen) << 1),\\n          changetype<usize>(this) + ((index + slen) << 1),\\n          (len - index) << 1\\n        );\\n        return out;\\n      }\\n    }\\n    return this;\\n  }\\n\\n  replaceAll(search: String, replacement: String): String {\\n    let thisLen: usize = this.length;\\n    let searchLen: usize = search.length;\\n    if (thisLen <= searchLen) {\\n      return thisLen < searchLen\\n        ? this\\n        : select<String>(replacement, this, search == this);\\n    }\\n    let replaceLen: usize = replacement.length;\\n    if (!searchLen) {\\n      if (!replaceLen) return this;\\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\\n      let offset = replaceLen;\\n      for (let i: usize = 0; i < thisLen; ++i) {\\n        store<u16>(\\n          changetype<usize>(out) + (offset++ << 1),\\n          load<u16>(changetype<usize>(this) + (i << 1))\\n        );\\n        memory.copy(\\n          changetype<usize>(out) + (offset << 1),\\n          changetype<usize>(replacement),\\n          replaceLen << 1\\n        );\\n        offset += replaceLen;\\n      }\\n      return out;\\n    }\\n    let prev: isize = 0, next: isize = 0;\\n    if (searchLen == replaceLen) {\\n      // Fast path when search and replacement have same length\\n      let outSize = thisLen << 1;\\n      let out = changetype<String>(__new(outSize, idof<String>()));\\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\\n        prev = next + searchLen;\\n      }\\n      return out;\\n    }\\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\\n      let chunk = next - prev;\\n      if (offset + chunk + replaceLen > outSize) {\\n        outSize <<= 1;\\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\\n      }\\n      memory.copy(\\n        changetype<usize>(out) + (offset << 1),\\n        changetype<usize>(this) + (prev << 1),\\n        chunk << 1\\n      );\\n      offset += chunk;\\n      memory.copy(\\n        changetype<usize>(out) + (offset << 1),\\n        changetype<usize>(replacement),\\n        replaceLen << 1\\n      );\\n      offset += replaceLen;\\n      prev = next + searchLen;\\n    }\\n    if (out) {\\n      let rest = thisLen - prev;\\n      if (offset + rest > outSize) {\\n        outSize <<= 1;\\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\\n      }\\n      if (rest) {\\n        memory.copy(\\n          changetype<usize>(out) + (offset << 1),\\n          changetype<usize>(this) + (prev << 1),\\n          rest << 1\\n        );\\n      }\\n      rest += offset;\\n      if (outSize > rest) {\\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\\n      }\\n      return out;\\n    }\\n    return this;\\n  }\\n\\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\\n    let len = this.length;\\n    start = start < 0 ? max(start + len, 0) : min(start, len);\\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\\n    len   = end - start;\\n    if (len <= 0) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(len << 1, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\\n    return out;\\n  }\\n\\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\\n    if (changetype<usize>(separator) == 0) return [ this ];\\n    let length: isize = this.length;\\n    let sepLen = changetype<string>(separator).length;\\n    if (limit < 0) limit = i32.MAX_VALUE;\\n    if (!sepLen) {\\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\\n      // split by chars\\n      length = min<isize>(length, <isize>limit);\\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\\n      // @ts-ignore: cast\\n      let resultStart = result.dataStart as usize;\\n      for (let i: isize = 0; i < length; ++i) {\\n        let charStr = changetype<String>(__new(2, idof<String>()));\\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\\n      }\\n      return result;\\n    } else if (!length) {\\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\\n      // @ts-ignore: cast\\n      store<usize>(result.dataStart as usize, changetype<usize>(\\\"\\\")); // static \\\"\\\"\\n      return result;\\n    }\\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\\n    let end = 0, start = 0, i = 0;\\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\\n      let len = end - start;\\n      if (len > 0) {\\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\\n        result.push(out);\\n      } else {\\n        result.push(changetype<String>(\\\"\\\"));\\n      }\\n      if (++i == limit) return result;\\n      start = end + sepLen;\\n    }\\n    if (!start) { // also means: loop above didn't do anything\\n      result.push(this);\\n      return result;\\n    }\\n    let len = length - start;\\n    if (len > 0) {\\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\\n      result.push(out);\\n    } else {\\n      result.push(changetype<String>(\\\"\\\")); // static \\\"\\\"\\n    }\\n    return result;\\n  }\\n\\n  toLowerCase(): String {\\n    let len = <usize>this.length;\\n    if (!len) return this;\\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\\n    let j: usize = 0;\\n    for (let i: usize = 0; i < len; ++i, ++j) {\\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\\n      if (isAscii(c)) {\\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\\n      } else {\\n        // check and read surrogate pair\\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\\n            let c0 = c;\\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\\n            ++i;\\n            if (c >= 0x20000) {\\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\\n              ++j;\\n              continue;\\n            }\\n          }\\n        }\\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\\n        if (c == 0x0130) {\\n          // 0x0130 -> [0x0069, 0x0307]\\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\\n          ++j;\\n        } else if (c == 0x03A3) { // '\u03A3'\\n          // \u03A3 maps to \u03C3 but except at the end of a word where it maps to \u03C2\\n          let sigma = 0x03C3; // \u03C3\\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\\n            sigma = 0x03C2; // \u03C2\\n          }\\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\\n        } else {\\n          let code = casemap(c, 0) & 0x1FFFFF;\\n          if (code < 0x10000) {\\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\\n          } else {\\n            // store as surrogare pair\\n            code -= 0x10000;\\n            let lo = (code >>> 10) | 0xD800;\\n            let hi = (code & 0x03FF) | 0xDC00;\\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\\n            ++j;\\n          }\\n        }\\n      }\\n    }\\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\\n  }\\n\\n  toUpperCase(): String {\\n    let len = <usize>this.length;\\n    if (!len) return this;\\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\\n    let specialsLen = SPECIALS_UPPER.length;\\n    let j: usize = 0;\\n    for (let i: usize = 0; i < len; ++i, ++j) {\\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\\n      if (isAscii(c)) {\\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\\n      } else {\\n        // check and read surrogate pair\\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\\n            let c0 = c;\\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\\n            ++i;\\n            if (c >= 0x20000) {\\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\\n              ++j;\\n              continue;\\n            }\\n          }\\n        }\\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\\n          // monkey patch\\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\\n        } else {\\n          let index: usize = -1;\\n          // Fast range check. See first and last rows in specialsUpper table\\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\\n          }\\n          if (~index) {\\n            // load next 3 code points from row with `index` offset for specialsUpper table\\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\\n            j += 1 + usize(cc != 0);\\n          } else {\\n            let code = casemap(c, 1) & 0x1FFFFF;\\n            if (code < 0x10000) {\\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\\n            } else {\\n              // store as surrogare pair\\n              code -= 0x10000;\\n              let lo = (code >>> 10) | 0xD800;\\n              let hi = (code & 0x03FF) | 0xDC00;\\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\\n              ++j;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\\n  }\\n\\n  toString(): String {\\n    return this;\\n  }\\n}\\n\\n// @ts-ignore: nolib\\nexport type string = String;\\n\\nexport function parseInt(str: string, radix: i32 = 0): f64 {\\n  return strtol<f64>(str, radix);\\n}\\n\\nexport function parseFloat(str: string): f64 {\\n  return strtod(str);\\n}\\n\\n// Encoding helpers\\nexport namespace String {\\n\\n  export namespace UTF8 {\\n\\n    export const enum ErrorMode {\\n      WTF8,\\n      REPLACE,\\n      ERROR\\n    }\\n\\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\\n      let strOff = changetype<usize>(str);\\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\\n      let bufLen = i32(nullTerminated);\\n      while (strOff < strEnd) {\\n        let c1 = <u32>load<u16>(strOff);\\n        if (c1 < 128) {\\n          // @ts-ignore: cast\\n          if (nullTerminated & !c1) break;\\n          bufLen += 1;\\n        } else if (c1 < 2048) {\\n          bufLen += 2;\\n        } else {\\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\\n              bufLen += 4; strOff += 4;\\n              continue;\\n            }\\n          }\\n          bufLen += 3;\\n        }\\n        strOff += 2;\\n      }\\n      return bufLen;\\n    }\\n\\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\\n      return buf;\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\\n      let strEnd = str + (<usize>len << 1);\\n      let bufOff = buf;\\n      while (str < strEnd) {\\n        let c1 = <u32>load<u16>(str);\\n        if (c1 < 128) {\\n          store<u8>(bufOff, c1);\\n          bufOff++;\\n          // @ts-ignore: cast\\n          if (nullTerminated & !c1) return bufOff - buf;\\n        } else if (c1 < 2048) {\\n          let b0 = c1 >> 6 | 192;\\n          let b1 = c1 & 63 | 128;\\n          store<u16>(bufOff, b1 << 8 | b0);\\n          bufOff += 2;\\n        } else {\\n          // D800: 11011 0 0000000000 Lead\\n          // DBFF: 11011 0 1111111111\\n          // DC00: 11011 1 0000000000 Trail\\n          // DFFF: 11011 1 1111111111\\n          // F800: 11111 0 0000000000 Mask\\n          // FC00: 11111 1 0000000000\\n          if ((c1 & 0xF800) == 0xD800) {\\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\\n              let c2 = <u32>load<u16>(str, 2);\\n              if ((c2 & 0xFC00) == 0xDC00) {\\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\\n                let b0 = c1 >> 18 | 240;\\n                let b1 = c1 >> 12 & 63 | 128;\\n                let b2 = c1 >> 6  & 63 | 128;\\n                let b3 = c1       & 63 | 128;\\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\\n                bufOff += 4; str += 4;\\n                continue;\\n              }\\n            }\\n            if (errorMode != ErrorMode.WTF8) { // unlikely\\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\\n              c1 = 0xFFFD;\\n            }\\n          }\\n          let b0 = c1 >> 12 | 224;\\n          let b1 = c1 >> 6  & 63 | 128;\\n          let b2 = c1       & 63 | 128;\\n          store<u16>(bufOff, b1 << 8 | b0);\\n          store<u8>(bufOff, b2, 2);\\n          bufOff += 3;\\n        }\\n        str += 2;\\n      }\\n      if (nullTerminated) {\\n        store<u8>(bufOff++, 0);\\n      }\\n      return bufOff - buf;\\n    }\\n\\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\\n      let bufOff = buf;\\n      let bufEnd = buf + len;\\n      assert(bufEnd >= bufOff); // guard wraparound\\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\\n      let strOff = changetype<usize>(str);\\n      while (bufOff < bufEnd) {\\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\\n        if (!(u0 & 128)) {\\n          // @ts-ignore: cast\\n          if (nullTerminated & !u0) break;\\n          store<u16>(strOff, u0);\\n        } else {\\n          if (bufEnd == bufOff) break;\\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\\n          if ((u0 & 224) == 192) {\\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\\n          } else {\\n            if (bufEnd == bufOff) break;\\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\\n            if ((u0 & 240) == 224) {\\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\\n            } else {\\n              if (bufEnd == bufOff) break;\\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\\n              ++bufOff;\\n            }\\n            if (u0 < 0x10000) {\\n              store<u16>(strOff, u0);\\n            } else {\\n              u0 -= 0x10000;\\n              let lo = u0 >> 10 | 0xD800;\\n              let hi = (u0 & 0x03FF) | 0xDC00;\\n              store<u32>(strOff, lo | (hi << 16));\\n              strOff += 2;\\n            }\\n          }\\n        }\\n        strOff += 2;\\n      }\\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\\n    }\\n  }\\n\\n  export namespace UTF16 {\\n\\n    export function byteLength(str: string): i32 {\\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\\n    }\\n\\n    export function encode(str: string): ArrayBuffer {\\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\\n      return buf;\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\\n      let size = <usize>len << 1;\\n      memory.copy(buf, changetype<usize>(str), size);\\n      return size;\\n    }\\n\\n    export function decode(buf: ArrayBuffer): String {\\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function decodeUnsafe(buf: usize, len: usize): String {\\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\\n      memory.copy(changetype<usize>(str), buf, len);\\n      return str;\\n    }\\n  }\\n}\\n\\nexport class TemplateStringsArray extends Array<string> {\\n  readonly raw: string[];\\n}\\n\",\n  \"symbol\": \"import { Map } from \\\"./map\\\";\\n\\n// @ts-ignore: decorator\\n@lazy let stringToId: Map<string, usize> = new Map();\\n\\n// @ts-ignore: decorator\\n@lazy let idToString: Map<usize, string> = new Map();\\n\\n// @ts-ignore: decorator\\n@lazy let nextId: usize = 12; // Symbol.unscopables + 1\\n\\n@unmanaged @final abstract class _Symbol {\\n\\n  // TODO: all of the following default symbols are unused currently yet add to\\n  // binary size if #toString becomes compiled. Ultimately we'll most likely want\\n  // to remove the unsupported ones and only keep what's actually supported.\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly hasInstance: symbol = changetype<symbol>(1);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly isConcatSpreadable: symbol = changetype<symbol>(2);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly isRegExp: symbol = changetype<symbol>(3);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly iterator: symbol = changetype<symbol>(3);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly match: symbol = changetype<symbol>(4);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly replace: symbol = changetype<symbol>(5);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly search: symbol = changetype<symbol>(6);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly species: symbol = changetype<symbol>(7);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly split: symbol = changetype<symbol>(8);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly toPrimitive: symbol = changetype<symbol>(9);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly toStringTag: symbol = changetype<symbol>(10);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly unscopables: symbol = changetype<symbol>(11);\\n\\n  static for(key: string): symbol {\\n    if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));\\n    let id = nextId++;\\n    if (!id) unreachable(); // out of ids\\n    stringToId.set(key, id);\\n    idToString.set(id, key);\\n    return changetype<symbol>(id);\\n  }\\n\\n  static keyFor(sym: symbol): string | null {\\n    return idToString.has(changetype<usize>(sym))\\n      ? idToString.get(changetype<usize>(sym))\\n      : null;\\n  }\\n\\n  toString(): string {\\n    let id = changetype<usize>(this);\\n    let str = \\\"\\\";\\n    switch (<u32>id) {\\n      case 1:  { str = \\\"hasInstance\\\"; break; }\\n      case 2:  { str = \\\"isConcatSpreadable\\\"; break; }\\n      case 3:  { str = \\\"isRegExp\\\"; break; }\\n      case 4:  { str = \\\"match\\\"; break; }\\n      case 5:  { str = \\\"replace\\\"; break; }\\n      case 6:  { str = \\\"search\\\"; break; }\\n      case 7:  { str = \\\"species\\\"; break; }\\n      case 8:  { str = \\\"split\\\"; break; }\\n      case 9:  { str = \\\"toPrimitive\\\"; break; }\\n      case 10: { str = \\\"toStringTag\\\"; break; }\\n      case 11: { str = \\\"unscopables\\\"; break; }\\n      default: {\\n        if (idToString != null && idToString.has(id)) str = idToString.get(id);\\n        break;\\n      }\\n    }\\n    return \\\"Symbol(\\\" + str + \\\")\\\";\\n  }\\n}\\n\\nexport function Symbol(description: string | null = null): symbol {\\n  let id = nextId++;\\n  if (!id) unreachable(); // out of ids\\n  return changetype<symbol>(id);\\n}\\n\\nexport type Symbol = _Symbol;\\n\\n// @ts-ignore: nolib\\nexport type symbol = _Symbol;\\n\",\n  \"table\": \"import { E_NOTIMPLEMENTED } from \\\"./util/error\\\";\\n\\nexport namespace table {\\n\\n  export function copy(dst: u32, src: u32, n: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  export function drop(elementIndex: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n}\\n\",\n  \"typedarray\": \"import { COMPARATOR, SORT } from \\\"./util/sort\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \\\"./util/error\\\";\\nimport { joinIntegerArray, joinFloatArray } from \\\"./util/string\\\";\\nimport { REVERSE, FILL } from \\\"./util/bytes\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { ArrayBufferView } from \\\"./arraybuffer\\\";\\n\\nexport class Int8Array extends ArrayBufferView {\\n  [key: number]: i8;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i8>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i8 {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i8>(this.dataStart + <usize>index);\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i8 {\\n    return load<i8>(this.dataStart + <usize>index);\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<i8>): void {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<i8>): void {\\n    store<i8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  at(index: i32): i8 {\\n    let len = this.byteLength;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i8>(this.dataStart + <usize>index);\\n  }\\n\\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\\n    SORT<i8>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\\n    return SLICE<Int8Array, i8>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\\n    return MAP<Int8Array, i8>(this, fn);\\n  }\\n\\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\\n    return FILTER<Int8Array, i8>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\\n    return FIND_INDEX<Int8Array, i8>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\\n  }\\n\\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\\n    return SOME<Int8Array, i8>(this, fn);\\n  }\\n\\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\\n    return EVERY<Int8Array, i8>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\\n    FOREACH<Int8Array, i8>(this, fn);\\n  }\\n\\n  reverse(): Int8Array {\\n    REVERSE<u8>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint8Array extends ArrayBufferView {\\n  [key: number]: u8;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u8>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u8 {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u8 {\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<u8>): void {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<u8>): void {\\n    store<u8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  at(index: i32): u8 {\\n    let len = this.byteLength;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\\n    SORT<u8>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    return SLICE<Uint8Array, u8>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\\n    return MAP<Uint8Array, u8>(this, fn);\\n  }\\n\\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\\n    return FILTER<Uint8Array, u8>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\\n  }\\n\\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\\n    return SOME<Uint8Array, u8>(this, fn);\\n  }\\n\\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\\n    return EVERY<Uint8Array, u8>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\\n    FOREACH<Uint8Array, u8>(this, fn);\\n  }\\n\\n  reverse(): Uint8Array {\\n    REVERSE<u8>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint8ClampedArray extends ArrayBufferView {\\n  [key: number]: u8;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u8>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u8 {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u8 {\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<u8>): void {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<u8>): void {\\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\\n  }\\n\\n  at(index: i32): u8 {\\n    let len = this.byteLength;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\\n    SORT<u8>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\\n  }\\n\\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\\n    return MAP<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\\n    return SOME<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  reverse(): Uint8ClampedArray {\\n    REVERSE<u8>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Int16Array extends ArrayBufferView {\\n  [key: number]: i16;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i16>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<i16>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i16 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i16 {\\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<i16>): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<i16>): void {\\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\\n  }\\n\\n  at(index: i32): i16 {\\n    let len = this.byteLength >>> alignof<i16>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\\n  }\\n\\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\\n    SORT<i16>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\\n    return SLICE<Int16Array, i16>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\\n    return MAP<Int16Array, i16>(this, fn);\\n  }\\n\\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\\n    return FILTER<Int16Array, i16>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\\n    return FIND_INDEX<Int16Array, i16>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\\n  }\\n\\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\\n    return SOME<Int16Array, i16>(this, fn);\\n  }\\n\\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\\n    return EVERY<Int16Array, i16>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\\n    FOREACH<Int16Array, i16>(this, fn);\\n  }\\n\\n  reverse(): Int16Array {\\n    REVERSE<u16>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint16Array extends ArrayBufferView {\\n  [key: number]: u16;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u16>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<u16>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u16 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u16 {\\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<u16>): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<u16>): void {\\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\\n  }\\n\\n  at(index: i32): u16 {\\n    let len = this.byteLength >>> alignof<u16>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\\n  }\\n\\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\\n    SORT<u16>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    return SLICE<Uint16Array, u16>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\\n    return MAP<Uint16Array, u16>(this, fn);\\n  }\\n\\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\\n    return FILTER<Uint16Array, u16>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\\n  }\\n\\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\\n    return SOME<Uint16Array, u16>(this, fn);\\n  }\\n\\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\\n    return EVERY<Uint16Array, u16>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\\n    FOREACH<Uint16Array, u16>(this, fn);\\n  }\\n\\n  reverse(): Uint16Array {\\n    REVERSE<u16>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Int32Array extends ArrayBufferView {\\n  [key: number]: i32;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i32>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<i32>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i32 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i32 {\\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: i32): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: i32): void {\\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\\n  }\\n\\n  at(index: i32): i32 {\\n    let len = this.byteLength >>> alignof<i32>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\\n  }\\n\\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\\n    SORT<i32>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\\n    return SLICE<Int32Array, i32>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\\n    return MAP<Int32Array, i32>(this, fn);\\n  }\\n\\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\\n    return FILTER<Int32Array, i32>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\\n    return FIND_INDEX<Int32Array, i32>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\\n  }\\n\\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\\n    return SOME<Int32Array, i32>(this, fn);\\n  }\\n\\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\\n    return EVERY<Int32Array, i32>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\\n    FOREACH<Int32Array, i32>(this, fn);\\n  }\\n\\n  reverse(): Int32Array {\\n    REVERSE<u32>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint32Array extends ArrayBufferView {\\n  [key: number]: u32;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u32>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<u32>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u32 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u32 {\\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: u32): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: u32): void {\\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\\n  }\\n\\n  at(index: i32): u32 {\\n    let len = this.byteLength >>> alignof<u32>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\\n  }\\n\\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    FILL<u32>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\\n    SORT<u32>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    return SLICE<Uint32Array, u32>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\\n    return MAP<Uint32Array, u32>(this, fn);\\n  }\\n\\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\\n    return FILTER<Uint32Array, u32>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\\n  }\\n\\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\\n    return SOME<Uint32Array, u32>(this, fn);\\n  }\\n\\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\\n    return EVERY<Uint32Array, u32>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\\n    FOREACH<Uint32Array, u32>(this, fn);\\n  }\\n\\n  reverse(): Uint32Array {\\n    REVERSE<u32>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Int64Array extends ArrayBufferView {\\n  [key: number]: i64;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i64>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<i64>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i64 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i64 {\\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: i64): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: i64): void {\\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\\n  }\\n\\n  at(index: i32): i64 {\\n    let len = this.byteLength >>> alignof<i64>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\\n  }\\n\\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\\n    SORT<i64>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\\n    return SLICE<Int64Array, i64>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\\n    return MAP<Int64Array, i64>(this, fn);\\n  }\\n\\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\\n    return FILTER<Int64Array, i64>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\\n    return FIND_INDEX<Int64Array, i64>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\\n  }\\n\\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\\n    return SOME<Int64Array, i64>(this, fn);\\n  }\\n\\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\\n    return EVERY<Int64Array, i64>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\\n    FOREACH<Int64Array, i64>(this, fn);\\n  }\\n\\n  reverse(): Int64Array {\\n    REVERSE<u64>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint64Array extends ArrayBufferView {\\n  [key: number]: u64;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u64>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<u64>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u64 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u64 {\\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: u64): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: u64): void {\\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\\n  }\\n\\n  at(index: i32): u64 {\\n    let len = this.byteLength >>> alignof<u64>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\\n  }\\n\\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    FILL<u64>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\\n    SORT<u64>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    return SLICE<Uint64Array, u64>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\\n    return MAP<Uint64Array, u64>(this, fn);\\n  }\\n\\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\\n    return FILTER<Uint64Array, u64>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\\n  }\\n\\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\\n    return SOME<Uint64Array, u64>(this, fn);\\n  }\\n\\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\\n    return EVERY<Uint64Array, u64>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\\n    FOREACH<Uint64Array, u64>(this, fn);\\n  }\\n\\n  reverse(): Uint64Array {\\n    REVERSE<u64>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Float32Array extends ArrayBufferView {\\n  [key: number]: f32;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<f32>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<f32>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): f32 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): f32 {\\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: f32): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: f32): void {\\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\\n  }\\n\\n  at(index: i32): f32 {\\n    let len = this.byteLength >>> alignof<f32>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\\n  }\\n\\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\\n    FILL<f32>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\\n    SORT<f32>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\\n    return SLICE<Float32Array, f32>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\\n    return MAP<Float32Array, f32>(this, fn);\\n  }\\n\\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\\n    return FILTER<Float32Array, f32>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\\n    return FIND_INDEX<Float32Array, f32>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\\n  }\\n\\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\\n    return SOME<Float32Array, f32>(this, fn);\\n  }\\n\\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\\n    return EVERY<Float32Array, f32>(this, fn);\\n  }\\n\\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\\n    FOREACH<Float32Array, f32>(this, fn);\\n  }\\n\\n  reverse(): Float32Array {\\n    REVERSE<f32>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Float64Array extends ArrayBufferView {\\n  [key: number]: f64;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<f64>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<f64>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): f64 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): f64 {\\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: f64): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: f64): void {\\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\\n  }\\n\\n  at(index: i32): f64 {\\n    let len = this.byteLength >>> alignof<f64>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\\n  }\\n\\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\\n    FILL<f64>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\\n    SORT<f64>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\\n    return SLICE<Float64Array, f64>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\\n    return MAP<Float64Array, f64>(this, fn);\\n  }\\n\\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\\n    return FILTER<Float64Array, f64>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\\n    return FIND_INDEX<Float64Array, f64>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\\n  }\\n\\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\\n    return SOME<Float64Array, f64>(this, fn);\\n  }\\n\\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\\n    return EVERY<Float64Array, f64>(this, fn);\\n  }\\n\\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\\n    FOREACH<Float64Array, f64>(this, fn);\\n  }\\n\\n  reverse(): Float64Array {\\n    REVERSE<f64>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  start: i32,\\n  end: i32\\n): TArray {\\n  let len = array.length;\\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\\n  len = max(end - start, 0);\\n  let slice = instantiate<TArray>(len);\\n  memory.copy(\\n    slice.dataStart,\\n    array.dataStart + (<usize>start << alignof<T>()),\\n    <usize>len << alignof<T>()\\n  );\\n  return slice;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  begin: i32,\\n  end: i32\\n): TArray {\\n  let len = array.length;\\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\\n  end   = max(end, begin);\\n\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  let buf = changetype<usize>(array.buffer);\\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), buf, false);\\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\\\"dataStart\\\"));\\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\\\"byteLength\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  target: i32,\\n  start: i32,\\n  end: i32\\n): TArray {\\n  let len = array.length;\\n  let ptr = array.dataStart;\\n\\n  end   = min<i32>(end, len);\\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\\n  let count = min(last - from, len - to);\\n\\n  memory.copy(\\n    ptr + (<usize>to << alignof<T>()),\\n    ptr + (<usize>from << alignof<T>()),\\n    <usize>count << alignof<T>()\\n  );\\n  return array;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\\n  array: TArray,\\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\\n  initialValue: TRet\\n): TRet {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\\n  }\\n  return initialValue;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\\n  array: TArray,\\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\\n  initialValue: TRet\\n): TRet {\\n  let ptr = array.dataStart;\\n  for (let i = array.length - 1; i >= 0; i--) {\\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\\n  }\\n  return initialValue;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, self: TArray) => T,\\n): TArray {\\n  let len = array.length;\\n  let ptr = array.dataStart;\\n\\n  let byteLength = len << alignof<T>();\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\\n  for (let i = 0; i < len; i++) {\\n    store<T>(\\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\\n    );\\n  }\\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\\\"dataStart\\\"));\\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\\\"byteLength\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, self: TArray) => bool,\\n): TArray {\\n  let len = array.length;\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\\n  let dataStart  = array.dataStart;\\n  let j: usize = 0;\\n  for (let i = 0; i < len; i++) {\\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    if (fn(value, i, array)) {\\n      store<T>(\\n        changetype<usize>(buf) + (j++ << alignof<T>()),\\n        value\\n      );\\n    }\\n  }\\n  // shrink output buffer\\n  let byteLength = j << alignof<T>();\\n  let data = __renew(changetype<usize>(buf), byteLength);\\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), data, false);\\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\\\"byteLength\\\"));\\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\\\"dataStart\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): i32 {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): i32 {\\n  let ptr = array.dataStart;\\n  for (let i = array.length - 1; i >= 0; --i) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  searchElement: T,\\n  fromIndex: i32,\\n): bool {\\n  if (isFloat<T>()) {\\n    let index: isize = fromIndex;\\n    let len: isize = array.length;\\n    if (len == 0 || index >= len) return false;\\n    if (index < 0) index = max(len + index, 0);\\n    let dataStart = array.dataStart;\\n    while (index < len) {\\n      let elem = load<T>(dataStart + (index << alignof<T>()));\\n      // @ts-ignore\\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\\n      ++index;\\n    }\\n    return false;\\n  } else {\\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  searchElement: T,\\n  fromIndex: i32,\\n): i32 {\\n  let index: isize = fromIndex;\\n  let len: isize = array.length;\\n  if (len == 0 || index >= len) return -1;\\n  if (index < 0) index = max(len + index, 0);\\n  let dataStart = array.dataStart;\\n  while (index < len) {\\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\\n    ++index;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  searchElement: T,\\n  fromIndex: i32,\\n): i32 {\\n  let index: isize = fromIndex;\\n  let len: isize = array.length;\\n  if (len == 0) return -1;\\n  if (index < 0) index = len + index; // no need to clamp\\n  else if (index >= len) index = len - 1;\\n  let dataStart = array.dataStart;\\n  while (index >= 0) {\\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\\n    --index;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): bool {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\\n  }\\n  return false;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): bool {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\\n    return false;\\n  }\\n  return true;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => void,\\n): void {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction WRAP<TArray extends ArrayBufferView, T>(\\n  buffer: ArrayBuffer,\\n  byteOffset: i32 = 0,\\n  len: i32 = -1\\n): TArray {\\n  let byteLength: i32;\\n  let bufferByteLength = buffer.byteLength;\\n  const mask: u32 = sizeof<T>() - 1;\\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\\n    throw new RangeError(E_INDEXOUTOFRANGE);\\n  }\\n  if (len < 0) {\\n    if (len == -1) {\\n      if (bufferByteLength & mask) {\\n        throw new RangeError(E_INVALIDLENGTH);\\n      }\\n      byteLength = bufferByteLength - byteOffset;\\n    } else {\\n      throw new RangeError(E_INVALIDLENGTH);\\n    }\\n  } else {\\n    byteLength = len << alignof<T>();\\n    if (byteOffset + byteLength > bufferByteLength) {\\n      throw new RangeError(E_INVALIDLENGTH);\\n    }\\n  }\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\\\"byteLength\\\"));\\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\\\"dataStart\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SET<\\n  TArray extends ArrayLike<number>,\\n  UArray extends ArrayLike<number>\\n>(\\n  target: TArray,\\n  source: UArray,\\n  offset: i32 = 0\\n): void {\\n  // need to assert at compile time that U is not a reference or a function\\n  if (isReference<valueof<UArray>>()) {\\n    ERROR(E_NOTIMPLEMENTED);\\n  }\\n  let sourceLen = source.length;\\n  if (offset < 0 || sourceLen + offset > target.length) {\\n    // offset is out of bounds\\n    throw new RangeError(E_INDEXOUTOFRANGE);\\n  }\\n  // @ts-ignore: dataStart\\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\\n  // @ts-ignore: dataStart\\n  let sourceStart = source.dataStart;\\n  // if the types align and match, use memory.copy() instead of manual loop\\n  if (\\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\\n  ) {\\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\\n  } else {\\n    for (let i = 0; i < sourceLen; i++) {\\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\\n      // if TArray is Uint8ClampedArray, then values must be clamped\\n      if (target instanceof Uint8ClampedArray) {\\n        if (isFloat<valueof<UArray>>()) {\\n          store<valueof<TArray>>(ptr,\\n            isFinite<valueof<UArray>>(value)\\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\\n              : 0\\n          );\\n        } else {\\n          if (!isSigned<valueof<UArray>>()) {\\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\\n          } else if (sizeof<valueof<TArray>>() <= 4) {\\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\\n          } else {\\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\\n          }\\n        }\\n      } else {\\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\\n        } else {\\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\\n        }\\n      }\\n    }\\n  }\\n}\\n\",\n  \"uri\": \"import { encode, decode, URI_UNSAFE, URL_UNSAFE } from \\\"./util/uri\\\";\\n\\nexport function encodeURI(str: string): string {\\n  return changetype<string>(encode(changetype<usize>(str), str.length, URI_UNSAFE));\\n}\\n\\nexport function decodeURI(str: string): string {\\n  return changetype<string>(decode(changetype<usize>(str), str.length, false));\\n}\\n\\nexport function encodeURIComponent(str: string): string {\\n  return changetype<string>(encode(changetype<usize>(str), str.length, URL_UNSAFE));\\n}\\n\\nexport function decodeURIComponent(str: string): string {\\n  return changetype<string>(decode(changetype<usize>(str), str.length, true));\\n}\\n\",\n  \"util/bytes\": \"export function REVERSE<T>(ptr: usize, len: usize): void {\\n  if (len > 1) {\\n    let\\n      i: usize = 0,\\n      tail: usize,\\n      hlen: usize = len >> 1;\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (sizeof<T>() == 1) {\\n        // TODO: Decide later: Does we need this fast path cases?\\n        //\\n        // if (len == 4) {\\n        //   store<u32>(ptr, bswap(load<u32>(ptr)));\\n        //   return;\\n        // }\\n        // if (len == 8) {\\n        //   store<u64>(ptr, bswap(load<u64>(ptr)));\\n        //   return;\\n        // }\\n        tail = len - 8;\\n        while (i + 7 < hlen) {\\n          let front = ptr + i;\\n          let back  = ptr + tail - i;\\n          let temp  = bswap(load<u64>(front));\\n          store<u64>(front, bswap(load<u64>(back)));\\n          store<u64>(back, temp);\\n          i += 8;\\n        }\\n      }\\n\\n      if (sizeof<T>() == 2) {\\n        tail = len - 2;\\n        while (i + 1 < hlen) {\\n          let front = ptr + (i << 1);\\n          let back  = ptr + (tail - i << 1);\\n          let temp  = rotr(load<u32>(back), 16);\\n          store<u32>(back, rotr(load<u32>(front), 16));\\n          store<u32>(front, temp);\\n          i += 2;\\n        }\\n      }\\n    }\\n\\n    tail = len - 1;\\n    while (i < hlen) {\\n      let front = ptr + (i << alignof<T>());\\n      let back  = ptr + (tail - i << alignof<T>());\\n      let temp  = load<T>(front);\\n      store<T>(front, load<T>(back));\\n      store<T>(back, temp);\\n      i++;\\n    }\\n  }\\n}\\n\\nexport function FILL<T>(\\n  ptr: usize,\\n  len: usize,\\n  value: T,\\n  start: isize,\\n  end: isize\\n): void {\\n  start = start < 0 ? max(len + start, 0) : min(start, len);\\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\\n\\n  if (sizeof<T>() == 1) {\\n    if (start < end) {\\n      memory.fill(\\n        ptr + <usize>start,\\n        u8(value),\\n        <usize>(end - start)\\n      );\\n    }\\n  } else {\\n    if (ASC_SHRINK_LEVEL <= 1) {\\n      if (isInteger<T>()) {\\n        // @ts-ignore\\n        if (value == <T>0 | value == <T>-1) {\\n          if (start < end) {\\n            memory.fill(\\n              ptr + (<usize>start << alignof<T>()),\\n              u8(value),\\n              <usize>(end - start) << alignof<T>()\\n            );\\n          }\\n          return;\\n        }\\n      } else if (isFloat<T>()) {\\n        // for floating non-negative zeros we can use fast memory.fill\\n        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||\\n            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {\\n          if (start < end) {\\n            memory.fill(\\n              ptr + (<usize>start << alignof<T>()),\\n              0,\\n              <usize>(end - start) << alignof<T>()\\n            );\\n          }\\n          return;\\n        }\\n      }\\n    }\\n    for (; start < end; ++start) {\\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\\n    }\\n  }\\n}\\n\",\n  \"util/casemap\": \"// Total tables size: ~5 kb (usually compressed to ~4 kb)\\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h\\n\\n// @ts-ignore: decorator\\n@lazy @inline const TAB = memory.data<u8>([\\n  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,\\n  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,\\n  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,\\n  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,\\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,\\n  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,\\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,\\n  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,\\n  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,\\n  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,\\n  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,\\n  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,\\n  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,\\n  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,\\n  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,\\n  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,\\n  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,\\n  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,\\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,\\n  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\\n  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,\\n  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\\n  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,\\n  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\\n  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,\\n  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,\\n  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,\\n  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,\\n  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,\\n  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,\\n  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,\\n  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,\\n  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,\\n  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,\\n  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,\\n  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,\\n  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,\\n  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,\\n  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,\\n  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const RULES = memory.data<i32>([\\n  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,\\n  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,\\n  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,\\n  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,\\n  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,\\n  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,\\n  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,\\n  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,\\n  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,\\n  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,\\n  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,\\n  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,\\n  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,\\n  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,\\n  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,\\n  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,\\n  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,\\n  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,\\n  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,\\n  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,\\n  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,\\n  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,\\n  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,\\n  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,\\n  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,\\n  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,\\n  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,\\n  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,\\n  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,\\n  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,\\n  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,\\n  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,\\n  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,\\n  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,\\n  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,\\n  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,\\n  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,\\n  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,\\n  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,\\n  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const RULE_BASES = memory.data<u8>([\\n  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,\\n  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,\\n  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXCEPTIONS = memory.data<u8>([\\n  48, 12,  49, 13,  120, 14,  127, 15,\\n  128, 16,  129, 17,  134, 18,  137, 19,\\n  138, 19,  142, 20,  143, 21,  144, 22,\\n  147, 19,  148, 23,  149, 24,  150, 25,\\n  151, 26,  154, 27,  156, 25,  157, 28,\\n  158, 29,  159, 30,  166, 31,  169, 31,\\n  174, 31,  177, 32,  178, 32,  183, 33,\\n  191, 34,  197, 35,  200, 35,  203, 35,\\n  221, 36,  242, 35,  246, 37,  247, 38,\\n  32, 45,  58, 46,  61, 47,  62, 48,\\n  63, 49,  64, 49,  67, 50,  68, 51,\\n  69, 52,  80, 53,  81, 54,  82, 55,\\n  83, 56,  84, 57,  89, 58,  91, 59,\\n  92, 60,  97, 61,  99, 62,  101, 63,\\n  102, 64,  104, 65,  105, 66,  106, 64,\\n  107, 67,  108, 68,  111, 66,  113, 69,\\n  114, 70,  117, 71,  125, 72,  130, 73,\\n  135, 74,  137, 75,  138, 76,  139, 76,\\n  140, 77,  146, 78,  157, 79,  158, 80,\\n  69, 87,  123, 29,  124, 29,  125, 29,\\n  127, 88,  134, 89,  136, 90,  137, 90,\\n  138, 90,  140, 91,  142, 92,  143, 92,\\n  172, 93,  173, 94,  174, 94,  175, 94,\\n  194, 95,  204, 96,  205, 97,  206, 97,\\n  207, 98,  208, 99,  209, 100,  213, 101,\\n  214, 102,  215, 103,  240, 104,  241, 105,\\n  242, 106,  243, 107,  244, 108,  245, 109,\\n  249, 110,  253, 45,  254, 45,  255, 45,\\n  80, 105,  81, 105,  82, 105,  83, 105,\\n  84, 105,  85, 105,  86, 105,  87, 105,\\n  88, 105,  89, 105,  90, 105,  91, 105,\\n  92, 105,  93, 105,  94, 105,  95, 105,\\n  130, 0,  131, 0,  132, 0,  133, 0,\\n  134, 0,  135, 0,  136, 0,  137, 0,\\n  192, 117,  207, 118,  128, 137,  129, 138,\\n  130, 139,  133, 140,  134, 141,  112, 157,\\n  113, 157,  118, 158,  119, 158,  120, 159,\\n  121, 159,  122, 160,  123, 160,  124, 161,\\n  125, 161,  179, 162,  186, 163,  187, 163,\\n  188, 164,  190, 165,  195, 162,  204, 164,\\n  218, 166,  219, 166,  229, 106,  234, 167,\\n  235, 167,  236, 110,  243, 162,  248, 168,\\n  249, 168,  250, 169,  251, 169,  252, 164,\\n  38, 176,  42, 177,  43, 178,  78,  179,\\n  132,  8,  98, 186,  99, 187,  100, 188,\\n  101, 189,  102, 190,  109, 191,  110, 192,\\n  111, 193,  112, 194,  126, 195,  127, 195,\\n  125, 207,  141, 208,  148, 209,  171, 210,\\n  172, 211,  173, 212,  176, 213,  177, 214,\\n  178, 215,  196, 216,  197, 217,  198, 218\\n]);\\n\\n/* Special Case Mappings\\n * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt\\n */\\n\\n/*\\n@lazy @inline\\nconst SPECIALS_LOWER: StaticArray<u16> = [\\n  0x0130,  0x0069, 0x0307, 0x0000,\\n];\\n*/\\n\\n// @ts-ignore: decorator\\n@lazy @inlne\\nexport const SPECIALS_UPPER: StaticArray<u16> = [\\n  // String#toUpperCase needs .length\\n  0x00DF,  0x0053, 0x0053, 0x0000,\\n  0x0149,  0x02BC, 0x004E, 0x0000,\\n  0x01F0,  0x004A, 0x030C, 0x0000,\\n  0x0390,  0x0399, 0x0308, 0x0301,\\n  0x03B0,  0x03A5, 0x0308, 0x0301,\\n  0x0587,  0x0535, 0x0552, 0x0000,\\n  0x1E96,  0x0048, 0x0331, 0x0000,\\n  0x1E97,  0x0054, 0x0308, 0x0000,\\n  0x1E98,  0x0057, 0x030A, 0x0000,\\n  0x1E99,  0x0059, 0x030A, 0x0000,\\n  0x1E9A,  0x0041, 0x02BE, 0x0000,\\n  0x1F50,  0x03A5, 0x0313, 0x0000,\\n  0x1F52,  0x03A5, 0x0313, 0x0300,\\n  0x1F54,  0x03A5, 0x0313, 0x0301,\\n  0x1F56,  0x03A5, 0x0313, 0x0342,\\n  0x1F80,  0x1F08, 0x0399, 0x0000,\\n  0x1F81,  0x1F09, 0x0399, 0x0000,\\n  0x1F82,  0x1F0A, 0x0399, 0x0000,\\n  0x1F83,  0x1F0B, 0x0399, 0x0000,\\n  0x1F84,  0x1F0C, 0x0399, 0x0000,\\n  0x1F85,  0x1F0D, 0x0399, 0x0000,\\n  0x1F86,  0x1F0E, 0x0399, 0x0000,\\n  0x1F87,  0x1F0F, 0x0399, 0x0000,\\n  0x1F88,  0x1F08, 0x0399, 0x0000,\\n  0x1F89,  0x1F09, 0x0399, 0x0000,\\n  0x1F8A,  0x1F0A, 0x0399, 0x0000,\\n  0x1F8B,  0x1F0B, 0x0399, 0x0000,\\n  0x1F8C,  0x1F0C, 0x0399, 0x0000,\\n  0x1F8D,  0x1F0D, 0x0399, 0x0000,\\n  0x1F8E,  0x1F0E, 0x0399, 0x0000,\\n  0x1F8F,  0x1F0F, 0x0399, 0x0000,\\n  0x1F90,  0x1F28, 0x0399, 0x0000,\\n  0x1F91,  0x1F29, 0x0399, 0x0000,\\n  0x1F92,  0x1F2A, 0x0399, 0x0000,\\n  0x1F93,  0x1F2B, 0x0399, 0x0000,\\n  0x1F94,  0x1F2C, 0x0399, 0x0000,\\n  0x1F95,  0x1F2D, 0x0399, 0x0000,\\n  0x1F96,  0x1F2E, 0x0399, 0x0000,\\n  0x1F97,  0x1F2F, 0x0399, 0x0000,\\n  0x1F98,  0x1F28, 0x0399, 0x0000,\\n  0x1F99,  0x1F29, 0x0399, 0x0000,\\n  0x1F9A,  0x1F2A, 0x0399, 0x0000,\\n  0x1F9B,  0x1F2B, 0x0399, 0x0000,\\n  0x1F9C,  0x1F2C, 0x0399, 0x0000,\\n  0x1F9D,  0x1F2D, 0x0399, 0x0000,\\n  0x1F9E,  0x1F2E, 0x0399, 0x0000,\\n  0x1F9F,  0x1F2F, 0x0399, 0x0000,\\n  0x1FA0,  0x1F68, 0x0399, 0x0000,\\n  0x1FA1,  0x1F69, 0x0399, 0x0000,\\n  0x1FA2,  0x1F6A, 0x0399, 0x0000,\\n  0x1FA3,  0x1F6B, 0x0399, 0x0000,\\n  0x1FA4,  0x1F6C, 0x0399, 0x0000,\\n  0x1FA5,  0x1F6D, 0x0399, 0x0000,\\n  0x1FA6,  0x1F6E, 0x0399, 0x0000,\\n  0x1FA7,  0x1F6F, 0x0399, 0x0000,\\n  0x1FA8,  0x1F68, 0x0399, 0x0000,\\n  0x1FA9,  0x1F69, 0x0399, 0x0000,\\n  0x1FAA,  0x1F6A, 0x0399, 0x0000,\\n  0x1FAB,  0x1F6B, 0x0399, 0x0000,\\n  0x1FAC,  0x1F6C, 0x0399, 0x0000,\\n  0x1FAD,  0x1F6D, 0x0399, 0x0000,\\n  0x1FAE,  0x1F6E, 0x0399, 0x0000,\\n  0x1FAF,  0x1F6F, 0x0399, 0x0000,\\n  0x1FB2,  0x1FBA, 0x0399, 0x0000,\\n  0x1FB3,  0x0391, 0x0399, 0x0000,\\n  0x1FB4,  0x0386, 0x0399, 0x0000,\\n  0x1FB6,  0x0391, 0x0342, 0x0000,\\n  0x1FB7,  0x0391, 0x0342, 0x0399,\\n  0x1FBC,  0x0391, 0x0399, 0x0000,\\n  0x1FC2,  0x1FCA, 0x0399, 0x0000,\\n  0x1FC3,  0x0397, 0x0399, 0x0000,\\n  0x1FC4,  0x0389, 0x0399, 0x0000,\\n  0x1FC6,  0x0397, 0x0342, 0x0000,\\n  0x1FC7,  0x0397, 0x0342, 0x0399,\\n  0x1FCC,  0x0397, 0x0399, 0x0000,\\n  0x1FD2,  0x0399, 0x0308, 0x0300,\\n  0x1FD3,  0x0399, 0x0308, 0x0301,\\n  0x1FD6,  0x0399, 0x0342, 0x0000,\\n  0x1FD7,  0x0399, 0x0308, 0x0342,\\n  0x1FE2,  0x03A5, 0x0308, 0x0300,\\n  0x1FE3,  0x03A5, 0x0308, 0x0301,\\n  0x1FE4,  0x03A1, 0x0313, 0x0000,\\n  0x1FE6,  0x03A5, 0x0342, 0x0000,\\n  0x1FE7,  0x03A5, 0x0308, 0x0342,\\n  0x1FF2,  0x1FFA, 0x0399, 0x0000,\\n  0x1FF3,  0x03A9, 0x0399, 0x0000,\\n  0x1FF4,  0x038F, 0x0399, 0x0000,\\n  0x1FF6,  0x03A9, 0x0342, 0x0000,\\n  0x1FF7,  0x03A9, 0x0342, 0x0399,\\n  0x1FFC,  0x03A9, 0x0399, 0x0000,\\n  0xFB00,  0x0046, 0x0046, 0x0000,\\n  0xFB01,  0x0046, 0x0049, 0x0000,\\n  0xFB02,  0x0046, 0x004C, 0x0000,\\n  0xFB03,  0x0046, 0x0046, 0x0049,\\n  0xFB04,  0x0046, 0x0046, 0x004C,\\n  0xFB05,  0x0053, 0x0054, 0x0000,\\n  0xFB06,  0x0053, 0x0054, 0x0000,\\n  0xFB13,  0x0544, 0x0546, 0x0000,\\n  0xFB14,  0x0544, 0x0535, 0x0000,\\n  0xFB15,  0x0544, 0x053B, 0x0000,\\n  0xFB16,  0x054E, 0x0546, 0x0000,\\n  0xFB17,  0x0544, 0x053D, 0x0000\\n];\\n\\n// @ts-ignore: decorator\\n@lazy @inline const MT = memory.data<i32>([\\n  2048, 342, 57\\n]);\\n\\n// Special binary search routine for Special Casing Tables\\n// @ts-ignore: decorator\\n@inline\\nexport function bsearch(key: u32, ptr: usize, max: i32): i32 {\\n  let min = 0;\\n  while (min <= max) {\\n    let mid = (min + max) >>> 3 << 2;\\n    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;\\n    if (cmp == 0) return mid; // found\\n    else if (cmp >>> 31) min = mid + 4; // < 0\\n    else max = mid - 4; // > 0\\n  }\\n  return -1; // not found\\n}\\n\\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c\\nexport function casemap(c: u32, dir: i32): i32 {\\n  // if (c >= 0x20000) return c;\\n  let c0 = c as i32;\\n  let b = c >> 8;\\n  c &= 255;\\n\\n  let x = c / 3;\\n  let y = c % 3;\\n\\n  /* lookup entry in two-level base-6 table */\\n  // v = tab[(tab[b] as i32) * 86 + x] as u32;\\n  let v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);\\n  // v = (v * mt[y] >> 11) % 6;\\n  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;\\n  /* use the bit vector out of the tables as an index into\\n   * a block-specific set of rules and decode the rule into\\n   * a type and a case-mapping delta. */\\n  // r = rules[(ruleBases[b] as u32) + v];\\n  let r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));\\n  let rt: u32 = r & 255;\\n  let rd: i32 = r >> 8;\\n  /* rules 0/1 are simple lower/upper case with a delta.\\n   * apply according to desired mapping direction. */\\n  if (rt < 2) return c0 + (rd & -(rt ^ dir));\\n  /* binary search. endpoints of the binary search for\\n   * this block are stored in the rule delta field. */\\n  let xn: u32 = rd & 0xff;\\n  let xb: u32 = rd >>> 8;\\n  while (xn) {\\n    let h = xn >> 1;\\n    // let t = exceptions[(xb + h) * 2 + 0] as u32;\\n    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);\\n    if (t == c) {\\n      // r = rules[exceptions[(xb + h) * 2 + 1]];\\n      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));\\n      rt = r & 255;\\n      rd = r >> 8;\\n      if (rt < 2) return c0 + (rd & -(rt ^ dir));\\n      /* Hard-coded for the four exceptional titlecase */\\n      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);\\n    } else if (t > c) {\\n      xn = h;\\n    } else {\\n      xb += h;\\n      xn -= h;\\n    }\\n  }\\n  return c0;\\n}\\n\",\n  \"util/error\": \"// Common error messages for use across the standard library. Keeping error messages compact\\n// and reusing them where possible ensures minimal static data in binaries.\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_INDEXOUTOFRANGE: string = \\\"Index out of range\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_VALUEOUTOFRANGE: string = \\\"Value out of range\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_INVALIDLENGTH: string = \\\"Invalid length\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_EMPTYARRAY: string = \\\"Array is empty\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_HOLEYARRAY: string = \\\"Element type must be nullable if array is holey\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_NOTIMPLEMENTED: string = \\\"Not implemented\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_KEYNOTFOUND: string = \\\"Key does not exist\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_ALLOCATION_TOO_LARGE: string = \\\"Allocation too large\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_ALREADY_PINNED: string = \\\"Object already pinned\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_NOT_PINNED: string = \\\"Object is not pinned\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_URI_MALFORMED: string = \\\"URI malformed\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_INVALIDDATE: string = \\\"Invalid Date\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_UNPAIRED_SURROGATE: string = \\\"Unpaired surrogate\\\";\\n\",\n  \"util/hash\": \"export function HASH<T>(key: T): u32 {\\n  if (isString<T>()) {\\n    return hashStr(changetype<string>(key));\\n  } else if (isReference<T>()) {\\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\\n  } else if (isFloat<T>()) {\\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\\n  } else {\\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\\n    if (sizeof<T>() == 8) return hash64(u64(key));\\n  }\\n  return unreachable();\\n}\\n\\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\\n\\n// primes\\n// @ts-ignore: decorator\\n@inline const XXH32_P1: u32 = 2654435761;\\n// @ts-ignore: decorator\\n@inline const XXH32_P2: u32 = 2246822519;\\n// @ts-ignore: decorator\\n@inline const XXH32_P3: u32 = 3266489917;\\n// @ts-ignore: decorator\\n@inline const XXH32_P4: u32 = 668265263;\\n// @ts-ignore: decorator\\n@inline const XXH32_P5: u32 = 374761393;\\n// @ts-ignore: decorator\\n@inline const XXH32_SEED: u32 = 0;\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction hash32(key: u32, len: u32 = 4): u32 {\\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\\n  h += key * XXH32_P3;\\n  h  = rotl(h, 17) * XXH32_P4;\\n  h ^= h >> 15;\\n  h *= XXH32_P2;\\n  h ^= h >> 13;\\n  h *= XXH32_P3;\\n  h ^= h >> 16;\\n  return h;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction hash64(key: u64): u32 {\\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\\n  h += <u32>key * XXH32_P3;\\n  h  = rotl(h, 17) * XXH32_P4;\\n  h += <u32>(key >> 32) * XXH32_P3;\\n  h  = rotl(h, 17) * XXH32_P4;\\n  h ^= h >> 15;\\n  h *= XXH32_P2;\\n  h ^= h >> 13;\\n  h *= XXH32_P3;\\n  h ^= h >> 16;\\n  return h;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction mix(h: u32, key: u32): u32 {\\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction hashStr(key: string): u32 {\\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\\n\\n  let h: u32 = key.length << 1;\\n  let len: usize = h;\\n  let pos = changetype<usize>(key);\\n\\n  if (len >= 16) {\\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\\n    let s2 = XXH32_SEED + XXH32_P2;\\n    let s3 = XXH32_SEED;\\n    let s4 = XXH32_SEED - XXH32_P1;\\n\\n    let end = len + pos - 16;\\n    while (pos <= end) {\\n      s1 = mix(s1, load<u32>(pos    ));\\n      s2 = mix(s2, load<u32>(pos,  4));\\n      s3 = mix(s3, load<u32>(pos,  8));\\n      s4 = mix(s4, load<u32>(pos, 12));\\n      pos += 16;\\n    }\\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\\n  } else {\\n    h += XXH32_SEED + XXH32_P5;\\n  }\\n\\n  let end = changetype<usize>(key) + len - 4;\\n  while (pos <= end) {\\n    h += load<u32>(pos) * XXH32_P3;\\n    h = rotl(h, 17) * XXH32_P4;\\n    pos += 4;\\n  }\\n\\n  end = changetype<usize>(key) + len;\\n  while (pos < end) {\\n    h += <u32>load<u8>(pos) * XXH32_P5;\\n    h = rotl(h, 11) * XXH32_P1;\\n    pos++;\\n  }\\n\\n  h ^= h >> 15;\\n  h *= XXH32_P2;\\n  h ^= h >> 13;\\n  h *= XXH32_P3;\\n  h ^= h >> 16;\\n  return h;\\n}\\n\",\n  \"util/math\": \"//\\n// Lookup data for exp2f\\n//\\n\\n// @ts-ignore: decorator\\n@inline const EXP2F_TABLE_BITS = 5;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\\n  // used for computing 2^(k/N) for an int |k| < 150 N as\\n  // double(tab[k%N] + (k << 52-BITS))\\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\\n]);\\n\\n// ULP error: 0.502 (nearest rounding.)\\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\\n// @ts-ignore: decorator\\n@inline\\nexport function exp2f_lut(x: f32): f32 {\\n  const\\n    N      = 1 << EXP2F_TABLE_BITS,\\n    N_MASK = N - 1,\\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\\n    Ox127f = reinterpret<f32>(0x7F000000);\\n\\n  const\\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\\n\\n  let xd = <f64>x;\\n  let ix = reinterpret<u32>(x);\\n  let ux = ix >> 20 & 0x7FF;\\n  if (ux >= 0x430) {\\n    // |x| >= 128 or x is nan.\\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\\n  }\\n\\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\\n  let kd = xd + shift;\\n  let ki = reinterpret<u64>(kd);\\n  let r  = xd - (kd - shift);\\n  let t: u64, y: f64, s: f64;\\n\\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\\n  t += ki << (52 - EXP2F_TABLE_BITS);\\n  s  = reinterpret<f64>(t);\\n  y  = C2 * r + 1;\\n  y += (C0 * r + C1) * (r  * r);\\n  y *= s;\\n\\n  return <f32>y;\\n}\\n\\n// ULP error: 0.502 (nearest rounding.)\\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\\n// @ts-ignore: decorator\\n@inline\\nexport function expf_lut(x: f32): f32 {\\n  const\\n    N        = 1 << EXP2F_TABLE_BITS,\\n    N_MASK   = N - 1,\\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\\n    Ox1p127f = reinterpret<f32>(0x7F000000);\\n\\n  const\\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\\n\\n  let xd = <f64>x;\\n  let ix = reinterpret<u32>(x);\\n  let ux = ix >> 20 & 0x7FF;\\n  if (ux >= 0x42B) {\\n    // |x| >= 88 or x is nan.\\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\\n  }\\n\\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\\n  let z = InvLn2N * xd;\\n\\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\\n  // can be bigger which gives larger approximation error.\\n  let kd = <f64>(z + shift);\\n  let ki = reinterpret<u64>(kd);\\n  let r  = z - (kd - shift);\\n  let s: f64, y: f64, t: u64;\\n\\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\\n  t += ki << (52 - EXP2F_TABLE_BITS);\\n  s  = reinterpret<f64>(t);\\n  z  = C0 * r + C1;\\n  y  = C2 * r + 1;\\n  y += z * (r * r);\\n  y *= s;\\n\\n  return <f32>y;\\n}\\n\\n//\\n// Lookup data for log2f\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOG2F_TABLE_BITS = 4;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\\n]);\\n\\n// ULP error: 0.752 (nearest rounding.)\\n// Relative error: 1.9 * 2^-26 (before rounding.)\\n// @ts-ignore: decorator\\n@inline\\nexport function log2f_lut(x: f32): f32 {\\n  const\\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\\n\\n  let ux = reinterpret<u32>(x);\\n  // Fix sign of zero with downward rounding when x==1.\\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\\n    // x < 0x1p-126 or inf or nan.\\n    if (ux * 2 == 0) return -Infinity;\\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\\n    // x is subnormal, normalize it.\\n    ux = reinterpret<u32>(x * Ox1p23f);\\n    ux -= 23 << 23;\\n  }\\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ux - 0x3F330000;\\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\\n  let top  = tmp & 0xFF800000;\\n  let iz   = ux - top;\\n  let k    = <i32>tmp >> 23;\\n\\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\\n  let z    = <f64>reinterpret<f32>(iz);\\n\\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\\n  let r  = z * invc - 1;\\n  let y0 = logc + <f64>k;\\n\\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\\n  let y  = A1 * r + A2;\\n  let p  = A3 * r + y0;\\n  let r2 = r * r;\\n  y += A0 * r2;\\n  y  = y * r2 + p;\\n\\n  return <f32>y;\\n}\\n\\n//\\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOGF_TABLE_BITS = 4;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\\n]);\\n\\n// ULP error: 0.818 (nearest rounding.)\\n// Relative error: 1.957 * 2^-26 (before rounding.)\\n// @ts-ignore: decorator\\n@inline\\nexport function logf_lut(x: f32): f32 {\\n  const\\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\\n\\n  const\\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\\n\\n  let ux = reinterpret<u32>(x);\\n  // Fix sign of zero with downward rounding when x==1.\\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\\n    // x < 0x1p-126 or inf or nan.\\n    if ((ux << 1) == 0) return -Infinity;\\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\\n    // x is subnormal, normalize it.\\n    ux = reinterpret<u32>(x * Ox1p23f);\\n    ux -= 23 << 23;\\n  }\\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp = ux - 0x3F330000;\\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\\n  let k   = <i32>tmp >> 23;\\n  let iz  = ux - (tmp & 0x1FF << 23);\\n\\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\\n\\n  let z = <f64>reinterpret<f32>(iz);\\n\\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\\n  let r = z * invc - 1;\\n  let y0 = logc + <f64>k * Ln2;\\n\\n  // Pipelined polynomial evaluation to approximate log1p(r).\\n  let r2 = r * r;\\n  let y  = A1 * r + A2;\\n  y += A0 * r2;\\n  y = y * r2 + (y0 + r);\\n\\n  return <f32>y;\\n}\\n\\n//\\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction zeroinfnanf(ux: u32): bool {\\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\\n}\\n\\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\\n// the bit representation of a non-zero finite floating-point value.\\n// @ts-ignore: decorator\\n@inline\\nfunction checkintf(iy: u32): i32 {\\n  let e = iy >> 23 & 0xFF;\\n  if (e < 0x7F     ) return 0;\\n  if (e > 0x7F + 23) return 2;\\n  e = 1 << (0x7F + 23 - e);\\n  if (iy & (e - 1)) return 0;\\n  if (iy &  e     ) return 1;\\n  return 2;\\n}\\n\\n// Subnormal input is normalized so ix has negative biased exponent.\\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\\n// @ts-ignore: decorator\\n@inline\\nfunction log2f_inline(ux: u32): f64 {\\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\\n\\n  const\\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ux - 0x3F330000;\\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\\n  let top  = tmp & 0xFF800000;\\n  let uz   = ux - top;\\n  let k    = <i32>top >> 23;\\n\\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\\n  let z    = <f64>reinterpret<f32>(uz);\\n\\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\\n  let r  = z * invc - 1;\\n  let y0 = logc + <f64>k;\\n\\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\\n  let y = A0 * r + A1;\\n  let p = A2 * r + A3;\\n  let q = A4 * r + y0;\\n\\n  r *= r;\\n  q += p * r;\\n  y  = y * (r * r) + q;\\n\\n  return y;\\n}\\n\\n// The output of log2 and thus the input of exp2 is either scaled by N\\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\\n// in [-1021,1023], sign_bias sets the sign of the result.\\n// @ts-ignore: decorator\\n@inline\\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\\n  const\\n    N      = 1 << EXP2F_TABLE_BITS,\\n    N_MASK = N - 1,\\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\\n\\n  const\\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\\n\\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\\n  let kd = <f64>(xd + shift);\\n  let ki = reinterpret<u64>(kd);\\n  let r  = xd - (kd - shift);\\n  let t: u64, z: f64, y: f64, s: f64;\\n\\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\\n  s  = reinterpret<f64>(t);\\n  z  = C0 * r + C1;\\n  y  = C2 * r + 1;\\n  y += z * (r * r);\\n  y *= s;\\n  return <f32>y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction xflowf(sign: u32, y: f32): f32 {\\n  return select<f32>(-y, y, sign) * y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction oflowf(sign: u32): f32 {\\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction uflowf(sign: u32): f32 {\\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function powf_lut(x: f32, y: f32): f32 {\\n  const\\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\\n    LOWER_LIMIT = -150.0,\\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\\n\\n  let signBias: u32 = 0;\\n  let ix = reinterpret<u32>(x);\\n  let iy = reinterpret<u32>(y);\\n  let ny = 0;\\n\\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\\n    if (ny) {\\n      if ((iy << 1) == 0) return 1.0;\\n      if (ix == 0x3F800000) return NaN; // original: 1.0\\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\\n      return y * y;\\n    }\\n    if (zeroinfnanf(ix)) {\\n      let x2 = x * x;\\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\\n      return <i32>iy < 0 ? 1 / x2 : x2;\\n    }\\n    // x and y are non-zero finite.\\n    if (<i32>ix < 0) {\\n      // Finite x < 0.\\n      let yint = checkintf(iy);\\n      if (yint == 0) return (x - x) / (x - x);\\n      if (yint == 1) signBias = SIGN_BIAS;\\n      ix &= 0x7FFFFFFF;\\n    }\\n    if (ix < 0x00800000) {\\n      // Normalize subnormal x so exponent becomes negative.\\n      ix = reinterpret<u32>(x * Ox1p23f);\\n      ix &= 0x7FFFFFFF;\\n      ix -= 23 << 23;\\n    }\\n  }\\n  let logx = log2f_inline(ix);\\n  let ylogx = y * logx; // cannot overflow, y is single prec.\\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\\n    // |y * log(x)| >= 126\\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\\n  }\\n  return exp2f_inline(ylogx, signBias);\\n}\\n\\n//\\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const EXP_TABLE_BITS = 7;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\\n  0x0000000000000000, 0x3FF0000000000000,\\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\\n]);\\n\\n// Handle cases that may overflow or underflow when computing the result that\\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\\n// scale is in SBITS, however it has a computed exponent that may have\\n// overflown into the sign bit so that needs to be adjusted before using it as\\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\\n// adjustment of scale, positive k here means the result may overflow and\\n// negative k means the result may underflow.\\n// @ts-ignore: decorator\\n@inline\\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\\n  const\\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\\n\\n  let scale: f64;\\n  if (!(ki & 0x80000000)) {\\n    // k > 0, the exponent of scale might have overflowed by <= 460.\\n    sbits -= u64(1009) << 52;\\n    scale = reinterpret<f64>(sbits);\\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\\n  }\\n  // k < 0, need special care in the subnormal range.\\n  sbits += u64(1022) << 52;\\n  // Note: sbits is signed scale.\\n  scale = reinterpret<f64>(sbits);\\n  let y = scale + scale * tmp;\\n  if (abs(y) < 1.0) {\\n    // Round y to the right precision before scaling it into the subnormal\\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\\n    // E is the worst-case ulp error outside the subnormal range.  So this\\n    // is only useful if the goal is better than 1 ulp worst-case error.\\n    let one = copysign(1.0, y);\\n    let lo = scale - y + scale * tmp;\\n    let hi = one + y;\\n    lo = one - hi + y + lo;\\n    y  = (hi + lo) - one;\\n    // Fix the sign of 0.\\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\\n  }\\n  return y * Ox1p_1022;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function exp_lut(x: f64): f64 {\\n  const\\n    N      = 1 << EXP_TABLE_BITS,\\n    N_MASK = N - 1;\\n\\n  const\\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\\n\\n  const\\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\\n\\n  let ux = reinterpret<u64>(x);\\n  let abstop = u32(ux >> 52) & 0x7FF;\\n  if (abstop - 0x3C9 >= 0x03F) {\\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\\n    if (abstop >= 0x409) {\\n      if (ux == 0xFFF0000000000000) return 0;\\n      if (abstop >= 0x7FF) {\\n        return 1.0 + x;\\n      } else {\\n        return select<f64>(0, Infinity, <i64>ux < 0);\\n      }\\n    }\\n    // Large x is special cased below.\\n    abstop = 0;\\n  }\\n\\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\\n  let z = InvLn2N * x;\\n  // #if TOINT_INTRINSICS\\n  // \\tkd = roundtoint(z);\\n  // \\tki = converttoint(z);\\n  // #elif EXP_USE_TOINT_NARROW\\n  // \\t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\\n  // let kd = z + shift;\\n  // let ki = reinterpret<u64>(kd) >> 16;\\n  // let kd = <f64><i32>ki;\\n  // #else\\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\\n  let kd = z + shift;\\n  let ki = reinterpret<u64>(kd);\\n  kd -= shift;\\n  // #endif\\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\\n  // 2^(k/N) ~= scale * (1 + tail).\\n  let idx = usize((ki & N_MASK) << 1);\\n  let top = ki << (52 - EXP_TABLE_BITS);\\n\\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\\n  // This is only a valid scale when -1023*N < k < 1024*N\\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\\n  // Evaluation is optimized assuming superscalar pipelined execution.\\n  let r2 = r * r;\\n  // Without fma the worst case error is 0.25/N ulp larger.\\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\\n  let scale = reinterpret<f64>(sbits);\\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\\n  // is no spurious underflow here even without fma.\\n  return scale + scale * tmp;\\n}\\n\\n//\\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\\n//\\n\\n// Handle cases that may overflow or underflow when computing the result that\\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\\n// scale is in SBITS, however it has a computed exponent that may have\\n// overflown into the sign bit so that needs to be adjusted before using it as\\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\\n// adjustment of scale, positive k here means the result may overflow and\\n// negative k means the result may underflow.\\n// @ts-ignore: decorator\\n@inline\\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\\n  let scale: f64;\\n  if ((ki & 0x80000000) == 0) {\\n    // k > 0, the exponent of scale might have overflowed by 1\\n    sbits -= u64(1) << 52;\\n    scale = reinterpret<f64>(sbits);\\n    return 2 * (scale * tmp + scale);\\n  }\\n  // k < 0, need special care in the subnormal range\\n  sbits += u64(1022) << 52;\\n  scale = reinterpret<f64>(sbits);\\n  let y = scale * tmp + scale;\\n  if (y < 1.0) {\\n    // Round y to the right precision before scaling it into the subnormal\\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\\n    // E is the worst-case ulp error outside the subnormal range. So this\\n    // is only useful if the goal is better than 1 ulp worst-case error.\\n    let hi: f64, lo: f64;\\n    lo = scale - y + scale * tmp;\\n    hi = 1.0 + y;\\n    lo = 1.0 - hi + y + lo;\\n    y = (hi + lo) - 1.0;\\n  }\\n  return y * Ox1p_1022;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function exp2_lut(x: f64): f64 {\\n  const\\n    N      = 1 << EXP_TABLE_BITS,\\n    N_MASK = N - 1,\\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\\n\\n  const\\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\\n\\n  let ux = reinterpret<u64>(x);\\n  let abstop = u32(ux >> 52) & 0x7ff;\\n  if (abstop - 0x3C9 >= 0x03F) {\\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\\n    if (abstop >= 0x409) {\\n      if (ux == 0xFFF0000000000000) return 0;\\n      if (abstop >= 0x7FF) return 1.0 + x;\\n      if (<i64>ux >= 0) return Infinity;\\n      else if (ux >= 0xC090CC0000000000) return 0;\\n    }\\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\\n  }\\n\\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\\n  let kd = x + shift;\\n  let ki = reinterpret<u64>(kd);\\n  kd -= shift; // k/N for int k\\n  let r = x - kd;\\n  // 2^(k/N) ~= scale * (1 + tail)\\n  let idx = usize((ki & N_MASK) << 1);\\n  let top = ki << (52 - EXP_TABLE_BITS);\\n\\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\\n  // This is only a valid scale when -1023*N < k < 1024*N\\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\\n  // Evaluation is optimized assuming superscalar pipelined execution\\n  let r2 = r * r;\\n  // Without fma the worst case error is 0.5/N ulp larger.\\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\\n  let scale = reinterpret<f64>(sbits);\\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\\n  // is no spurious underflow here even without fma.\\n  return scale * tmp + scale;\\n}\\n\\n//\\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOG2_TABLE_BITS = 6;\\n\\n/* Algorithm:\\n\\n  x = 2^k z\\n  log2(x) = k + log2(c) + log2(z/c)\\n  log2(z/c) = poly(z/c - 1)\\n\\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\\ninto the ith one, then table entries are computed as\\n\\n  tab[i].invc = 1/c\\n  tab[i].logc = (double)log2(c)\\n  tab2[i].chi = (double)c\\n  tab2[i].clo = (double)(c - (double)c)\\n\\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\\nfloating point invc candidates around 1/center and selecting one for which\\n\\n  1) the rounding error in 0x1.8p10 + logc is 0,\\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\\n\\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\\n  //     invc       ,        logc\\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\\n  //      chi       ,         clo\\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\\n  0x3FF0200004292367, 0x3C9B7FF365324681,\\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\\n  0x3FF460000D387CB1, 0x3C820837856599A6,\\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\\n  0x3FF4E000043543F3, 0xBC781125ED175329,\\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function log2_lut(x: f64): f64 {\\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\\n\\n  const\\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\\n\\n  const\\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\\n\\n  const\\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\\n\\n  let ix = reinterpret<u64>(x);\\n  if (ix - LO < HI - LO) {\\n    let r = x - 1.0;\\n    // #if __FP_FAST_FMA\\n    //     hi = r * InvLn2hi;\\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\\n    // #else\\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\\n    let rlo = r - rhi;\\n    let hi  = rhi * InvLn2hi;\\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\\n    // #endif\\n    let r2 = r * r; // rounding error: 0x1p-62\\n    let r4 = r2 * r2;\\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\\n    let p = r2 * (B0 + r * B1);\\n    let y = hi + p;\\n    lo += hi - y + p;\\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\\n    return y + lo;\\n  }\\n  let top = u32(ix >> 48);\\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\\n    // x < 0x1p-1022 or inf or nan.\\n    if ((ix << 1) == 0) return -1.0 / (x * x);\\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\\n    // x is subnormal, normalize it.\\n    ix = reinterpret<u64>(x * Ox1p52);\\n    ix -= u64(52) << 52;\\n  }\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ix - 0x3FE6000000000000;\\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\\n  let k    = <i64>tmp >> 52;\\n  let iz   = ix - (tmp & 0xFFF0000000000000);\\n\\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\\n  let z    = reinterpret<f64>(iz);\\n  let kd   = <f64>k;\\n\\n  // log2(x) = log2(z/c) + log2(c) + k.\\n  // r ~= z/c - 1, |r| < 1/(2*N).\\n  // #if __FP_FAST_FMA\\n  // \\t// rounding error: 0x1p-55/N.\\n  // \\tr = __builtin_fma(z, invc, -1.0);\\n  // \\tt1 = r * InvLn2hi;\\n  // \\tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\\n  // #else\\n  // rounding error: 0x1p-55/N + 0x1p-65.\\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\\n\\n  let r   = (z - chi - clo) * invc;\\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\\n  let rlo = r - rhi;\\n  let t1  = rhi * InvLn2hi;\\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\\n  // #endif\\n\\n  // hi + lo = r/ln2 + log2(c) + k\\n  let t3 = kd + logc;\\n  let hi = t3 + t1;\\n  let lo = t3 - hi + t1 + t2;\\n\\n  // log2(r+1) = r/ln2 + r^2*poly(r)\\n  // Evaluation is optimized assuming superscalar pipelined execution\\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\\n  return lo + r2 * p + hi;\\n}\\n\\n//\\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOG_TABLE_BITS = 7;\\n\\n/* Algorithm:\\n\\n  x = 2^k z\\n  log(x) = k ln2 + log(c) + log(z/c)\\n  log(z/c) = poly(z/c - 1)\\n\\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\\ninto the ith one, then table entries are computed as\\n\\n  tab[i].invc = 1/c\\n  tab[i].logc = (double)log(c)\\n  tab2[i].chi = (double)c\\n  tab2[i].clo = (double)(c - (double)c)\\n\\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\\nfloating point invc candidates around 1/center and selecting one for which\\n\\n  1) the rounding error in 0x1.8p9 + logc is 0,\\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\\n\\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\\n  //      invc      ,        logc\\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\\n  0x3FF293726014B530, 0xBFC31B996B490000,\\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\\n  0x3FF008040614B195, 0xBF60040979240000,\\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\\n  //      chi       ,         clo\\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\\n  0x3FE710000E869780, 0x3C7BFF6671097952,\\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\\n  0x3FEA500010971D79, 0x3C88FECADD787930,\\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\\n  0x3FF2B00014556313, 0xBC92808233F21F02,\\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\\n  0x3FF530001605277A, 0xBC96BFCECE233209,\\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function log_lut(x: f64): f64 {\\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\\n\\n  const\\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\\n\\n  const\\n    LO: u64 = 0x3FEE000000000000,\\n    HI: u64 = 0x3FF1090000000000;\\n\\n  const\\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\\n\\n  let ix = reinterpret<u64>(x);\\n  if (ix - LO < HI - LO) {\\n    let r  = x - 1.0;\\n    let r2 = r * r;\\n    let r3 = r2 * r;\\n    let y =\\n      r3 * (B1 + r * B2 + r2 * B3 +\\n      r3 * (B4 + r * B5 + r2 * B6 +\\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\\n    // Worst-case error is around 0.507 ULP\\n    let w   = r * Ox1p27;\\n    let rhi = r + w - w;\\n    let rlo = r - rhi;\\n    w = rhi * rhi * B0; // B[0] == -0.5\\n    let hi = r + w;\\n    let lo = r - hi + w;\\n    lo += B0 * rlo * (rhi + r);\\n    return y + lo + hi;\\n  }\\n  let top = u32(ix >> 48);\\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\\n    // x < 0x1p-1022 or inf or nan\\n    if ((ix << 1) == 0) return -1.0 / (x * x);\\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\\n    // x is subnormal, normalize it\\n    ix = reinterpret<u64>(x * Ox1p52);\\n    ix -= u64(52) << 52;\\n  }\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ix - 0x3FE6000000000000;\\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\\n  let k    = <i64>tmp >> 52;\\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\\n\\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\\n  let z    = reinterpret<f64>(iz);\\n\\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\\n  // r ~= z/c - 1, |r| < 1/(2*N)\\n  // #if __FP_FAST_FMA\\n  // \\t// rounding error: 0x1p-55/N\\n  // \\tr = __builtin_fma(z, invc, -1.0);\\n  // #else\\n  // rounding error: 0x1p-55/N + 0x1p-66\\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\\n  let r = (z - chi - clo) * invc;\\n  // #endif\\n  let kd = <f64>k;\\n\\n  // hi + lo = r + log(c) + k*Ln2\\n  let w  = kd * Ln2hi + logc;\\n  let hi = w + r;\\n  let lo = w - hi + r + kd * Ln2lo;\\n\\n  // log(x) = lo + (log1p(r) - r) + hi\\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\\n  // Worst case error if |y| > 0x1p-5:\\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\\n  // Worst case error if |y| > 0x1p-4:\\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\\n}\\n\\n//\\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const POW_LOG_TABLE_BITS = 7;\\n\\n/* Algorithm:\\n\\n  x = 2^k z\\n  log(x) = k ln2 + log(c) + log(z/c)\\n  log(z/c) = poly(z/c - 1)\\n\\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\\nand z falls into the ith one, then table entries are computed as\\n\\n  tab[i].invc = 1/c\\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\\n  tab[i].logctail = (double)(log(c) - logc)\\n\\nwhere c is chosen near the center of the subinterval such that 1/c has only a\\nfew precision bits so z/c - 1 is exactly representible as double:\\n\\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\\n\\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\\nerror and the interval for z is selected such that near x == 1, where log(x)\\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\\n\\n// @ts-ignore: decorator\\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\\n  //      invc      ,pad,       logc       ,       logctail\\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\\n  0x3FF0000000000000, 0, 0, 0,\\n  0x3FF0000000000000, 0, 0, 0,\\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\\n]);\\n\\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\\n// the bit representation of a non-zero finite floating-point value.\\n// @ts-ignore: decorator\\n@inline\\nfunction checkint(iy: u64): i32 {\\n  let e = iy >> 52 & 0x7FF;\\n  if (e < 0x3FF     ) return 0;\\n  if (e > 0x3FF + 52) return 2;\\n  e = u64(1) << (0x3FF + 52 - e);\\n  if (iy & (e - 1)) return 0;\\n  if (iy &  e     ) return 1;\\n  return 2;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction xflow(sign: u32, y: f64): f64 {\\n  return select(-y, y, sign) * y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction uflow(sign: u32): f64 {\\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction oflow(sign: u32): f64 {\\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\\n}\\n\\n// Returns 1 if input is the bit representation of 0, infinity or nan.\\n// @ts-ignore: decorator\\n@inline\\nfunction zeroinfnan(u: u64): bool {\\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let log_tail: f64 = 0;\\n\\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\\n// additional 15 bits precision. IX is the bit representation of x, but\\n// normalized in the subnormal range using the sign bit for the exponent.\\n// @ts-ignore: decorator\\n@inline\\nfunction log_inline(ix: u64): f64 {\\n  const N = 1 << POW_LOG_TABLE_BITS;\\n  const N_MASK = N - 1;\\n\\n  const\\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFE0000000000000),\\n    A1 = reinterpret<f64>(0xBFE5555555555560),\\n    A2 = reinterpret<f64>(0x3FE0000000000006),\\n    A3 = reinterpret<f64>(0x3FE999999959554E),\\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp = ix - 0x3fE6955500000000;\\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\\n  let k   = <i64>tmp >> 52;\\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\\n  let z   = reinterpret<f64>(iz);\\n  let kd  = <f64>k;\\n\\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\\n\\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\\n  let zlo = z - zhi;\\n  let rhi = zhi * invc - 1.0;\\n  let rlo = zlo * invc;\\n  let r   = rhi + rlo;\\n\\n  // k * Ln2 + log(c) + r.\\n  let t1  = kd * Ln2hi + logc;\\n  let t2  = t1 + r;\\n  let lo1 = kd * Ln2lo + logctail;\\n  let lo2 = t1 - t2 + r;\\n\\n  // Evaluation is optimized assuming superscalar pipelined execution.\\n  let ar  = A0 * r; // A[0] = -0.5\\n  let ar2 = r * ar;\\n  let ar3 = r * ar2;\\n  // k * Ln2 + log(c) + r + A[0] * r * r.\\n  let arhi  = A0  * rhi;\\n  let arhi2 = rhi * arhi;\\n  let hi    = t2  + arhi2;\\n  let lo3   = rlo * (ar + arhi);\\n  let lo4   = t2 - hi + arhi2;\\n\\n  // p = log1p(r) - r - A[0] * r * r.\\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\\n  let y  = hi + lo;\\n  log_tail = hi - y + lo;\\n\\n  return y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\\n\\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\\n// @ts-ignore: decorator\\n@inline\\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\\n  const N      = 1 << EXP_TABLE_BITS;\\n  const N_MASK = N - 1;\\n\\n  const\\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\\n\\n  const\\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\\n\\n  let abstop: u32;\\n  let ki: u64, top: u64, sbits: u64;\\n  let idx: usize;\\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\\n\\n  let ux = reinterpret<u64>(x);\\n  abstop = u32(ux >> 52) & 0x7FF;\\n  if (abstop - 0x3C9 >= 0x03F) {\\n    if (abstop - 0x3C9 >= 0x80000000) {\\n      // Avoid spurious underflow for tiny x.\\n      // Note: 0 is common input.\\n      return select(-1.0, 1.0, sign_bias);\\n    }\\n    if (abstop >= 0x409) { // top12(1024.0)\\n      // Note: inf and nan are already handled.\\n      return <i64>ux < 0\\n        ? uflow(sign_bias)\\n        : oflow(sign_bias);\\n    }\\n    // Large x is special cased below.\\n    abstop = 0;\\n  }\\n\\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\\n  z = InvLn2N * x;\\n\\n  // #if TOINT_INTRINSICS\\n  //   kd = roundtoint(z);\\n  //   ki = converttoint(z);\\n  // #elif EXP_USE_TOINT_NARROW\\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\\n  //   kd = eval_as_double(z + shift);\\n  //   ki = asuint64(kd) >> 16;\\n  //   kd = (double_t)(int32_t)ki;\\n  // #else\\n  // z - kd is in [-1, 1] in non-nearest rounding modes\\n  kd  = z + shift;\\n  ki  = reinterpret<u64>(kd);\\n  kd -= shift;\\n  // #endif\\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\\n  r += xtail;\\n  // 2^(k/N) ~= scale * (1 + tail)\\n  idx = usize((ki & N_MASK) << 1);\\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\\n\\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\\n  // This is only a valid scale when -1023*N < k < 1024*N\\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\\n  // Evaluation is optimized assuming superscalar pipelined execution.\\n  r2 = r * r;\\n  // Without fma the worst case error is 0.25/N ulp larger.\\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\\n  scale = reinterpret<f64>(sbits);\\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\\n  // is no spurious underflow here even without fma.\\n  return scale + scale * tmp;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function pow_lut(x: f64, y: f64): f64 {\\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\\n\\n  let sign_bias: u32 = 0;\\n  let ix = reinterpret<u64>(x);\\n  let iy = reinterpret<u64>(y);\\n  let topx = ix >> 52;\\n  let topy = iy >> 52;\\n\\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\\n    // Special cases: (x < 0x1p-126 or inf or nan) or\\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\\n    if (zeroinfnan(iy)) {\\n      if ((iy << 1) == 0) return 1.0;\\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\\n      return y * y;\\n    }\\n    if (zeroinfnan(ix)) {\\n      let x2 = x * x;\\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\\n      return <i64>iy < 0 ? 1 / x2 : x2;\\n    }\\n    // Here x and y are non-zero finite\\n    if (<i64>ix < 0) {\\n      // Finite x < 0\\n      let yint = checkint(iy);\\n      if (yint == 0) return (x - x) / (x - x);\\n      if (yint == 1) sign_bias = SIGN_BIAS;\\n      ix   &= 0x7FFFFFFFFFFFFFFF;\\n      topx &= 0x7FF;\\n    }\\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\\n      // Note: sign_bias == 0 here because y is not odd.\\n      if (ix == 0x3FF0000000000000) return 1;\\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\\n    }\\n    if (topx == 0) {\\n      // Normalize subnormal x so exponent becomes negative.\\n      ix = reinterpret<u64>(x * Ox1p52);\\n      ix &= 0x7FFFFFFFFFFFFFFF;\\n      ix -= u64(52) << 52;\\n    }\\n  }\\n\\n  let hi = log_inline(ix);\\n  let lo = log_tail;\\n  let ehi: f64, elo: f64;\\n  // #if __FP_FAST_FMA\\n  //   ehi = y * hi;\\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\\n  // #else\\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\\n  let ylo = y - yhi;\\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\\n  let llo = hi - lhi + lo;\\n  ehi = yhi * lhi;\\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\\n  // #endif\\n  return exp_inline(ehi, elo, sign_bias);\\n}\\n\",\n  \"util/memory\": \"export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\\n  let w: u32, x: u32;\\n\\n  // copy 1 byte each until src is aligned to 4 bytes\\n  while (n && (src & 3)) {\\n    store<u8>(dest++, load<u8>(src++));\\n    n--;\\n  }\\n\\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\\n  if ((dest & 3) == 0) {\\n    while (n >= 16) {\\n      store<u32>(dest     , load<u32>(src     ));\\n      store<u32>(dest +  4, load<u32>(src +  4));\\n      store<u32>(dest +  8, load<u32>(src +  8));\\n      store<u32>(dest + 12, load<u32>(src + 12));\\n      src += 16; dest += 16; n -= 16;\\n    }\\n    if (n & 8) {\\n      store<u32>(dest    , load<u32>(src    ));\\n      store<u32>(dest + 4, load<u32>(src + 4));\\n      dest += 8; src += 8;\\n    }\\n    if (n & 4) {\\n      store<u32>(dest, load<u32>(src));\\n      dest += 4; src += 4;\\n    }\\n    if (n & 2) { // drop to 2 bytes each\\n      store<u16>(dest, load<u16>(src));\\n      dest += 2; src += 2;\\n    }\\n    if (n & 1) { // drop to 1 byte\\n      store<u8>(dest++, load<u8>(src++));\\n    }\\n    return;\\n  }\\n\\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\\n  if (n >= 32) {\\n    switch (<u32>dest & 3) {\\n      // known to be != 0\\n      case 1: {\\n        w = load<u32>(src);\\n        store<u8>(dest++, load<u8>(src++));\\n        store<u8>(dest++, load<u8>(src++));\\n        store<u8>(dest++, load<u8>(src++));\\n        n -= 3;\\n        while (n >= 17) {\\n          x = load<u32>(src + 1);\\n          store<u32>(dest, w >> 24 | x << 8);\\n          w = load<u32>(src + 5);\\n          store<u32>(dest + 4, x >> 24 | w << 8);\\n          x = load<u32>(src + 9);\\n          store<u32>(dest + 8, w >> 24 | x << 8);\\n          w = load<u32>(src + 13);\\n          store<u32>(dest + 12, x >> 24 | w << 8);\\n          src += 16; dest += 16; n -= 16;\\n        }\\n        break;\\n      }\\n      case 2: {\\n        w = load<u32>(src);\\n        store<u8>(dest++, load<u8>(src++));\\n        store<u8>(dest++, load<u8>(src++));\\n        n -= 2;\\n        while (n >= 18) {\\n          x = load<u32>(src + 2);\\n          store<u32>(dest, w >> 16 | x << 16);\\n          w = load<u32>(src + 6);\\n          store<u32>(dest + 4, x >> 16 | w << 16);\\n          x = load<u32>(src + 10);\\n          store<u32>(dest + 8, w >> 16 | x << 16);\\n          w = load<u32>(src + 14);\\n          store<u32>(dest + 12, x >> 16 | w << 16);\\n          src += 16; dest += 16; n -= 16;\\n        }\\n        break;\\n      }\\n      case 3: {\\n        w = load<u32>(src);\\n        store<u8>(dest++, load<u8>(src++));\\n        n -= 1;\\n        while (n >= 19) {\\n          x = load<u32>(src + 3);\\n          store<u32>(dest, w >> 8 | x << 24);\\n          w = load<u32>(src + 7);\\n          store<u32>(dest + 4, x >> 8 | w << 24);\\n          x = load<u32>(src + 11);\\n          store<u32>(dest + 8, w >> 8 | x << 24);\\n          w = load<u32>(src + 15);\\n          store<u32>(dest + 12, x >> 8 | w << 24);\\n          src += 16; dest += 16; n -= 16;\\n        }\\n        break;\\n      }\\n    }\\n  }\\n\\n  // copy remaining bytes one by one\\n  if (n & 16) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 8) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 4) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 2) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 1) {\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\\n  if (dest == src) return;\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (src - dest - n <= -(n << 1)) {\\n      memcpy(dest, src, n);\\n      return;\\n    }\\n  }\\n  if (dest < src) {\\n    if (ASC_SHRINK_LEVEL < 2) {\\n      if ((src & 7) == (dest & 7)) {\\n        while (dest & 7) {\\n          if (!n) return;\\n          --n;\\n          store<u8>(dest++, load<u8>(src++));\\n        }\\n        while (n >= 8) {\\n          store<u64>(dest, load<u64>(src));\\n          n    -= 8;\\n          dest += 8;\\n          src  += 8;\\n        }\\n      }\\n    }\\n    while (n) {\\n      store<u8>(dest++, load<u8>(src++));\\n      --n;\\n    }\\n  } else {\\n    if (ASC_SHRINK_LEVEL < 2) {\\n      if ((src & 7) == (dest & 7)) {\\n        while ((dest + n) & 7) {\\n          if (!n) return;\\n          store<u8>(dest + --n, load<u8>(src + n));\\n        }\\n        while (n >= 8) {\\n          n -= 8;\\n          store<u64>(dest + n, load<u64>(src + n));\\n        }\\n      }\\n    }\\n    while (n) {\\n      store<u8>(dest + --n, load<u8>(src + n));\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\\n  if (ASC_SHRINK_LEVEL > 1) {\\n    while (n) {\\n      store<u8>(dest++, c);\\n      --n;\\n    }\\n  } else {\\n    // fill head and tail with minimal branching\\n    if (!n) return;\\n    let dend = dest + n;\\n    store<u8>(dest, c);\\n    store<u8>(dend - 1, c);\\n    if (n <= 2) return;\\n    store<u8>(dest, c, 1);\\n    store<u8>(dest, c, 2);\\n    store<u8>(dend - 2, c);\\n    store<u8>(dend - 3, c);\\n    if (n <= 6) return;\\n    store<u8>(dest, c, 3);\\n    store<u8>(dend - 4, c);\\n    if (n <= 8) return;\\n\\n    // advance pointer to align it at 4-byte boundary\\n    let k: usize = -dest & 3;\\n    dest += k;\\n    n -= k;\\n    n &= -4;\\n\\n    let c32: u32 = <u32>-1 / 255 * c;\\n\\n    // fill head/tail up to 28 bytes each in preparation\\n    dend = dest + n;\\n    store<u32>(dest, c32);\\n    store<u32>(dend - 4, c32);\\n    if (n <= 8) return;\\n    store<u32>(dest, c32, 4);\\n    store<u32>(dest, c32, 8);\\n    store<u32>(dend - 12, c32);\\n    store<u32>(dend - 8, c32);\\n    if (n <= 24) return;\\n    store<u32>(dest, c32, 12);\\n    store<u32>(dest, c32, 16);\\n    store<u32>(dest, c32, 20);\\n    store<u32>(dest, c32, 24);\\n    store<u32>(dend - 28, c32);\\n    store<u32>(dend - 24, c32);\\n    store<u32>(dend - 20, c32);\\n    store<u32>(dend - 16, c32);\\n\\n    // align to a multiple of 8\\n    k = 24 + (dest & 4);\\n    dest += k;\\n    n -= k;\\n\\n    // copy 32 bytes each\\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\\n    while (n >= 32) {\\n      store<u64>(dest, c64);\\n      store<u64>(dest, c64, 8);\\n      store<u64>(dest, c64, 16);\\n      store<u64>(dest, c64, 24);\\n      n -= 32;\\n      dest += 32;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\\n  if (vl == vr) return 0;\\n  if (ASC_SHRINK_LEVEL < 2) {\\n    if ((vl & 7) == (vr & 7)) {\\n      while (vl & 7) {\\n        if (!n) return 0;\\n        let a = <i32>load<u8>(vl);\\n        let b = <i32>load<u8>(vr);\\n        if (a != b) return a - b;\\n        n--; vl++; vr++;\\n      }\\n      while (n >= 8) {\\n        if (load<u64>(vl) != load<u64>(vr)) break;\\n        vl += 8;\\n        vr += 8;\\n        n  -= 8;\\n      }\\n    }\\n  }\\n  while (n--) {\\n    let a = <i32>load<u8>(vl);\\n    let b = <i32>load<u8>(vr);\\n    if (a != b) return a - b;\\n    vl++; vr++;\\n  }\\n  return 0;\\n}\\n\",\n  \"util/number\": \"/// <reference path=\\\"../rt/index.d.ts\\\" />\\n\\nimport { idof } from \\\"../builtins\\\";\\nimport { CharCode } from \\\"./string\\\";\\n\\n// @ts-ignore: decorator\\n@inline\\nexport const MAX_DOUBLE_LENGTH = 28;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const POWERS10 = memory.data<u32>([\\n  1,\\n  10,\\n  100,\\n  1000,\\n  10000,\\n  100000,\\n  1000000,\\n  10000000,\\n  100000000,\\n  1000000000\\n]);\\n\\n/*\\n  Lookup table for pairwise char codes in range [0-99]\\n\\n  \\\"00\\\", \\\"01\\\", \\\"02\\\", \\\"03\\\", \\\"04\\\", \\\"05\\\", \\\"06\\\", \\\"07\\\", \\\"08\\\", \\\"09\\\",\\n  \\\"10\\\", \\\"11\\\", \\\"12\\\", \\\"13\\\", \\\"14\\\", \\\"15\\\", \\\"16\\\", \\\"17\\\", \\\"18\\\", \\\"19\\\",\\n  \\\"20\\\", \\\"21\\\", \\\"22\\\", \\\"23\\\", \\\"24\\\", \\\"25\\\", \\\"26\\\", \\\"27\\\", \\\"28\\\", \\\"29\\\",\\n  \\\"30\\\", \\\"31\\\", \\\"32\\\", \\\"33\\\", \\\"34\\\", \\\"35\\\", \\\"36\\\", \\\"37\\\", \\\"38\\\", \\\"39\\\",\\n  \\\"40\\\", \\\"41\\\", \\\"42\\\", \\\"43\\\", \\\"44\\\", \\\"45\\\", \\\"46\\\", \\\"47\\\", \\\"48\\\", \\\"49\\\",\\n  \\\"50\\\", \\\"51\\\", \\\"52\\\", \\\"53\\\", \\\"54\\\", \\\"55\\\", \\\"56\\\", \\\"57\\\", \\\"58\\\", \\\"59\\\",\\n  \\\"60\\\", \\\"61\\\", \\\"62\\\", \\\"63\\\", \\\"64\\\", \\\"65\\\", \\\"66\\\", \\\"67\\\", \\\"68\\\", \\\"69\\\",\\n  \\\"70\\\", \\\"71\\\", \\\"72\\\", \\\"73\\\", \\\"74\\\", \\\"75\\\", \\\"76\\\", \\\"77\\\", \\\"78\\\", \\\"79\\\",\\n  \\\"80\\\", \\\"81\\\", \\\"82\\\", \\\"83\\\", \\\"84\\\", \\\"85\\\", \\\"86\\\", \\\"87\\\", \\\"88\\\", \\\"89\\\",\\n  \\\"90\\\", \\\"91\\\", \\\"92\\\", \\\"93\\\", \\\"94\\\", \\\"95\\\", \\\"96\\\", \\\"97\\\", \\\"98\\\", \\\"99\\\"\\n*/\\n// @ts-ignore: decorator\\n@lazy @inline const DIGITS = memory.data<u32>([\\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\\n]);\\n\\n// Lookup table for pairwise char codes in range [0x00-0xFF]\\n// @ts-ignore: decorator\\n@lazy @inline const HEX_DIGITS =\\n\\\"000102030405060708090a0b0c0d0e0f\\\\\\n101112131415161718191a1b1c1d1e1f\\\\\\n202122232425262728292a2b2c2d2e2f\\\\\\n303132333435363738393a3b3c3d3e3f\\\\\\n404142434445464748494a4b4c4d4e4f\\\\\\n505152535455565758595a5b5c5d5e5f\\\\\\n606162636465666768696a6b6c6d6e6f\\\\\\n707172737475767778797a7b7c7d7e7f\\\\\\n808182838485868788898a8b8c8d8e8f\\\\\\n909192939495969798999a9b9c9d9e9f\\\\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline const ANY_DIGITS = \\\"0123456789abcdefghijklmnopqrstuvwxyz\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\\n    907,   933,   960,   986,  1013,  1039,  1066\\n/* eslint-enable indent */]);\\n\\n// 1e-348, 1e-340, ..., 1e340\\n// @ts-ignore: decorator\\n@lazy @inline const FRC_POWERS = memory.data<u64>([\\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isPowerOf2<T extends number>(value: T): bool {\\n  return popcnt<T>(value) == 1;\\n}\\n\\n// Count number of decimals for u32 values\\n// In our case input value always non-zero so we can simplify some parts\\nexport function decimalCount32(value: u32): u32 {\\n  if (value < 100000) {\\n    if (value < 100) {\\n      return 1 + u32(value >= 10);\\n    } else {\\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\\n    }\\n  } else {\\n    if (value < 10000000) {\\n      return 6 + u32(value >= 1000000);\\n    } else {\\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\\n    }\\n  }\\n}\\n\\n// Count number of decimals for u64 values\\n// In our case input value always greater than 2^32-1 so we can skip some parts\\nexport function decimalCount64High(value: u64): u32 {\\n  if (value < 1000000000000000) {\\n    if (value < 1000000000000) {\\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\\n    } else {\\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\\n    }\\n  } else {\\n    if (value < 100000000000000000) {\\n      return 16 + u32(value >= 10000000000000000);\\n    } else {\\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\\n    }\\n  }\\n}\\n\\nfunction ulog_base(num: u64, base: i32): u32 {\\n  if (isPowerOf2(base)) {\\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\\n  }\\n  let b64 = u64(base), b = b64, e: u32 = 1;\\n  while (num >= b) {\\n    num /= b;\\n    b *= b;\\n    e <<= 1;\\n  }\\n  while (num >= 1) {\\n    num /= b64;\\n    e++;\\n  }\\n  return e - 1;\\n}\\n\\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\\n  while (num >= 10000) {\\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\\n    let t = num / 10000;\\n    let r = num % 10000;\\n    num = t;\\n\\n    let d1 = r / 100;\\n    let d2 = r % 100;\\n\\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\\n\\n    offset -= 4;\\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\\n  }\\n\\n  if (num >= 100) {\\n    let t  = num / 100;\\n    let d1 = num % 100;\\n    num = t;\\n    offset -= 2;\\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\\n    store<u32>(buffer + (offset << 1), digits);\\n  }\\n\\n  if (num >= 10) {\\n    offset -= 2;\\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\\n    store<u32>(buffer + (offset << 1), digits);\\n  } else {\\n    offset -= 1;\\n    let digit = CharCode._0 + num;\\n    store<u16>(buffer + (offset << 1), digit);\\n  }\\n}\\n\\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\\n  while (num >= 100000000) {\\n    let t = num / 100000000;\\n    let r = <usize>(num - t * 100000000);\\n    num = t;\\n\\n    let b = r / 10000;\\n    let c = r % 10000;\\n\\n    let b1 = b / 100;\\n    let b2 = b % 100;\\n    let c1 = c / 100;\\n    let c2 = c % 100;\\n\\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\\n\\n    offset -= 4;\\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\\n\\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\\n\\n    offset -= 4;\\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\\n  }\\n\\n  utoa32_dec_lut(buffer, <u32>num, offset);\\n}\\n\\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\\n  const lut = changetype<usize>(HEX_DIGITS);\\n  while (offset >= 2) {\\n    offset -= 2;\\n    store<u32>(\\n      buffer + (offset << 1),\\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\\n    );\\n    num >>= 8;\\n  }\\n  if (offset & 1) {\\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\\n  }\\n}\\n\\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\\n  do {\\n    let t = num / 10;\\n    let r = <u32>(num % 10);\\n    num = changetype<T>(t);\\n    offset--;\\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\\n  } while (num);\\n}\\n\\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\\n  do {\\n    let d = num & 0x0F | CharCode._0;\\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\\n    offset--;\\n    store<u16>(buffer + (offset << 1), d);\\n    // @ts-ignore: type\\n    num >>= 4;\\n  } while (num);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_dec_simple<u32>(buffer, num, offset);\\n  } else {\\n    utoa32_dec_lut(buffer, num, offset);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_hex_simple<u32>(buffer, num, offset);\\n  } else {\\n    utoa_hex_lut(buffer, num, offset);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_dec_simple<u64>(buffer, num, offset);\\n  } else {\\n    utoa64_dec_lut(buffer, num, offset);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_hex_simple<u64>(buffer, num, offset);\\n  } else {\\n    utoa_hex_lut(buffer, num, offset);\\n  }\\n}\\n\\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\\n  const lut = changetype<usize>(ANY_DIGITS);\\n  let base = u64(radix);\\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\\n    let shift = u64(ctz(radix) & 7);\\n    let mask = base - 1;\\n    do {\\n      offset--;\\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\\n      num >>= shift;\\n    } while (num);\\n  } else {\\n    do {\\n      offset--;\\n      let q = num / base;\\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\\n      num = q;\\n    } while (num);\\n  }\\n}\\n\\nexport function utoa32(value: u32, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n  let out: String;\\n\\n  if (radix == 10) {\\n    let decimals = decimalCount32(value);\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\\n  } else if (radix == 16) {\\n    let decimals = (31 - clz(value) >> 2) + 1;\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\\n  } else {\\n    let decimals = ulog_base(value, radix);\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\\n  }\\n  return out;\\n}\\n\\nexport function itoa32(value: i32, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n\\n  let sign = (value >>> 31) << 1;\\n  if (sign) value = -value;\\n  let out: String;\\n\\n  if (radix == 10) {\\n    let decimals = decimalCount32(value);\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\\n  } else if (radix == 16) {\\n    let decimals = (31 - clz(value) >> 2) + 1;\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\\n  } else {\\n    let val32 = u32(value);\\n    let decimals = ulog_base(val32, radix);\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\\n  }\\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\\n  return out;\\n}\\n\\nexport function utoa64(value: u64, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n  let out: String;\\n\\n  if (radix == 10) {\\n    if (value <= u32.MAX_VALUE) {\\n      let val32    = <u32>value;\\n      let decimals = decimalCount32(val32);\\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\\n    } else {\\n      let decimals = decimalCount64High(value);\\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\\n    }\\n  } else if (radix == 16) {\\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\\n  } else {\\n    let decimals = ulog_base(value, radix);\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\\n  }\\n  return out;\\n}\\n\\nexport function itoa64(value: i64, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n\\n  let sign = u32(value >>> 63) << 1;\\n  if (sign) value = -value;\\n  let out: String;\\n\\n  if (radix == 10) {\\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\\n      let val32    = <u32>value;\\n      let decimals = decimalCount32(val32);\\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\\n    } else {\\n      let decimals = decimalCount64High(value);\\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\\n    }\\n  } else if (radix == 16) {\\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\\n  } else {\\n    let decimals = ulog_base(value, radix);\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\\n  }\\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let _K: i32 = 0;\\n\\n// // @ts-ignore: decorator\\n// @lazy\\n// let _frc: u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _exp: i32 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _frc_minus: u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _frc_plus:  u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _frc_pow: u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _exp_pow: i32 = 0;\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction umul64f(u: u64, v: u64): u64 {\\n  let u0 = u & 0xFFFFFFFF;\\n  let v0 = v & 0xFFFFFFFF;\\n\\n  let u1 = u >> 32;\\n  let v1 = v >> 32;\\n\\n  let l = u0 * v0;\\n  let t = u1 * v0 + (l >> 32);\\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\\n\\n  w += 0x7FFFFFFF; // rounding\\n\\n  t >>= 32;\\n  w >>= 32;\\n\\n  return u1 * v1 + t + w;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction umul64e(e1: i32, e2: i32): i32 {\\n  return e1 + e2 + 64; // where 64 is significand size\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction normalizedBoundaries(f: u64, e: i32): void {\\n  let frc = (f << 1) + 1;\\n  let exp = e - 1;\\n  let off = <i32>clz<u64>(frc);\\n  frc <<= off;\\n  exp  -= off;\\n\\n  let m = 1 + i32(f == 0x0010000000000000);\\n\\n  _frc_plus  = frc;\\n  _frc_minus = ((f << m) - 1) << e - m - exp;\\n  _exp = exp;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\\n  let lastp = buffer + ((len - 1) << 1);\\n  let digit = load<u16>(lastp);\\n  while (\\n    rest < wp_w &&\\n    delta - rest >= ten_kappa && (\\n      rest + ten_kappa < wp_w ||\\n      wp_w - rest > rest + ten_kappa - wp_w\\n    )\\n  ) {\\n    --digit;\\n    rest += ten_kappa;\\n  }\\n  store<u16>(lastp, digit);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction getCachedPower(minExp: i32): void {\\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\\n  let dk = (-61 - minExp) * c + 347;\\t            // dk must be positive, so can do ceiling in positive\\n  let k = <i32>dk;\\n  k += i32(k != dk); // conversion with ceil\\n\\n  let index = (k >> 3) + 1;\\n  _K = 348 - (index << 3);\\t// decimal exponent no need lookup table\\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\\n\\n  // frexp routine\\n  let uv  = reinterpret<u64>(value);\\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\\n  let sid = uv & 0x000FFFFFFFFFFFFF;\\n  let frc = (u64(exp != 0) << 52) + sid;\\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\\n\\n  normalizedBoundaries(frc, exp);\\n  getCachedPower(_exp);\\n\\n  // normalize\\n  let off = <i32>clz<u64>(frc);\\n  frc <<= off;\\n  exp  -= off;\\n\\n  let frc_pow = _frc_pow;\\n  let exp_pow = _exp_pow;\\n\\n  let w_frc = umul64f(frc, frc_pow);\\n  let w_exp = umul64e(exp, exp_pow);\\n\\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\\n  let wp_exp = umul64e(_exp, exp_pow);\\n\\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\\n  let delta  = wp_frc - wm_frc;\\n\\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\\n}\\n\\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\\n  let one_exp = -mp_exp;\\n  let one_frc = (<u64>1) << one_exp;\\n  let mask    = one_frc - 1;\\n\\n  let wp_w_frc = mp_frc - w_frc;\\n\\n  let p1 = u32(mp_frc >> one_exp);\\n  let p2 = mp_frc & mask;\\n\\n  let kappa = <i32>decimalCount32(p1);\\n  let len = sign;\\n\\n  while (kappa > 0) {\\n    let d: u32;\\n    switch (kappa) {\\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\\n      case  3: { d = p1 /        100; p1 %=        100; break; }\\n      case  2: { d = p1 /         10; p1 %=         10; break; }\\n      case  1: { d = p1;              p1 =           0; break; }\\n      default: { d = 0; break; }\\n    }\\n\\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\\n\\n    --kappa;\\n    let tmp = ((<u64>p1) << one_exp) + p2;\\n    if (tmp <= delta) {\\n      _K += kappa;\\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\\n      return len;\\n    }\\n  }\\n\\n  while (true) {\\n    p2    *= 10;\\n    delta *= 10;\\n\\n    let d = p2 >> one_exp;\\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\\n\\n    p2 &= mask;\\n    --kappa;\\n    if (p2 < delta) {\\n      _K += kappa;\\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\\n      return len;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction genExponent(buffer: usize, k: i32): i32 {\\n  let sign = k < 0;\\n  if (sign) k = -k;\\n  let decimals = decimalCount32(k) + 1;\\n  utoa32_dec_core(buffer, k, decimals);\\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\\n  return decimals;\\n}\\n\\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\\n  if (!k) {\\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\\n    return length + 2;\\n  }\\n\\n  let kk = length + k;\\n  if (length <= kk && kk <= 21) {\\n    // 1234e7 -> 12340000000\\n    for (let i = length; i < kk; ++i) {\\n      store<u16>(buffer + (i << 1), CharCode._0);\\n    }\\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\\n    return kk + 2;\\n  } else if (kk > 0 && kk <= 21) {\\n    // 1234e-2 -> 12.34\\n    let ptr = buffer + (kk << 1);\\n    memory.copy(\\n      ptr + 2,\\n      ptr,\\n      -k << 1\\n    );\\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\\n    return length + 1;\\n  } else if (-6 < kk && kk <= 0) {\\n    // 1234e-6 -> 0.001234\\n    let offset = 2 - kk;\\n    memory.copy(\\n      buffer + (offset << 1),\\n      buffer,\\n      length << 1\\n    );\\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\\n    for (let i = 2; i < offset; ++i) {\\n      store<u16>(buffer + (i << 1), CharCode._0);\\n    }\\n    return length + offset;\\n  } else if (length == 1) {\\n    // 1e30\\n    store<u16>(buffer, CharCode.e, 2);\\n    length = genExponent(buffer + 4, kk - 1);\\n    return length + 2;\\n  } else {\\n    let len = length << 1;\\n    memory.copy(\\n      buffer + 4,\\n      buffer + 2,\\n      len - 2\\n    );\\n    store<u16>(buffer,       CharCode.DOT, 2);\\n    store<u16>(buffer + len, CharCode.e,   2);\\n    length += genExponent(buffer + len + 4, kk - 1);\\n    return length + 2;\\n  }\\n}\\n\\nfunction dtoa_core(buffer: usize, value: f64): i32 {\\n  let sign = i32(value < 0);\\n  if (sign) {\\n    value = -value;\\n    store<u16>(buffer, CharCode.MINUS);\\n  }\\n  // assert(value > 0 && value <= 1.7976931348623157e308);\\n  let len = grisu2(value, buffer, sign);\\n  len = prettify(buffer + (sign << 1), len - sign, _K);\\n  return len + sign;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\\n\\nexport function dtoa(value: f64): String {\\n  if (value == 0) return \\\"0.0\\\";\\n  if (!isFinite(value)) {\\n    if (isNaN(value)) return \\\"NaN\\\";\\n    return select<String>(\\\"-Infinity\\\", \\\"Infinity\\\", value < 0);\\n  }\\n  let size = dtoa_core(dtoa_buf, value) << 1;\\n  let result = changetype<String>(__new(size, idof<String>()));\\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\\n  return result;\\n}\\n\\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\\n  let sign: u32 = 0;\\n  if (isSigned<T>()) {\\n    sign = u32(value < 0);\\n    if (sign) {\\n      if (sizeof<T>() == 1) {\\n        if (value == -0x80) {\\n          // -0x80  ->  -128\\n          store<u64>(buffer,\\n            <u64>CharCode.MINUS |\\n            <u64>(CharCode._0 + 1) << 16 |\\n            <u64>(CharCode._0 + 2) << 32 |\\n            <u64>(CharCode._0 + 8) << 48\\n          );\\n          return 4;\\n        }\\n      }\\n      if (sizeof<T>() == 2) {\\n        if (value == -0x8000) {\\n          // -0x8000  ->  -32768\\n          store<u64>(buffer,\\n            <u64>CharCode.MINUS |\\n            <u64>(CharCode._0 + 3) << 16 |\\n            <u64>(CharCode._0 + 2) << 32 |\\n            <u64>(CharCode._0 + 7) << 48\\n          ); // -327\\n          store<u32>(buffer + 8,\\n            (CharCode._0 + 6) << 0 |\\n            (CharCode._0 + 8) << 16\\n          ); // 68\\n          return 6;\\n        }\\n      }\\n      store<u16>(buffer, CharCode.MINUS);\\n      // @ts-ignore\\n      value = -value;\\n    }\\n  }\\n  let dest = buffer + (sign << 1);\\n  if (ASC_SHRINK_LEVEL <= 1) {\\n    if (isSigned<T>()) {\\n      if (sizeof<T>() <= 4) {\\n        if (<u32>value < 10) {\\n          store<u16>(dest, value | CharCode._0);\\n          return 1 + sign;\\n        }\\n      } else {\\n        if (<u64>value < 10) {\\n          store<u16>(dest, value | CharCode._0);\\n          return 1 + sign;\\n        }\\n      }\\n    } else {\\n      if (value < 10) {\\n        store<u16>(buffer, value | CharCode._0);\\n        return 1;\\n      }\\n    }\\n  }\\n  let decimals: u32 = 0;\\n  if (sizeof<T>() <= 4) {\\n    let val32 = <u32>value;\\n    decimals = decimalCount32(val32);\\n    utoa32_dec_core(dest, val32, decimals);\\n  } else {\\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\\n      let val32 = <u32>value;\\n      decimals = decimalCount32(val32);\\n      utoa32_dec_core(dest, val32, decimals);\\n    } else {\\n      let val64 = <u64>value;\\n      decimals = decimalCount64High(val64);\\n      utoa64_dec_core(dest, val64, decimals);\\n    }\\n  }\\n  return sign + decimals;\\n}\\n\\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\\n  if (value == 0) {\\n    store<u16>(buffer, CharCode._0);\\n    store<u16>(buffer, CharCode.DOT, 2);\\n    store<u16>(buffer, CharCode._0,  4);\\n    return 3;\\n  }\\n  if (!isFinite(value)) {\\n    if (isNaN(value)) {\\n      store<u16>(buffer, CharCode.N);\\n      store<u16>(buffer, CharCode.a, 2);\\n      store<u16>(buffer, CharCode.N, 4);\\n      return 3;\\n    } else {\\n      let sign = value < 0;\\n      if (sign) {\\n        store<u16>(buffer, CharCode.MINUS); // -\\n        buffer += 2;\\n      }\\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\\n      return 8 + u32(sign);\\n    }\\n  }\\n  return dtoa_core(buffer, value);\\n}\\n\",\n  \"util/sort\": \"import { compareImpl } from \\\"./string\\\";\\n\\ntype Comparator<T> = (a: T, b: T) => i32;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EMPTY = u32.MAX_VALUE;\\n// @ts-ignore: decorator\\n@inline const INSERTION_SORT_THRESHOLD = 48;\\n// @ts-ignore: decorator\\n@inline const MIN_RUN_LENGTH = 32;\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction log2u(n: u32): u32 {\\n  return 31 - clz(n);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function COMPARATOR<T>(): Comparator<T> {\\n  if (isInteger<T>()) {\\n    if (isSigned<T>() && sizeof<T>() <= 4) {\\n      return (a, b) => i32(a) - i32(b);\\n    } else {\\n      return (a, b) => i32(a > b) - i32(a < b);\\n    }\\n  } else if (isFloat<T>()) {\\n    if (sizeof<T>() == 4) {\\n      return (a, b) => {\\n        let ia = reinterpret<i32>(f32(a));\\n        let ib = reinterpret<i32>(f32(b));\\n        ia ^= ia >> 31 >>> 1;\\n        ib ^= ib >> 31 >>> 1;\\n        return i32(ia > ib) - i32(ia < ib);\\n      };\\n    } else {\\n      return (a, b) => {\\n        let ia = reinterpret<i64>(f64(a));\\n        let ib = reinterpret<i64>(f64(b));\\n        ia ^= ia >> 63 >>> 1;\\n        ib ^= ib >> 63 >>> 1;\\n        return i32(ia > ib) - i32(ia < ib);\\n      };\\n    }\\n  } else if (isString<T>()) {\\n    return (a, b) => {\\n      if (\\n        changetype<usize>(a) == changetype<usize>(b) ||\\n        changetype<usize>(a) == 0 ||\\n        changetype<usize>(b) == 0\\n      ) return 0;\\n      let alen = changetype<string>(a).length;\\n      let blen = changetype<string>(b).length;\\n      if (!(alen | blen)) return 0;\\n      if (!alen) return -1;\\n      if (!blen) return  1;\\n      let res = compareImpl(\\n        changetype<string>(a), 0,\\n        changetype<string>(b), 0,\\n        <usize>min(alen, blen)\\n      );\\n      return res ? res : alen - blen;\\n    };\\n  } else {\\n    return (a, b) => i32(a > b) - i32(a < b);\\n  }\\n}\\n\\n// Power Sort implementation (stable) from paper \\\"Nearly-Optimal Mergesorts\\\"\\n// https://arxiv.org/pdf/1805.04154.pdf\\n// This method usually outperform TimSort.\\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\\nexport function SORT<T>(\\n  ptr: usize,\\n  len: i32,\\n  comparator: Comparator<T>\\n): void {\\n  if (len <= INSERTION_SORT_THRESHOLD) {\\n    if (len <= 1) return;\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      switch (len) {\\n        case 3: {\\n          let a = load<T>(ptr, 0);\\n          let b = load<T>(ptr, 1 << alignof<T>());\\n          let c = comparator(a, b) > 0;\\n          store<T>(ptr, select<T>(b, a, c), 0);\\n          a = select<T>(a, b, c);\\n          b = load<T>(ptr, 2 << alignof<T>());\\n          c = comparator(a, b) > 0;\\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\\n        }\\n        case 2: {\\n          let a = load<T>(ptr, 0);\\n          let b = load<T>(ptr, 1 << alignof<T>());\\n          let c = comparator(a, b) > 0;\\n          store<T>(ptr, select<T>(b, a, c), 0);\\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\\n          return;\\n        }\\n      }\\n    }\\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\\n    return;\\n  }\\n\\n  let lgPlus2         = log2u(len) + 2;\\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\\n\\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\\n  }\\n\\n  let buffer = __alloc(len << alignof<T>());\\n\\n  let hi   = len - 1;\\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\\n  let lenA = endA + 1;\\n\\n  if (lenA < MIN_RUN_LENGTH) {\\n    endA = min(hi, MIN_RUN_LENGTH - 1);\\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\\n  }\\n\\n  let top: u32 = 0, startA = 0;\\n  while (endA < hi) {\\n    let startB = endA + 1;\\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\\n    let lenB = endB - startB + 1;\\n\\n    if (lenB < MIN_RUN_LENGTH) {\\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\\n    }\\n\\n    let k = nodePower(0, hi, startA, startB, endB);\\n\\n    for (let i = top; i > k; --i) {\\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\\n      if (start != EMPTY) {\\n        mergeRuns<T>(\\n          ptr,\\n          start,\\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\\n          endA,\\n          buffer,\\n          comparator\\n        );\\n        startA = start;\\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\\n      }\\n    }\\n\\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\\n    startA = startB;\\n    endA = endB;\\n    top = k;\\n  }\\n\\n  for (let i = top; i != 0; --i) {\\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\\n    if (start != EMPTY) {\\n      mergeRuns<T>(\\n        ptr,\\n        start,\\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\\n        hi,\\n        buffer,\\n        comparator\\n      );\\n    }\\n  }\\n  // dealloc aux buffers\\n  __free(buffer);\\n  __free(leftRunStartBuf);\\n}\\n\\nfunction insertionSort<T>(\\n  ptr: usize,\\n  left: i32,\\n  right: i32,\\n  presorted: i32,\\n  comparator: Comparator<T>\\n): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    // slightly improved original insertion sort\\n    for (let i = left + presorted; i <= right; ++i) {\\n      let j = i - 1;\\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\\n      while (j >= left) {\\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\\n        if (comparator(a, b) < 0) {\\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\\n        } else break;\\n      }\\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\\n    }\\n  } else {\\n    // even-odd two-way insertion sort which allow increase minRunLen\\n    let range = right - left + 1;\\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\\n    for (; i <= right; i += 2) {\\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\\n      let min = b, max = a;\\n      if (comparator(a, b) <= 0) {\\n        min = a, max = b;\\n      }\\n      let j = i - 1;\\n      while (j >= left) {\\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\\n        if (comparator(a, max) > 0) {\\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\\n        } else break;\\n      }\\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\\n      while (j >= left) {\\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\\n        if (comparator(a, min) > 0) {\\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\\n        } else break;\\n      }\\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\\n    }\\n  }\\n}\\n\\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\\n  let n: u64 = right - left + 1;\\n  let s = startB - (left << 1);\\n  let l = startA + s;\\n  let r = endB   + s + 1;\\n  let a = (<u64>l << 30) / n;\\n  let b = (<u64>r << 30) / n;\\n  return clz(<u32>(a ^ b));\\n}\\n\\nfunction extendRunRight<T>(\\n  ptr: usize,\\n  i: i32,\\n  right: i32,\\n  comparator: Comparator<T>\\n): i32 {\\n  if (i == right) return i;\\n  let j = i;\\n  if (comparator(\\n    load<T>(ptr + (<usize>  j << alignof<T>())),\\n    load<T>(ptr + (<usize>++j << alignof<T>()))\\n  ) > 0) {\\n    while (\\n      j < right &&\\n      (comparator(\\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\\n        load<T>(ptr + (<usize>j << alignof<T>()))\\n      ) >>> 31) // < 0\\n    ) ++j;\\n    // reverse\\n    let k = j;\\n    while (i < k) {\\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\\n    }\\n  } else {\\n    while (\\n      j < right &&\\n      comparator(\\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\\n        load<T>(ptr + (<usize>j << alignof<T>()))\\n      ) >= 0\\n    ) ++j;\\n  }\\n  return j;\\n}\\n\\n// Merges arr[l..m - 1] and arr[m..r]\\nfunction mergeRuns<T>(\\n  ptr: usize,\\n  l: i32,\\n  m: i32,\\n  r: i32,\\n  buffer: usize,\\n  comparator: Comparator<T>\\n): void {\\n  --m;\\n  let i: i32, j: i32, t = r + m;\\n  for (i = m + 1; i > l; --i) {\\n    store<T>(\\n      buffer + (<usize>(i - 1) << alignof<T>()),\\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\\n    );\\n  }\\n  for (j = m; j < r; ++j) {\\n    store<T>(\\n      buffer + (<usize>(t - j) << alignof<T>()),\\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\\n    );\\n  }\\n  for (let k = l; k <= r; ++k) {\\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\\n    if (comparator(a, b) < 0) {\\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\\n      --j;\\n    } else {\\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\\n      ++i;\\n    }\\n  }\\n}\\n\",\n  \"util/string\": \"import {\\n  itoa32,\\n  utoa32,\\n  itoa64,\\n  utoa64,\\n  dtoa,\\n  itoa_buffered,\\n  dtoa_buffered,\\n  MAX_DOUBLE_LENGTH\\n} from \\\"./number\\\";\\n\\nimport {\\n  ipow32\\n} from \\\"../math\\\";\\n\\n// All tables are stored as two staged lookup tables (static tries)\\n// because the full range of Unicode symbols can't be efficiently\\n// represented as-is in memory (see Unicode spec ch 5, p.196):\\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\\n// Tables have been generated using these forked musl tools:\\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\\n\\n// Lookup table to check if a character is alphanumeric or not\\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\\n// size: 3904 bytes\\n// @ts-ignore\\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\\n  16,16,125,16,16,16,\\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\\n  31,254,225,255,\\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\\n  63,\\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,\\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\\n  255,\\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\\n  0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,\\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\\n]);\\n\\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\\n// @ts-ignore: decorator\\n@lazy @inline const CASED = memory.data<u8>([\\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0\\n]);\\n\\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\\n// @ts-ignore: decorator\\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,248\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOWER127 = memory.data<u8>([\\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\\n  64,\\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\\n  91,92,93,94,95,96,\\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\\n  123,124,125,126,127\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const UPPER127 = memory.data<u8>([\\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\\n  64,\\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\\n  91,92,93,94,95,96,\\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\\n  123,124,125,126,127\\n]);\\n\\n// 23 * 8 = 184 bytes\\n// @ts-ignore: decorator\\n@lazy @inline const POWERS10 = memory.data<f64>([\\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\\n  1e20, 1e21, 1e22\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport const enum CharCode {\\n  PERCENT = 0x25,\\n  PLUS = 0x2B,\\n  MINUS = 0x2D,\\n  DOT = 0x2E,\\n  _0 = 0x30,\\n  _1 = 0x31,\\n  _2 = 0x32,\\n  _3 = 0x33,\\n  _4 = 0x34,\\n  _5 = 0x35,\\n  _6 = 0x36,\\n  _7 = 0x37,\\n  _8 = 0x38,\\n  _9 = 0x39,\\n  A = 0x41,\\n  B = 0x42,\\n  E = 0x45,\\n  I = 0x49,\\n  N = 0x4E,\\n  O = 0x4F,\\n  X = 0x58,\\n  Z = 0x5A,\\n  a = 0x61,\\n  b = 0x62,\\n  e = 0x65,\\n  n = 0x6E,\\n  o = 0x6F,\\n  u = 0x75,\\n  x = 0x78,\\n  z = 0x7A\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isAscii(c: u32): bool {\\n  return !(c >> 7);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isLower8(c: u32): bool {\\n  return c - CharCode.a < 26;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isUpper8(c: u32): bool {\\n  return c - CharCode.A < 26;\\n}\\n\\nexport function isSpace(c: u32): bool {\\n  if (c < 0x1680) { // < <LS> (1)\\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\\n  }\\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\\n  switch (c) {\\n    case 0x1680: // <LS> (1)\\n    case 0x2028: // <LS> (2)\\n    case 0x2029: // <PS>\\n    case 0x202F: // <NNS>\\n    case 0x205F: // <MMSP>\\n    case 0x3000: // <IS>\\n    case 0xFEFF: return true; // <ZWNBSP>\\n  }\\n  return false;\\n}\\n\\nexport function isAlpha(c: u32): bool {\\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\\n  if (c < 0x20000) {\\n    // @ts-ignore: cast\\n    return stagedBinaryLookup(ALPHA_TABLE, c);\\n  }\\n  return c < 0x2FFFE;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isCased(c: u32): bool {\\n  // @ts-ignore: cast\\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isCaseIgnorable(c: u32): bool {\\n  // @ts-ignore: cast\\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\\n  const lookaheadLimit = 30; // max lookahead limit\\n  let found = false;\\n  let pos = index;\\n  let minPos = max(0, pos - lookaheadLimit);\\n  while (pos > minPos) {\\n    let c = codePointBefore(buffer, pos);\\n    if (!isCaseIgnorable(c)) {\\n      if (isCased(c)) {\\n        found = true;\\n      } else {\\n        return false;\\n      }\\n    }\\n    pos -= isize(c >= 0x10000) + 1;\\n  }\\n  if (!found) return false;\\n  pos = index + 1;\\n  let maxPos = min(pos + lookaheadLimit, len);\\n  while (pos < maxPos) {\\n    let c = <u32>load<u16>(buffer + (pos << 1));\\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\\n      if ((c1 & 0xFC00) == 0xDC00) {\\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\\n      }\\n    }\\n    if (!isCaseIgnorable(c)) {\\n      return !isCased(c);\\n    }\\n    pos += isize(c >= 0x10000) + 1;\\n  }\\n  return true;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction codePointBefore(buffer: usize, index: isize): i32 {\\n  if (index <= 0) return -1;\\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\\n    if ((c1 & 0xFC00) == 0xD800) {\\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\\n    }\\n  }\\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\\n}\\n\\n// Search routine for two-staged lookup tables\\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\\n}\\n\\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\\n  if (ASC_SHRINK_LEVEL < 2) {\\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\\n      do {\\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\\n        ptr1 += 8;\\n        ptr2 += 8;\\n        len  -= 4;\\n      } while (len >= 4);\\n    }\\n  }\\n  while (len--) {\\n    let a = <i32>load<u16>(ptr1);\\n    let b = <i32>load<u16>(ptr2);\\n    if (a != b) return a - b;\\n    ptr1 += 2;\\n    ptr2 += 2;\\n  }\\n  return 0;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function toLower8(c: u32): u32 {\\n  if (ASC_SHRINK_LEVEL > 0) {\\n    return c | u32(isUpper8(c)) << 5;\\n  } else {\\n    return <u32>load<u8>(LOWER127 + c);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function toUpper8(c: u32): u32 {\\n  if (ASC_SHRINK_LEVEL > 0) {\\n    return c & ~(u32(isLower8(c)) << 5);\\n  } else {\\n    return <u32>load<u8>(UPPER127 + c);\\n  }\\n}\\n\\n/** Parses a string to an integer (usually), using the specified radix. */\\nexport function strtol<T>(str: string, radix: i32 = 0): T {\\n  let len = str.length;\\n  if (!len) {\\n    if (isFloat<T>()) {\\n      // @ts-ignore: cast\\n      return <T>NaN;\\n    } else {\\n      // @ts-ignore: cast\\n      return <T>0;\\n    }\\n  }\\n\\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\\n  let code = <u32>load<u16>(ptr);\\n\\n  // trim white spaces\\n  while (isSpace(code)) {\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  // determine sign\\n  // @ts-ignore\\n  let sign: T = 1;\\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\\n    if (!--len) {\\n      if (isFloat<T>()) {\\n        // @ts-ignore: cast\\n        return <T>NaN;\\n      } else {\\n        // @ts-ignore: cast\\n        return <T>0;\\n      }\\n    }\\n    if (code == CharCode.MINUS) {\\n      // @ts-ignore: type\\n      sign = -1;\\n    }\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n\\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\\n  if (radix) {\\n    if (radix < 2 || radix > 36) {\\n      if (isFloat<T>()) {\\n        // @ts-ignore: cast\\n        return <T>NaN;\\n      } else {\\n        // @ts-ignore: cast\\n        return <T>0;\\n      }\\n    }\\n    // handle case as parseInt(\\\"0xFF\\\", 16) by spec\\n    if (radix == 16) {\\n      if (\\n        len > 2 &&\\n        code == CharCode._0 &&\\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\\n      ) {\\n        ptr += 4; len -= 2;\\n      }\\n    }\\n  } else {\\n    // determine radix by literal prefix\\n    if (code == CharCode._0 && len > 2) {\\n      switch (<u32>load<u16>(ptr, 2) | 32) {\\n        case CharCode.b: {\\n          ptr += 4; len -= 2;\\n          radix = 2;\\n          break;\\n        }\\n        case CharCode.o: {\\n          ptr += 4; len -= 2;\\n          radix = 8;\\n          break;\\n        }\\n        case CharCode.x: {\\n          ptr += 4; len -= 2;\\n          radix = 16;\\n          break;\\n        }\\n      }\\n    }\\n    if (!radix) radix = 10;\\n  }\\n\\n  // calculate value\\n  // @ts-ignore: type\\n  let num: T = 0;\\n  let initial = len - 1;\\n  while (len--) {\\n    code = <u32>load<u16>(ptr);\\n    if (code - CharCode._0 < 10) {\\n      code -= CharCode._0;\\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\\n      code -= CharCode.A - 10;\\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\\n      code -= CharCode.a - 10;\\n    }\\n    if (code >= <u32>radix) {\\n      if (initial == len) {\\n        if (isFloat<T>()) {\\n          // @ts-ignore: cast\\n          return <T>NaN;\\n        } else {\\n          // @ts-ignore: cast\\n          return <T>0;\\n        }\\n      }\\n      break;\\n    }\\n    // @ts-ignore: type\\n    num = num * radix + code;\\n    ptr += 2;\\n  }\\n  // @ts-ignore: type\\n  return sign * num;\\n}\\n\\nexport function strtod(str: string): f64 {\\n  let len = str.length;\\n  if (!len) return NaN;\\n\\n  let ptr  = changetype<usize>(str);\\n  let code = <u32>load<u16>(ptr);\\n\\n  let sign = 1.0;\\n  // skip white spaces\\n  while (len && isSpace(code)) {\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  if (!len) return NaN;\\n\\n  // try parse '-' or '+'\\n  if (code == CharCode.MINUS) {\\n    if (!--len) return NaN;\\n    code = <u32>load<u16>(ptr += 2);\\n    sign = -1;\\n  } else if (code == CharCode.PLUS) {\\n    if (!--len) return NaN;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n\\n  // try parse Infinity\\n  if (len >= 8 && code == CharCode.I) {\\n    if (\\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\\n    ) {\\n      return Infinity * sign;\\n    }\\n    return NaN;\\n  }\\n  // validate next symbol\\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\\n    return NaN;\\n  }\\n  let savedPtr = ptr;\\n  // skip zeros\\n  while (code == CharCode._0) {\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  if (len <= 0) return 0.0 * sign;\\n  const capacity = 19; // int(64 * 0.3010)\\n  let pointed = false;\\n  let consumed = 0;\\n  let position = 0;\\n  let x: u64 = 0;\\n  if (code == CharCode.DOT) {\\n    let noDigits = !(savedPtr - ptr);\\n    ptr += 2; --len;\\n    if (!len && noDigits) return NaN;\\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\\n    if (len <= 0) return 0.0 * sign;\\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\\n  }\\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\\n    if (digit < 10) {\\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\\n      ++consumed;\\n    } else {\\n      position = consumed;\\n      pointed = true;\\n    }\\n    if (!--len) break;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n\\n  if (!pointed) position = consumed;\\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\\n}\\n\\nexport function strtob(str: string): bool {\\n  let size: usize = str.length << 1;\\n  let offset: usize = 0;\\n  if (size > 8) {\\n    // try trim end whitespaces first\\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\\n    if (size > 8) {\\n      // trim start whitespaces\\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\\n      size -= offset;\\n    }\\n  }\\n  if (size != 8) return false;\\n  // \\\"true\\\" represents as \\\\00\\\\e\\\\00\\\\u\\\\00\\\\e\\\\00\\\\t (00 65 00 75 00 72 00 74)\\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\\n}\\n\\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) return select(\\\"true\\\", \\\"false\\\", load<bool>(dataStart));\\n\\n  let sepLen = separator.length;\\n  let valueLen = 5; // max possible length of element len(\\\"false\\\")\\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\\n  let offset = 0;\\n  let value: bool;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<bool>(dataStart + i);\\n    valueLen = 4 + i32(!value);\\n    memory.copy(\\n      changetype<usize>(result) + (<usize>offset << 1),\\n      changetype<usize>(select(\\\"true\\\", \\\"false\\\", value)),\\n      <usize>valueLen << 1\\n    );\\n    offset += valueLen;\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<bool>(dataStart + <usize>lastIndex);\\n  valueLen = 4 + i32(!value);\\n  memory.copy(\\n    changetype<usize>(result) + (<usize>offset << 1),\\n    changetype<usize>(select(\\\"true\\\", \\\"false\\\", value)),\\n    valueLen << 1\\n  );\\n  offset += valueLen;\\n\\n  if (estLen > offset) return result.substring(0, offset);\\n  return result;\\n}\\n\\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) {\\n    let value = load<T>(dataStart);\\n    if (isSigned<T>()) {\\n      if (sizeof<T>() <= 4) {\\n        // @ts-ignore: type\\n        return changetype<string>(itoa32(<i32>value, 10));\\n      } else {\\n        // @ts-ignore: type\\n        return changetype<string>(itoa64(<i32>value, 10));\\n      }\\n    } else {\\n      if (sizeof<T>() <= 4) {\\n        // @ts-ignore: type\\n        return changetype<string>(utoa32(<u32>value, 10));\\n      } else {\\n        // @ts-ignore: type\\n        return changetype<string>(utoa64(<u64>value, 10));\\n      }\\n    }\\n  }\\n\\n  let sepLen = separator.length;\\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\\n  let offset = 0;\\n  let value: T;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    // @ts-ignore: type\\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\\n  // @ts-ignore: type\\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\\n  if (estLen > offset) return result.substring(0, offset);\\n  return result;\\n}\\n\\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) {\\n    return changetype<string>(dtoa(\\n      // @ts-ignore: type\\n      load<T>(dataStart))\\n    );\\n  }\\n\\n  const valueLen = MAX_DOUBLE_LENGTH;\\n  let sepLen = separator.length;\\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\\n  let offset = 0;\\n  let value: T;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    // @ts-ignore: type\\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\\n  // @ts-ignore: type\\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\\n  if (estLen > offset) return result.substring(0, offset);\\n  return result;\\n}\\n\\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) {\\n    // @ts-ignore: type\\n    return load<string>(dataStart) || \\\"\\\";\\n  }\\n  let estLen = 0;\\n  let value: string;\\n  for (let i = 0; i < length; ++i) {\\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\\n    if (changetype<usize>(value) != 0) estLen += value.length;\\n  }\\n  let offset = 0;\\n  let sepLen = separator.length;\\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\\n    if (changetype<usize>(value) != 0) {\\n      let valueLen = value.length;\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(value),\\n        <usize>valueLen << 1\\n      );\\n      offset += valueLen;\\n    }\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\\n  if (changetype<usize>(value) != 0) {\\n    memory.copy(\\n      changetype<usize>(result) + (<usize>offset << 1),\\n      changetype<usize>(value),\\n      <usize>value.length << 1\\n    );\\n  }\\n  return result;\\n}\\n\\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  let value: T;\\n  if (!lastIndex) {\\n    value = load<T>(dataStart);\\n    // @ts-ignore: type\\n    return value != null ? value.toString() : \\\"\\\";\\n  }\\n  let result = \\\"\\\";\\n  let sepLen = separator.length;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    // @ts-ignore: type\\n    if (value != null) result += value.toString();\\n    if (sepLen) result += separator;\\n  }\\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\\n  // @ts-ignore: type\\n  if (value != null) result += value.toString();\\n  return result;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction scientific(significand: u64, exp: i32): f64 {\\n  if (!significand || exp < -342) return 0;\\n  if (exp > 308) return Infinity;\\n  // Try use fast path\\n  // Use fast path for string-to-double conversion if possible\\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\\n  // Simple integer\\n  let significandf = <f64>significand;\\n  if (!exp) return significandf;\\n  if (exp > 22 && exp <= 22 + 15) {\\n    significandf *= pow10(exp - 22);\\n    exp = 22;\\n  }\\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\\n    if (exp > 0) return significandf * pow10(exp);\\n    return significandf / pow10(-exp);\\n  } else if (exp < 0) {\\n    return scaledown(significand, exp);\\n  } else {\\n    return scaleup(significand, exp);\\n  }\\n}\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction scaledown(significand: u64, exp: i32): f64 {\\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\\n\\n  let shift = clz(significand);\\n  significand <<= shift;\\n  shift = exp - shift;\\n\\n  for (; exp <= -14; exp += 14) {\\n    let q = significand / denom;\\n    let r = significand % denom;\\n    let s = clz(q);\\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\\n    shift -= s;\\n  }\\n  let b = <u64>ipow32(5, -exp);\\n  let q = significand / b;\\n  let r = significand % b;\\n  let s = clz(q);\\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\\n  shift -= s;\\n\\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\\n}\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction scaleup(significand: u64, exp: i32): f64 {\\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\\n  let shift = ctz(significand);\\n  significand >>= shift;\\n  shift += exp;\\n\\n  __fixmulShift = shift;\\n  for (; exp >= 13; exp -= 13) {\\n    significand = fixmul(significand, coeff);\\n  }\\n  significand = fixmul(significand, <u32>ipow32(5, exp));\\n  shift = __fixmulShift;\\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\\n}\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction parseExp(ptr: usize, len: i32): i32 {\\n  let sign = 1, magnitude = 0;\\n  let code = <u32>load<u16>(ptr);\\n  // check code is 'e' or 'E'\\n  if ((code | 32) != CharCode.e) return 0;\\n\\n  if (!--len) return 0;\\n  code = <u32>load<u16>(ptr += 2);\\n  if (code == CharCode.MINUS) {\\n    if (!--len) return 0;\\n    code = <u32>load<u16>(ptr += 2);\\n    sign = -1;\\n  } else if (code == CharCode.PLUS) {\\n    if (!--len) return 0;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n  // skip zeros\\n  while (code == CharCode._0) {\\n    if (!--len) return 0;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\\n    if (magnitude >= 3200) return sign * 3200;\\n    magnitude = 10 * magnitude + digit;\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  return sign * magnitude;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let __fixmulShift: u64 = 0;\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction fixmul(a: u64, b: u32): u64 {\\n  let low  = (a & 0xFFFFFFFF) * b;\\n  let high = (a >> 32) * b + (low >> 32);\\n  let overflow = <u32>(high >> 32);\\n  let space = clz(overflow);\\n  let revspace: u64 = 32 - space;\\n  __fixmulShift += revspace;\\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction pow10(n: i32): f64 {\\n  // argument `n` should bounds in [0, 22] range\\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\\n}\\n\",\n  \"util/uri\": \"import { E_URI_MALFORMED } from \\\"./error\\\";\\nimport { CharCode } from \\\"./string\\\";\\n\\n// Truncated lookup boolean table that helps us quickly determine\\n// if a char needs to be escaped for URIs (RFC 2396).\\n// @ts-ignore: decorator\\n@lazy export const URI_UNSAFE = memory.data<u8>([\\n/* skip 32 + 1 always set to '1' head slots\\n  */ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,\\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*\\n  skip 128 + 1 always set to '1' tail slots */\\n]);\\n\\n// Truncated lookup boolean table that helps us quickly determine\\n// if a char needs to be escaped for URLs (RFC 3986).\\n// @ts-ignore: decorator\\n@lazy export const URL_UNSAFE = memory.data<u8>([\\n/* skip 32 + 1 always set to '1' head slots\\n  */ 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,\\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*\\n  skip 128 + 1 always set to '1' tail slots */\\n]);\\n\\n// Truncated lookup boolean table for determine reserved chars: ;/?:@&=+$,#\\n// @ts-ignore: decorator\\n@lazy export const URI_RESERVED = memory.data<u8>([\\n  /*  skip 32 + 3 always set to '0' head slots\\n        */ 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1,\\n  1, /* skip 191 always set to '0' tail slots */\\n]);\\n\\nexport function encode(src: usize, len: usize, table: usize): usize {\\n  if (!len) return src;\\n\\n  let i: usize = 0, offset: usize = 0, outSize = len << 1;\\n  let dst = __new(outSize, idof<String>());\\n\\n  while (i < len) {\\n    let org = i;\\n    let c: u32, c1: u32;\\n    // fast scan a check chars until it valid ASCII\\n    // and safe for copying withoud escaping.\\n    do {\\n      c = <u32>load<u16>(src + (i << 1));\\n      // is it valid ASII and safe?\\n      if (c - 33 < 94) { // 127 - 33\\n        if (load<u8>(table + (c - 33))) break;\\n      } else break;\\n    } while (++i < len);\\n\\n    // if we have some safe range of sequence just copy it without encoding\\n    if (i > org) {\\n      let size = i - org << 1;\\n      if (offset + size > outSize) {\\n        outSize = offset + size;\\n        dst = __renew(dst, outSize);\\n      }\\n      // TODO: should we optimize for short cases like 2 byte size?\\n      memory.copy(\\n        dst + offset,\\n        src + (org << 1),\\n        size\\n      );\\n      offset += size;\\n      // return if we reach end on input string\\n      if (i >= len) break;\\n    }\\n\\n    // decode UTF16 with checking for unpaired surrogates\\n    if (c >= 0xD800) {\\n      if (c >= 0xDC00 && c <= 0xDFFF) {\\n        throw new URIError(E_URI_MALFORMED);\\n      }\\n      if (c <= 0xDBFF) {\\n        if (i >= len) {\\n          throw new URIError(E_URI_MALFORMED);\\n        }\\n        c1 = <u32>load<u16>(src + (++i << 1));\\n        if (c1 < 0xDC00 || c1 > 0xDFFF) {\\n          throw new URIError(E_URI_MALFORMED);\\n        }\\n        c = (((c & 0x3FF) << 10) | (c1 & 0x3FF)) + 0x10000;\\n      }\\n    }\\n\\n    let estSize = offset + (c < 0x80 ? 1 * 6 : 4 * 6);\\n    if (estSize > outSize) {\\n      // doubling estimated size but only for greater than one\\n      // input lenght due to we already estemated it for worst case\\n      outSize = len > 1 ? estSize << 1 : estSize;\\n      dst = __renew(dst, outSize);\\n    }\\n\\n    if (c < 0x80) {\\n      // encode ASCII unsafe code point\\n      storeHex(dst, offset, c);\\n      offset += 6;\\n    } else {\\n      // encode UTF-8 unsafe code point\\n      if (c < 0x800) {\\n        storeHex(dst, offset, (c >> 6) | 0xC0);\\n        offset += 6;\\n      } else {\\n        if (c < 0x10000) {\\n          storeHex(dst, offset, (c >> 12) | 0xE0);\\n          offset += 6;\\n        } else {\\n          storeHex(dst, offset, (c >> 18) | 0xF0);\\n          offset += 6;\\n          storeHex(dst, offset, (c >> 12 & 0x3F) | 0x80);\\n          offset += 6;\\n        }\\n        storeHex(dst, offset, (c >> 6 & 0x3F) | 0x80);\\n        offset += 6;\\n      }\\n      storeHex(dst, offset, (c & 0x3F) | 0x80);\\n      offset += 6;\\n    }\\n    ++i;\\n  }\\n  // shink output string buffer if necessary\\n  if (outSize > offset) {\\n    dst = __renew(dst, offset);\\n  }\\n  return dst;\\n}\\n\\nexport function decode(src: usize, len: usize, component: bool): usize {\\n  if (!len) return src;\\n\\n  let i: usize = 0, offset: usize = 0, ch: u32 = 0;\\n  let dst = __new(len << 1, idof<String>());\\n\\n  while (i < len) {\\n    let org = i;\\n    while (i < len && (ch = load<u16>(src + (i << 1))) != CharCode.PERCENT) i++;\\n\\n    if (i > org) {\\n      let size = i - org << 1;\\n      // TODO: should we optimize for short cases like 2 byte size?\\n      memory.copy(\\n        dst + offset,\\n        src + (org << 1),\\n        size\\n      );\\n      offset += size;\\n      if (i >= len) break;\\n    }\\n\\n    // decode hex\\n    if (\\n      i + 2 >= len ||\\n      ch != CharCode.PERCENT ||\\n      (ch = loadHex(src, i + 1 << 1)) == -1\\n    ) throw new URIError(E_URI_MALFORMED);\\n\\n    i += 3;\\n    if (ch < 0x80) {\\n      if (!component && isReserved(ch)) {\\n        ch = CharCode.PERCENT;\\n        i -= 2;\\n      }\\n    } else {\\n      // decode UTF-8 sequence\\n      let nb = utf8LenFromUpperByte(ch);\\n      // minimal surrogate: 2 => 0x80, 3 => 0x800, 4 => 0x10000, _ => -1\\n      let lo: u32 = 1 << (17 * nb >> 2) - 1;\\n      // mask: 2 => 31, 3 => 15, 4 => 7, _ =>  0\\n      ch &= nb ? (0x80 >> nb) - 1 : 0;\\n\\n      while (--nb != 0) {\\n        let c1: u32;\\n        // decode hex\\n        if (\\n          i + 2 >= len ||\\n          load<u16>(src + (i << 1)) != CharCode.PERCENT ||\\n          (c1 = loadHex(src, i + 1 << 1)) == -1\\n        ) throw new URIError(E_URI_MALFORMED);\\n\\n        i += 3;\\n        if ((c1 & 0xC0) != 0x80) {\\n          ch = 0;\\n          break;\\n        }\\n        ch = (ch << 6) | (c1 & 0x3F);\\n      }\\n\\n      // check if UTF8 code point properly fit into invalid UTF16 encoding\\n      if (ch < lo || lo == -1 || ch > 0x10FFFF || (ch >= 0xD800 && ch < 0xE000)) {\\n        throw new URIError(E_URI_MALFORMED);\\n      }\\n\\n      // encode UTF16\\n      if (ch >= 0x10000) {\\n        ch -= 0x10000;\\n        let lo = ch >> 10 | 0xD800;\\n        let hi = (ch & 0x03FF) | 0xDC00;\\n        store<u32>(dst + offset, lo | (hi << 16));\\n        offset += 4;\\n        continue;\\n      }\\n    }\\n    store<u16>(dst + offset, ch);\\n    offset += 2;\\n  }\\n\\n  assert(offset <= (len << 1));\\n  // shink output string buffer if necessary\\n  if ((len << 1) > offset) {\\n    dst = __renew(dst, offset);\\n  }\\n  return dst;\\n}\\n\\nfunction storeHex(dst: usize, offset: usize, ch: u32): void {\\n  // @ts-ignore: decorator\\n  const HEX_CHARS = memory.data<u8>([\\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\\n    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46\\n  ]);\\n\\n  store<u16>(dst + offset, CharCode.PERCENT, 0); // %\\n  store<u32>(\\n    dst + offset,\\n    <u32>load<u8>(HEX_CHARS + (ch >> 4 & 0x0F)) |\\n    <u32>load<u8>(HEX_CHARS + (ch      & 0x0F)) << 16,\\n    2\\n  ); // XX\\n}\\n\\nfunction loadHex(src: usize, offset: usize): u32 {\\n  let c0 = <u32>load<u16>(src + offset, 0);\\n  let c1 = <u32>load<u16>(src + offset, 2);\\n  return isHex(c0) && isHex(c1)\\n    ? fromHex(c0) << 4 | fromHex(c1)\\n    : -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function fromHex(ch: u32): u32 {\\n  return (ch | 32) % 39 - 9;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function utf8LenFromUpperByte(c0: u32): u32 {\\n  // same as\\n  // if (c0 - 0xC0 <= 0xDF - 0xC0) return 2;\\n  // if (c0 - 0xE0 <= 0xEF - 0xE0) return 3;\\n  // if (c0 - 0xF0 <= 0xF7 - 0xF0) return 4;\\n  // return 0;\\n  return c0 - 0xC0 < 56\\n    ? clz(~(c0 << 24))\\n    : 0;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function isReserved(ch: u32): bool {\\n  return ch - 35 < 30\\n    ? <bool>load<u8>(URI_RESERVED + (ch - 35))\\n    : false;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function isHex(ch: u32): bool {\\n  return (ch - CharCode._0 < 10) || ((ch | 32) - CharCode.a < 6);\\n}\\n\",\n  \"vector\": \"/** Vector abstraction. */\\n@final @unmanaged\\nexport abstract class V128 {\\n}\\n\"\n};\nexport const definitionFiles = {\n  \"assembly\": \"/**\\n * Environment definitions for compiling AssemblyScript to WebAssembly using asc.\\n * @module std/assembly\\n *//***/\\n\\n/// <reference no-default-lib=\\\"true\\\"/>\\n\\n// Types\\n\\n/** An 8-bit signed integer. */\\ndeclare type i8 = number;\\n/** A 16-bit signed integer. */\\ndeclare type i16 = number;\\n/** A 32-bit signed integer. */\\ndeclare type i32 = number;\\n/** A 64-bit signed integer. */\\ndeclare type i64 = number;\\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\\ndeclare type isize = number;\\n/** An 8-bit unsigned integer. */\\ndeclare type u8 = number;\\n/** A 16-bit unsigned integer. */\\ndeclare type u16 = number;\\n/** A 32-bit unsigned integer. */\\ndeclare type u32 = number;\\n/** A 64-bit unsigned integer. */\\ndeclare type u64 = number;\\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\\ndeclare type usize = number;\\n/** A 1-bit unsigned integer. */\\ndeclare type bool = boolean | number;\\n/** A 32-bit float. */\\ndeclare type f32 = number;\\n/** A 64-bit float. */\\ndeclare type f64 = number;\\n/** A 128-bit vector. */\\ndeclare type v128 = object;\\n/** Non-nullable function reference. */\\ndeclare type ref_func = object;\\n/** Canonical nullable function reference. */\\ndeclare type funcref = ref_func | null;\\n/** Non-nullable external reference. */\\ndeclare type ref_extern = object;\\n/** Canonical nullable external reference. */\\ndeclare type externref = ref_extern | null;\\n/** Non-nullable any reference. */\\ndeclare type ref_any = object;\\n/** Canonical nullable any reference. */\\ndeclare type anyref = ref_any | null;\\n/** Non-nullable equatable reference. */\\ndeclare type ref_eq = object;\\n/** Canonical nullable equatable reference. */\\ndeclare type eqref = ref_eq | null;\\n/** Non-nullable struct reference. */\\ndeclare type ref_struct = object;\\n/** Canonical nullable struct reference. */\\ndeclare type structref = ref_struct | null;\\n/** Non-nullable array reference. */\\ndeclare type ref_array = object;\\n/** Canonical nullable array reference. */\\ndeclare type arrayref = ref_array | null;\\n/** Non-nullable 31-bit integer reference. */\\ndeclare type ref_i31 = object;\\n/** Canonical nullable 31-bit integer reference. */\\ndeclare type i31ref = ref_i31 | null;\\n/** Non-nullable string reference. */\\ndeclare type ref_string = object;\\n/** Canonical nullable string reference. */\\ndeclare type stringref = ref_string | null;\\n/** Non-nullable WTF-8 string view. */\\ndeclare type ref_stringview_wtf8 = object;\\n/** Canonical nullable WTF-8 string view. */\\ndeclare type stringview_wtf8 = ref_stringview_wtf8 | null;\\n/** Non-nullable WTF-16 string view. */\\ndeclare type ref_stringview_wtf16 = object;\\n/** Canonical nullable WTF-16 string view. */\\ndeclare type stringview_wtf16 = ref_stringview_wtf16 | null;\\n/** Non-nullable string iterator. */\\ndeclare type ref_stringview_iter = object;\\n/** Canonical nullable string iterator. */\\ndeclare type stringview_iter = ref_stringview_iter | null;\\n\\n// Compiler hints\\n\\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\\ndeclare const ASC_TARGET: i32;\\n/** Runtime type. 0 = Stub, 1 = Minimal, 2 = Incremental. */\\ndeclare const ASC_RUNTIME: i32;\\n/** Provided noAssert option. */\\ndeclare const ASC_NO_ASSERT: bool;\\n/** Provided memoryBase option. */\\ndeclare const ASC_MEMORY_BASE: i32;\\n/** Provided tableBase option. */\\ndeclare const ASC_TABLE_BASE: i32;\\n/** Provided optimizeLevel option. */\\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\\n/** Provided shrinkLevel option. */\\ndeclare const ASC_SHRINK_LEVEL: i32;\\n/** Provided lowMemoryLimit option. */\\ndeclare const ASC_LOW_MEMORY_LIMIT: i32;\\n/** Provided noExportRuntime option. */\\ndeclare const ASC_NO_EXPORT_RUNTIME: i32;\\n/** Whether the sign extension feature is enabled. */\\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\\n/** Whether the mutable globals feature is enabled. */\\ndeclare const ASC_FEATURE_MUTABLE_GLOBALS: bool;\\n/** Whether the non-trapping float-to-int feature is enabled. */\\ndeclare const ASC_FEATURE_NONTRAPPING_F2I: bool;\\n/** Whether the bulk memory feature is enabled. */\\ndeclare const ASC_FEATURE_BULK_MEMORY: bool;\\n/** Whether the SIMD feature is enabled. */\\ndeclare const ASC_FEATURE_SIMD: bool;\\n/** Whether the threads feature is enabled. */\\ndeclare const ASC_FEATURE_THREADS: bool;\\n/** Whether the exception handling feature is enabled. */\\ndeclare const ASC_FEATURE_EXCEPTION_HANDLING: bool;\\n/** Whether the tail calls feature is enabled. */\\ndeclare const ASC_FEATURE_TAIL_CALLS: bool;\\n/** Whether the reference types feature is enabled. */\\ndeclare const ASC_FEATURE_REFERENCE_TYPES: bool;\\n/** Whether the multi value types feature is enabled. */\\ndeclare const ASC_FEATURE_MULTI_VALUE: bool;\\n/** Whether the garbage collection feature is enabled. */\\ndeclare const ASC_FEATURE_GC: bool;\\n/** Whether the memory64 feature is enabled. */\\ndeclare const ASC_FEATURE_MEMORY64: bool;\\n/** Whether the relaxed SIMD feature is enabled. */\\ndeclare const ASC_FEATURE_RELAXED_SIMD: bool;\\n/** Whether the extended const expression feature is enabled. */\\ndeclare const ASC_FEATURE_EXTENDED_CONST: bool;\\n/** Whether the string references feature is enabled. */\\ndeclare const ASC_FEATURE_STRINGREF: bool;\\n/** Major version of the compiler. */\\ndeclare const ASC_VERSION_MAJOR: i32;\\n/** Minor version of the compiler. */\\ndeclare const ASC_VERSION_MINOR: i32;\\n/** Patch version of the compiler. */\\ndeclare const ASC_VERSION_PATCH: i32;\\n\\n// Builtins\\n\\n/** Performs the sign-agnostic reverse bytes **/\\ndeclare function bswap<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;\\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\\ndeclare function clz<T extends i32 | i64>(value: T): T;\\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\\ndeclare function ctz<T extends i32 | i64>(value: T): T;\\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\\ndeclare function popcnt<T extends i32 | i64>(value: T): T;\\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\\ndeclare function rotl<T extends i32 | i64>(value: T, shift: T): T;\\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\\ndeclare function rotr<T extends i32 | i64>(value: T, shift: T): T;\\n/** Computes the absolute value of an integer or float. */\\ndeclare function abs<T extends i32 | i64 | f32 | f64>(value: T): T;\\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function max<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function min<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\\ndeclare function ceil<T extends f32 | f64>(value: T): T;\\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\\ndeclare function copysign<T extends f32 | f64>(x: T, y: T): T;\\n/** Performs the floor operation on a 32-bit or 64-bit float. */\\ndeclare function floor<T extends f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\\ndeclare function nearest<T extends f32 | f64>(value: T): T;\\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\\ndeclare function reinterpret<T extends i32 | i64 | f32 | f64>(value: number): T;\\n/** Selects one of two pre-evaluated values depending on the condition. */\\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\\n/** Calculates the square root of a 32-bit or 64-bit float. */\\ndeclare function sqrt<T extends f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\\ndeclare function trunc<T extends f32 | f64>(value: T): T;\\n/** Computes the sum of two integers or floats. */\\ndeclare function add<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Computes the difference of two integers or floats. */\\ndeclare function sub<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Computes the product of two integers or floats. */\\ndeclare function mul<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Computes the quotient of two integers or floats. */\\ndeclare function div<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Return 1 if two numbers are equal to each other, 0 otherwise. */\\ndeclare function eq<T extends i32 | i64 | f32 | f64>(left: T, right: T): i32;\\n/** Return 0 if two numbers are equal to each other, 1 otherwise. */\\ndeclare function ne<T extends i32 | i64 | f32 | f64>(left: T, right: T): i32;\\n/** Computes the remainder of two integers. */\\ndeclare function rem<T extends i32 | i64>(left: T, right: T): T;\\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\\ndeclare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\\ndeclare function store<T>(ptr: usize, value: T, immOffset?: usize, immAlign?: usize): void;\\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression. */\\ndeclare function unreachable(): never;\\n\\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\\ndeclare const NaN: f32 | f64;\\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\\ndeclare const Infinity: f32 | f64;\\n/** Data end offset. */\\ndeclare const __data_end: usize;\\n/** Stack pointer offset. */\\ndeclare let __stack_pointer: usize;\\n/** Heap base offset. */\\ndeclare const __heap_base: usize;\\n/** Determines the byte size of the specified underlying core type. Compiles to a constant. */\\ndeclare function sizeof<T>(): usize;\\n/** Determines the alignment (log2) of the specified underlying core type. Compiles to a constant. */\\ndeclare function alignof<T>(): usize;\\n/** Determines the end offset of the given class type. Compiles to a constant. */\\ndeclare function offsetof<T>(): usize;\\n/** Determines the offset of the specified field within the given class type. Compiles to a constant. */\\ndeclare function offsetof<T>(fieldName: keyof T | string): usize;\\n/** Determines the offset of the specified field within the given class type. Returns the class type's end offset if field name has been omitted. Compiles to a constant. */\\ndeclare function offsetof<T>(fieldName?: string): usize;\\n/** Determines the name of a given type. */\\ndeclare function nameof<T>(value?: T): string;\\n/** Determines the unique runtime id of a class type. Compiles to a constant. */\\ndeclare function idof<T>(): u32;\\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\\ndeclare function changetype<T>(value: any): T;\\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\\ndeclare function unchecked<T>(value: T): T;\\n/** Emits a `call_indirect` instruction, calling the specified function in the function table by index with the specified arguments. Does result in a runtime error if the arguments do not match the called function. */\\ndeclare function call_indirect<T>(index: u32, ...args: unknown[]): T;\\n/** Instantiates a new instance of `T` using the specified constructor arguments. */\\ndeclare function instantiate<T>(...args: any[]): T;\\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\\ndeclare function isNaN<T extends f32 | f64>(value: T): bool;\\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\\ndeclare function isFinite<T extends f32 | f64>(value: T): bool;\\n/** Tests if the specified type *or* expression is of a boolean type. */\\ndeclare function isBoolean<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression is of an integer type and not a reference. Compiles to a constant. */\\ndeclare function isInteger<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression can represent negative numbers. Compiles to a constant. */\\ndeclare function isSigned<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression is of a float type. Compiles to a constant. */\\ndeclare function isFloat<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression is of a v128 type. Compiles to a constant. */\\ndeclare function isVector<T>(value?: any): value is v128;\\n/** Tests if the specified type *or* expression is of a reference type. Compiles to a constant. */\\ndeclare function isReference<T>(value?: any): value is object | string;\\n/** Tests if the specified type *or* expression can be used as a string. Compiles to a constant. */\\ndeclare function isString<T>(value?: any): value is string | String;\\n/** Tests if the specified type *or* expression can be used as an array. Compiles to a constant. */\\ndeclare function isArray<T>(value?: any): value is Array<any>;\\n/** Tests if the specified type *or* expression can be used as an array like object. Compiles to a constant. */\\ndeclare function isArrayLike<T>(value?: any): value is ArrayLike<any>;\\n/** Tests if the specified type *or* expression is of a function type. Compiles to a constant. */\\ndeclare function isFunction<T>(value?: any): value is (...args: any) => any;\\n/** Tests if the specified type *or* expression is of a nullable reference type. Compiles to a constant. */\\ndeclare function isNullable<T>(value?: any): bool;\\n/** Tests if the specified expression resolves to a defined element. Compiles to a constant. */\\ndeclare function isDefined(expression: any): bool;\\n/** Tests if the specified expression evaluates to a constant value. Compiles to a constant. */\\ndeclare function isConstant(expression: any): bool;\\n/** Tests if the specified type *or* expression is of a managed type. Compiles to a constant. */\\ndeclare function isManaged<T>(value?: any): bool;\\n/** Tests if the specified type is void. Compiles to a constant. */\\ndeclare function isVoid<T>(): bool;\\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\\ndeclare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?\\n/** Parses an integer string to a 64-bit float. */\\ndeclare function parseInt(str: string, radix?: i32): f64;\\n/** Parses a string to a 64-bit float. */\\ndeclare function parseFloat(str: string): f64;\\n/** Returns the 64-bit floating-point remainder of `x/y`. */\\ndeclare function fmod(x: f64, y: f64): f64;\\n/** Returns the 32-bit floating-point remainder of `x/y`. */\\ndeclare function fmodf(x: f32, y: f32): f32;\\n/** Returns the number of parameters in the given function signature type. */\\ndeclare function lengthof<T extends (...args: any[]) => any>(func?: T): i32;\\n/** Encodes a text string as a valid Uniform Resource Identifier (URI). */\\ndeclare function encodeURI(str: string): string;\\n/** Encodes a text string as a valid component of a Uniform Resource Identifier (URI). */\\ndeclare function encodeURIComponent(str: string): string;\\n/** Decodes a Uniform Resource Identifier (URI) previously created by encodeURI. */\\ndeclare function decodeURI(str: string): string;\\n/** Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent. */\\ndeclare function decodeURIComponent(str: string): string;\\n\\n/** Atomic operations. */\\ndeclare namespace atomic {\\n  /** Atomically loads an integer value from memory and returns it. */\\n  export function load<T>(ptr: usize, immOffset?: usize): T;\\n  /** Atomically stores an integer value to memory. */\\n  export function store<T>(ptr: usize, value: T, immOffset?: usize): void;\\n  /** Atomically adds an integer value in memory. */\\n  export function add<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically subtracts an integer value in memory. */\\n  export function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically performs a bitwise AND operation on an integer value in memory. */\\n  export function and<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically performs a bitwise OR operation on an integer value in memory. */\\n  export function or<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically performs a bitwise XOR operation on an integer value in memory. */\\n  export function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically exchanges an integer value in memory. */\\n  export function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically compares and exchanges an integer value in memory if the condition is met. */\\n  export function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\\n  /** Performs a wait operation on an address in memory suspending this agent if the integer condition is met. */\\n  export function wait<T>(ptr: usize, expected: T, timeout?: i64): AtomicWaitResult;\\n  /** Performs a notify operation on an address in memory waking up suspended agents. */\\n  export function notify(ptr: usize, count?: i32): i32;\\n  /** Performs a fence operation, preserving synchronization guarantees of higher level languages. */\\n  export function fence(): void;\\n}\\n\\n/** Describes the result of an atomic wait operation. */\\ndeclare enum AtomicWaitResult {\\n  /** Woken by another agent. */\\n  OK,\\n  /** Loaded value did not match the expected value. */\\n  NOT_EQUAL,\\n  /** Not woken before the timeout expired. */\\n  TIMED_OUT\\n}\\n\\n/** Converts any other numeric value to an 8-bit signed integer. */\\ndeclare function i8(value: any): i8;\\ndeclare namespace i8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i8;\\n  /** Parses a string as an i8. */\\n  export function parse(value: string, radix?: i32): i8;\\n}\\n/** Converts any other numeric value to a 16-bit signed integer. */\\ndeclare function i16(value: any): i16;\\ndeclare namespace i16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i16;\\n  /** Parses a string as an i16. */\\n  export function parse(value: string, radix?: i32): i16;\\n}\\n/** Converts any other numeric value to a 32-bit signed integer. */\\ndeclare function i32(value: any): i32;\\ndeclare namespace i32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i32;\\n  /** Parses a string as an i32. */\\n  export function parse(value: string, radix?: i32): i32;\\n  /** Loads an 8-bit signed integer value from memory and returns it as a 32-bit integer. */\\n  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads a 16-bit signed integer value from memory and returns it as a 32-bit integer. */\\n  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads a 32-bit integer value from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Stores a 32-bit integer value to memory as an 8-bit integer. */\\n  export function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 32-bit integer value to memory as a 16-bit integer. */\\n  export function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 32-bit integer value to memory. */\\n  export function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n  /** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\\n  export function clz(value: i32): i32;\\n  /** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\\n  export function ctz(value: i32): i32;\\n  /** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\\n  export function popcnt(value: i32): i32;\\n  /** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\\n  export function rotl(value: i32, shift: i32): i32;\\n  /** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\\n  export function rotr(value: i32, shift: i32): i32;\\n  /** Reinterprets the bits of the specified 32-bit float as a 32-bit integer. */\\n  export function reinterpret_f32(value: f32): i32;\\n  /** Computes the sum of two 32-bit integers. */\\n  export function add(left: i32, right: i32): i32;\\n  /** Computes the difference of two 32-bit integers. */\\n  export function sub(left: i32, right: i32): i32;\\n  /** Computes the product of two 32-bit integers. */\\n  export function mul(left: i32, right: i32): i32;\\n  /** Computes the signed quotient of two 32-bit integers. */\\n  export function div_s(left: i32, right: i32): i32;\\n  /** Computes the unsigned quotient of two 32-bit integers. */\\n  export function div_u(left: i32, right: i32): i32;\\n  /** Return 1 if two 32-bit integers are equal to each other, 0 otherwise. */\\n  export function eq(left: i32, right: i32): i32;\\n  /** Return 0 if two 32-bit integers are equal to each other, 1 otherwise. */\\n  export function ne(left: i32, right: i32): i32;\\n  /** Computes the signed remainder of two 32-bit integers. */\\n  export function rem_s(left: i32, right: i32): i32;\\n  /** Computes the unsigned remainder of two 32-bit integers. */\\n  export function rem_u(left: u32, right: u32): u32;\\n\\n  /** Atomic 32-bit integer operations. */\\n  export namespace atomic {\\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n    export function load8_u(ptr: usize, immOffset?: usize): i32;\\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n    export function load16_u(ptr: usize, immOffset?: usize): i32;\\n    /** Atomically loads a 32-bit integer value from memory and returns it. */\\n    export function load(ptr: usize, immOffset?: usize): i32;\\n    /** Atomically stores a 32-bit integer value to memory as an 8-bit integer. */\\n    export function store8(ptr: usize, value: i32, immOffset?: usize): void;\\n    /** Atomically stores a 32-bit integer value to memory as a 16-bit integer. */\\n    export function store16(ptr: usize, value: i32, immOffset?: usize): void;\\n    /** Atomically stores a 32-bit integer value to memory. */\\n    export function store(ptr: usize, value: i32, immOffset?: usize): void;\\n    /** Atomic 32-bit integer read-modify-write operations on 8-bit values. */\\n    export namespace rmw8 {\\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise AND operation an 8-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise OR operation an 8-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise XOR operation an 8-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n    /** Atomic 32-bit integer read-modify-write operations on 16-bit values. */\\n    export namespace rmw16 {\\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise AND operation a 16-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise OR operation a 16-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise XOR operation a 16-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n    /** Atomic 32-bit integer read-modify-write operations. */\\n    export namespace rmw {\\n      /** Atomically adds a 32-bit integer value in memory. */\\n      export function add(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically subtracts a 32-bit integer value in memory. */\\n      export function sub(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise AND operation a 32-bit integer value in memory. */\\n      export function and(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise OR operation a 32-bit integer value in memory. */\\n      export function or(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise XOR operation a 32-bit integer value in memory. */\\n      export function xor(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically exchanges a 32-bit integer value in memory. */\\n      export function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically compares and exchanges a 32-bit integer value in memory if the condition is met. */\\n      export function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n  }\\n}\\n/** Converts any other numeric value to a 64-bit signed integer. */\\ndeclare function i64(value: any): i64;\\ndeclare namespace i64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i64;\\n  /** Parses a string as an i64. */\\n  export function parse(value: string, radix?: i32): i64;\\n  /** Loads an 8-bit signed integer value from memory and returns it as a 64-bit integer. */\\n  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 16-bit signed integer value from memory and returns it as a 64-bit integer. */\\n  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 32-bit signed integer value from memory and returns it as a 64-bit integer. */\\n  export function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n  export function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 64-bit unsigned integer value from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Stores a 64-bit integer value to memory as an 8-bit integer. */\\n  export function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 64-bit integer value to memory as a 16-bit integer. */\\n  export function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 64-bit integer value to memory as a 32-bit integer. */\\n  export function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 64-bit integer value to memory. */\\n  export function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Performs the sign-agnostic count leading zero bits operation on a 64-bit integer. All zero bits are considered leading if the value is zero. */\\n  export function clz(value: i64): i64;\\n  /** Performs the sign-agnostic count tailing zero bits operation on a 64-bit integer. All zero bits are considered trailing if the value is zero. */\\n  export function ctz(value: i64): i64;\\n  /** Performs the sign-agnostic count number of one bits operation on a 64-bit integer. */\\n  export function popcnt(value: i64): i64;\\n  /** Performs the sign-agnostic rotate left operation on a 64-bit integer. */\\n  export function rotl(value: i64, shift: i64): i64;\\n  /** Performs the sign-agnostic rotate right operation on a 64-bit integer. */\\n  export function rotr(value: i64, shift: i64): i64;\\n  /** Reinterprets the bits of the specified 64-bit float as a 64-bit integer. */\\n  export function reinterpret_f64(value: f64): i64;\\n  /** Computes the sum of two 64-bit integers. */\\n  export function add(left: i64, right: i64): i64;\\n  /** Computes the difference of two 64-bit integers. */\\n  export function sub(left: i64, right: i64): i64;\\n  /** Computes the product of two 64-bit integers. */\\n  export function mul(left: i64, right: i64): i64;\\n  /** Computes the signed quotient of two 64-bit integers. */\\n  export function div_s(left: i64, right: i64): i64;\\n  /** Computes the unsigned quotient of two 64-bit integers. */\\n  export function div_u(left: i64, right: i64): i64;\\n  /** Return 1 if two 64-bit integers are equal to each other, 0 otherwise. */\\n  export function eq(left: i64, right: i64): i32;\\n  /** Return 0 if two 64-bit integers are equal to each other, 1 otherwise. */\\n  export function ne(left: i64, right: i64): i32;\\n  /** Computes the signed remainder of two 64-bit integers. */\\n  export function rem_s(left: i64, right: i64): i64;\\n  /** Computes the unsigned remainder of two 64-bit integers. */\\n  export function rem_u(left: u64, right: u64): u64;\\n\\n  /** Atomic 64-bit integer operations. */\\n  export namespace atomic {\\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n    export function load8_u(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n    export function load16_u(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n    export function load32_u(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically loads a 64-bit integer value from memory and returns it. */\\n    export function load(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically stores a 64-bit integer value to memory as an 8-bit integer. */\\n    export function store8(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Atomically stores a 64-bit integer value to memory as a 16-bit integer. */\\n    export function store16(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Atomically stores a 64-bit integer value to memory as a 32-bit integer. */\\n    export function store32(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Atomically stores a 64-bit integer value to memory. */\\n    export function store(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Atomic 64-bit integer read-modify-write operations on 8-bit values. */\\n    export namespace rmw8 {\\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on an 8-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on an 8-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on an 8-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n    /** Atomic 64-bit integer read-modify-write operations on 16-bit values. */\\n    export namespace rmw16 {\\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts a 16-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on a 16-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on a 16-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on a 16-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n    /** Atomic 64-bit integer read-modify-write operations on 32-bit values. */\\n    export namespace rmw32 {\\n      /** Atomically adds a 32-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts a 32-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on a 32-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on a 32-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on a 32-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges a 32-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges a 32-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n    /** Atomic 64-bit integer read-modify-write operations. */\\n    export namespace rmw {\\n      /** Atomically adds a 64-bit integer value in memory. */\\n      export function add(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts a 64-bit integer value in memory. */\\n      export function sub(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on a 64-bit integer value in memory. */\\n      export function and(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on a 64-bit integer value in memory. */\\n      export function or(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on a 64-bit integer value in memory. */\\n      export function xor(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges a 64-bit integer value in memory. */\\n      export function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges a 64-bit integer value in memory if the condition is met. */\\n      export function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n  }\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\\ndeclare let isize: typeof i32 | typeof i64;\\n/** Converts any other numeric value to an 8-bit unsigned integer. */\\ndeclare function u8(value: any): u8;\\ndeclare namespace u8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u8;\\n  /** Parses a string as an u8. */\\n  export function parse(value: string, radix?: i32): u8;\\n}\\n/** Converts any other numeric value to a 16-bit unsigned integer. */\\ndeclare function u16(value: any): u16;\\ndeclare namespace u16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u16;\\n  /** Parses a string as an u16. */\\n  export function parse(value: string, radix?: i32): u16;\\n}\\n/** Converts any other numeric value to a 32-bit unsigned integer. */\\ndeclare function u32(value: any): u32;\\ndeclare namespace u32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u32;\\n  /** Parses a string as an u32. */\\n  export function parse(value: string, radix?: i32): u32;\\n}\\n/** Converts any other numeric value to a 64-bit unsigned integer. */\\ndeclare function u64(value: any): u64;\\ndeclare namespace u64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u64;\\n  /** Parses a string as an u64. */\\n  export function parse(value: string, radix?: i32): u64;\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\\ndeclare let usize: typeof u32 | typeof u64;\\n/** Converts any other numeric value to a 1-bit unsigned integer. */\\ndeclare function bool(value: any): bool;\\ndeclare namespace bool {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: bool;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: bool;\\n  /** Parses a string as a bool. */\\n  export function parse(value: string): bool;\\n}\\n/** Converts any other numeric value to a 32-bit float. */\\ndeclare function f32(value: any): f32;\\ndeclare namespace f32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f32;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f32;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f32;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f32;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f32;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f32;\\n  /** Not a number value. */\\n  export const NaN: f32;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f32;\\n  /** Parses a string as an f32. */\\n  export function parse(value: string): f32;\\n  /** Loads a 32-bit float from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\\n  /** Stores a 32-bit float to memory. */\\n  export function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\\n  /** Computes the sum of two 32-bit floats. */\\n  export function add(left: f32, right: f32): f32;\\n  /** Computes the difference of two 32-bit floats. */\\n  export function sub(left: f32, right: f32): f32;\\n  /** Computes the product of two 32-bit floats. */\\n  export function mul(left: f32, right: f32): f32;\\n  /** Computes the quotient of two 32-bit floats. */\\n  export function div(left: f32, right: f32): f32;\\n  /** Return 1 two 32-bit floats are equal to each other, 0 otherwise. */\\n  export function eq(left: f32, right: f32): i32;\\n  /** Return 0 two 32-bit floats are equal to each other, 1 otherwise. */\\n  export function ne(left: f32, right: f32): i32;\\n  /** Computes the absolute value of a 32-bit float. */\\n  export function abs(value: f32): f32;\\n  /** Determines the maximum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function max(left: f32, right: f32): f32;\\n  /** Determines the minimum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function min(left: f32, right: f32): f32;\\n  /** Performs the ceiling operation on a 32-bit float. */\\n  export function ceil(value: f32): f32;\\n  /** Composes a 32-bit float from the magnitude of `x` and the sign of `y`. */\\n  export function copysign(x: f32, y: f32): f32;\\n  /** Performs the floor operation on a 32-bit float. */\\n  export function floor(value: f32): f32;\\n  /** Rounds to the nearest integer tied to even of a 32-bit float. */\\n  export function nearest(value: f32): f32;\\n  /** Reinterprets the bits of the specified 32-bit integer as a 32-bit float. */\\n  export function reinterpret_i32(value: i32): f32;\\n  /** Calculates the square root of a 32-bit float. */\\n  export function sqrt(value: f32): f32;\\n  /** Rounds to the nearest integer towards zero of a 32-bit float. */\\n  export function trunc(value: f32): f32;\\n}\\n/** Converts any other numeric value to a 64-bit float. */\\ndeclare function f64(value: any): f64;\\ndeclare namespace f64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f64;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f64;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f64;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f64;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f64;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f64;\\n  /** Not a number value. */\\n  export const NaN: f64;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f64;\\n  /** Parses a string as an f64. */\\n  export function parse(value: string): f64;\\n  /** Loads a 64-bit float from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\\n  /** Stores a 64-bit float to memory. */\\n  export function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\\n  /** Computes the sum of two 64-bit floats. */\\n  export function add(left: f64, right: f64): f64;\\n  /** Computes the difference of two 64-bit floats. */\\n  export function sub(left: f64, right: f64): f64;\\n  /** Computes the product of two 64-bit floats. */\\n  export function mul(left: f64, right: f64): f64;\\n  /** Computes the quotient of two 64-bit floats. */\\n  export function div(left: f64, right: f64): f64;\\n  /** Return 1 two 64-bit floats are equal to each other, 0 otherwise. */\\n  export function eq(left: f64, right: f64): i32;\\n  /** Return 0 two 32-bit floats are equal to each other, 1 otherwise. */\\n  export function ne(left: f64, right: f64): i32;\\n  /** Computes the absolute value of a 64-bit float. */\\n  export function abs(value: f64): f64;\\n  /** Determines the maximum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function max(left: f64, right: f64): f64;\\n  /** Determines the minimum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function min(left: f64, right: f64): f64;\\n  /** Performs the ceiling operation on a 64-bit float. */\\n  export function ceil(value: f64): f64;\\n  /** Composes a 64-bit float from the magnitude of `x` and the sign of `y`. */\\n  export function copysign(x: f64, y: f64): f64;\\n  /** Performs the floor operation on a 64-bit float. */\\n  export function floor(value: f64): f64;\\n  /** Rounds to the nearest integer tied to even of a 64-bit float. */\\n  export function nearest(value: f64): f64;\\n  /** Reinterprets the bits of the specified 64-bit integer as a 64-bit float. */\\n  export function reinterpret_i64(value: i64): f64;\\n  /** Calculates the square root of a 64-bit float. */\\n  export function sqrt(value: f64): f64;\\n  /** Rounds to the nearest integer towards zero of a 64-bit float. */\\n  export function trunc(value: f64): f64;\\n}\\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\\ndeclare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\\ndeclare namespace v128 {\\n  /** Creates a vector with identical lanes. */\\n  export function splat<T>(x: T): v128;\\n  /** Extracts one lane as a scalar. */\\n  export function extract_lane<T>(x: v128, idx: u8): T;\\n  /** Replaces one lane. */\\n  export function replace_lane<T>(x: v128, idx: u8, value: T): v128;\\n  /** Selects lanes from either vector according to the specified lane indexes. */\\n  export function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n  /** Loads a vector from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading the lanes of the specified type and extending each to the next larger type. */\\n  export function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading a value of the specified type into the lowest bits and initializing all other bits of the vector to zero. */\\n  export function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores the single lane at the specified index of the given vector to memory. */\\n  export function store_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\\n  /** Creates a vector with eight 16-bit integer lanes by loading and sign extending eight 8-bit integers. */\\n  export function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with eight 16-bit integer lanes by loading and zero extending eight 8-bit integers. */\\n  export function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with four 32-bit integer lanes by loading and sign extending four 16-bit integers. */\\n  export function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with four 32-bit integer lanes by loading and zero extending four 16-bit integers. */\\n  export function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with two 64-bit integer lanes by loading and sign extending two 32-bit integers. */\\n  export function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with two 64-bit integer lanes by loading and zero extending two 32-bit integers. */\\n  export function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with identical lanes by loading the splatted value. */\\n  export function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads an 8-bit integer and splats it sixteen times forming a new vector. */\\n  export function load8_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a 16-bit integer and splats it eight times forming a new vector. */\\n  export function load16_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a 32-bit integer and splats it four times forming a new vector. */\\n  export function load32_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a 64-bit integer and splats it two times forming a new vector. */\\n  export function load64_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading a 32-bit value into the lowest bits and initializing all other bits of the vector to zero. */\\n  export function load32_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading a 64-bit value into the lowest bits and initializing all other bits of the vector to zero. */\\n  export function load64_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 8-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 16-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 32-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 64-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores the 8-bit lane at the specified lane of the given vector to memory. */\\n  export function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores the 16-bit lane at the specified lane of the given vector to memory. */\\n  export function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores the 32-bit lane at the specified lane of the given vector to memory. */\\n  export function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores the 64-bit lane at the specified lane of the given vector to memory. */\\n  export function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a vector to memory. */\\n  export function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\\n  /** Adds each lane. */\\n  export function add<T>(a: v128, b: v128): v128;\\n  /** Subtracts each lane. */\\n  export function sub<T>(a: v128, b: v128): v128;\\n  /** Multiplies each lane. */\\n  export function mul<T>(a: v128, b: v128): v128; // except i64\\n  /** Divides each lane. */\\n  export function div<T extends f32 | f64>(a: v128, b: v128): v128;\\n  /** Negates each lane of a vector. */\\n  export function neg<T>(a: v128): v128;\\n  /** Adds each lane using saturation. */\\n  export function add_sat<T>(a: v128, b: v128): v128;\\n  /** Subtracts each lane using saturation. */\\n  export function sub_sat<T>(a: v128, b: v128): v128;\\n  /** Performs a bitwise left shift on each lane of a vector by a scalar. */\\n  export function shl<T>(a: v128, b: i32): v128;\\n  /** Performs a bitwise right shift on each lane of a vector by a scalar. */\\n  export function shr<T>(a: v128, b: i32): v128;\\n  /** Performs the bitwise AND operation on two vectors. */\\n  export function and(a: v128, b: v128): v128;\\n  /** Performs the bitwise OR operation on two vectors. */\\n  export function or(a: v128, b: v128): v128;\\n  /** Performs the bitwise XOR operation on two vectors. */\\n  export function xor(a: v128, b: v128): v128;\\n  /** Performs the bitwise ANDNOT operation on two vectors. */\\n  export function andnot(a: v128, b: v128): v128;\\n  /** Performs the bitwise NOT operation on a vector. */\\n  export function not(a: v128): v128;\\n  /** Selects bits of either vector according to the specified mask. Selects from `v1` if the bit in `mask` is `1`, otherwise from `v2`. */\\n  export function bitselect(v1: v128, v2: v128, mask: v128): v128;\\n  /** Reduces a vector to a scalar indicating whether any lane is considered `true`. */\\n  export function any_true(a: v128): bool;\\n  /** Reduces a vector to a scalar indicating whether all lanes are considered `true`. */\\n  export function all_true<T>(a: v128): bool;\\n  /** Extracts the high bit of each lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask<T>(a: v128): i32;\\n  /** Counts the number of bits set to one within each lane. */\\n  export function popcnt<T>(a: v128): v128;\\n  /** Computes the minimum of each lane. */\\n  export function min<T>(a: v128, b: v128): v128;\\n  /** Computes the maximum of each lane. */\\n  export function max<T>(a: v128, b: v128): v128;\\n  /** Computes the pseudo-minimum of each lane. */\\n  export function pmin<T extends f32 | f64>(a: v128, b: v128): v128;\\n  /** Computes the pseudo-maximum of each lane. */\\n  export function pmax<T extends f32 | f64>(a: v128, b: v128): v128;\\n  /** Computes the dot product of two lanes each, yielding lanes one size wider than the input. */\\n  export function dot<T extends i16>(a: v128, b: v128): v128;\\n  /** Computes the average of each lane. */\\n  export function avgr<T extends u8 | u16>(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each lane. */\\n  export function abs<T extends f32 | f64>(a: v128): v128;\\n  /** Computes the square root of each lane. */\\n  export function sqrt<T extends f32 | f64>(a: v128): v128;\\n  /** Performs the ceiling operation on each lane. */\\n  export function ceil<T extends f32 | f64>(a: v128): v128;\\n  /** Performs the floor operation on each lane. */\\n  export function floor<T extends f32 | f64>(a: v128): v128;\\n  /** Rounds to the nearest integer towards zero of each lane. */\\n  export function trunc<T extends f32 | f64>(a: v128): v128;\\n  /** Rounds to the nearest integer tied to even of each lane. */\\n  export function nearest<T extends f32 | f64>(a: v128): v128;\\n  /** Computes which lanes are equal. */\\n  export function eq<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes are not equal. */\\n  export function ne<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are less than those of the second. */\\n  export function lt<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are less than or equal those of the second. */\\n  export function le<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are greater than those of the second. */\\n  export function gt<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are greater than or equal those of the second. */\\n  export function ge<T>(a: v128, b: v128): v128;\\n  /** Converts each lane of a vector from integer to single-precision floating point. */\\n  export function convert<TFrom extends i32 | u32>(a: v128): v128;\\n  /** Converts the low lanes of a vector from integer to double-precision floating point. */\\n  export function convert_low<TFrom extends i32 | u32>(a: v128): v128;\\n  /** Truncates each lane of a vector from single-precision floating point to integer with saturation. Takes the target type. */\\n  export function trunc_sat<TTo extends i32 | u32>(a: v128): v128;\\n  /** Truncates each lane of a vector from double-precision floating point to integer with saturation. Takes the target type. */\\n  export function trunc_sat_zero<TTo extends i32 | u32>(a: v128): v128;\\n  /** Narrows each lane to their respective narrower lanes. */\\n  export function narrow<TFrom extends i16 | i32>(a: v128, b: v128): v128;\\n  /** Extends the low lanes of a vector to their respective wider lanes. */\\n  export function extend_low<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;\\n  /** Extends the high lanes of a vector to their respective wider lanes. */\\n  export function extend_high<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;\\n  /** Adds lanes pairwise producing twice wider extended results. */\\n  export function extadd_pairwise<TFrom extends i8 | u8 | i16 | u16>(a: v128): v128;\\n  /** Demotes each float lane to lower precision. The higher lanes of the result are initialized to zero. */\\n  export function demote_zero<T extends f64 = f64>(a: v128): v128;\\n  /** Promotes the lower float lanes to higher precision. */\\n  export function promote_low<T extends f32 = f32>(a: v128): v128;\\n  /** Performs the line-wise saturating rounding multiplication in Q15 format (`(a[i] * b[i] + (1 << (Q - 1))) >> Q` where `Q=15`). */\\n  export function q15mulr_sat<T extends i16>(a: v128, b: v128): v128;\\n  /** Performs the lane-wise integer extended multiplication of the lower lanes producing a twice wider result than the inputs. */\\n  export function extmul_low<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;\\n  /** Performs the lane-wise integer extended multiplication of the higher lanes producing a twice wider result than the inputs. */\\n  export function extmul_high<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;\\n  /**\\n   * Selects 8-bit lanes from `a` using indices in `s`. Indices in the range [0-15] select the i-th element of `a`.\\n   * \\n   * Unlike {@link v128.swizzle}, the result of an out of bounds index is implementation-defined, depending on hardware\\n   * capabilities: Either `0` or `a[s[i]%16]`.\\n   */\\n  export function relaxed_swizzle(a: v128, s: v128): v128;\\n  /**\\n   * Truncates each lane of a vector from 32-bit floating point to a 32-bit signed or unsigned integer as indicated by\\n   * `T`.\\n   *\\n   * Unlike {@link v128.trunc_sat}, the result of lanes out of bounds of the target type is implementation defined,\\n   * depending on hardware capabilities:\\n   * - If the input lane contains `NaN`, the result is either `0` or the respective maximum integer value.\\n   * - If the input lane contains a value otherwise out of bounds of the target type, the result is either the\\n   *   saturatated result or maximum integer value.\\n   */\\n  export function relaxed_trunc<T extends i32 | u32>(a: v128): v128;\\n  /**\\n   * Truncates each lane of a vector from 64-bit floating point to a 32-bit signed or unsigned integer as indicated by\\n   * `T`. Unused higher integer lanes of the result are initialized to zero.\\n   * \\n   * Unlike {@link v128.trunc_sat_zero}, the result of lanes out of bounds of the target type is implementation defined,\\n   * depending on hardware capabilities:\\n   * - If the input lane contains `NaN`, the result is either `0` or the respective maximum integer value.\\n   * - If the input lane contains a value otherwise out of bounds of the target type, the result is either the\\n   *   saturatated result or maximum integer value.\\n   */\\n  export function relaxed_trunc_zero<T extends i32 | u32>(a: v128): v128;\\n  /**\\n   * Performs the fused multiply-add operation (`a * b + c`) on 32- or 64-bit floating point lanes as indicated by\\n   * `T`.\\n   * \\n   * The result is implementation defined, depending on hardware capabilities:\\n   * - Either `a * b` is rounded once and the final result rounded again, or\\n   * - The expression is evaluated with higher precision and only rounded once\\n   */\\n  export function relaxed_madd<T>(a: v128, b: v128, c: v128): v128;\\n  /**\\n   * Performs the fused negative multiply-add operation (`-(a * b) + c`) on 32- or 64-bit floating point lanes as\\n   * indicated by `T`.\\n   * \\n   * The result is implementation defined, depending on hardware capabilities:\\n   * - Either `a * b` is rounded once and the final result rounded again, or\\n   * - The expression is evaluated with higher precision and only rounded once\\n   */\\n  export function relaxed_nmadd<T>(a: v128, b: v128, c: v128): v128;\\n  /**\\n   * Selects 8-, 16-, 32- or 64-bit integer lanes as indicated by `T` from `a` or `b` based on masks in `m`.\\n   * \\n   * Behaves like {@link v128.bitselect} if masks in `m` do have all bits either set (result is `a[i]`) or unset (result\\n   * is `b[i]`). Otherwise the result is implementation-defined, depending on hardware capabilities: If the most\\n   * significant bit of `m` is set, the result is either `bitselect(a[i], b[i], mask)` or `a[i]`, otherwise the result\\n   * is `b[i]`.\\n   */\\n  export function relaxed_laneselect<T>(a: v128, b: v128, m: v128): v128;\\n  /**\\n   * Computes the minimum of each 32- or 64-bit floating point lane as indicated by `T`.\\n   * \\n   * Unlike {@link v128.min}, the result is implementation-defined if either value is `NaN` or both are `-0.0` and\\n   * `+0.0`, depending on hardware capabilities: Either `a[i]` or `b[i]`.\\n   */\\n  export function relaxed_min<T>(a: v128, b: v128): v128;\\n  /**\\n   * Computes the maximum of each 32- or 64-bit floating point lane as indicated by `T`.\\n   * \\n   * Unlike {@link v128.max}, the result is implementation-defined if either value is `NaN` or both are `-0.0` and\\n   * `+0.0`, depending on hardware capabilities: Either `a[i]` or `b[i]`.\\n   */\\n  export function relaxed_max<T>(a: v128, b: v128): v128;\\n  /**\\n   * Performs the lane-wise rounding multiplication in Q15 format (`(a[i] * b[i] + (1 << (Q - 1))) >> Q` where `Q=15`).\\n   * \\n   * Unlike {@link v128.q15mulr_sat}, the result is implementation-defined if both inputs are the minimum signed value:\\n   * Either the minimum or maximum signed value.\\n   */\\n  export function relaxed_q15mulr<T>(a: v128, b: v128): v128;\\n  /**\\n   * Computes the dot product of two 8-bit integer lanes each, yielding lanes one size wider than the input.\\n   * \\n   * Unlike {@link v128.dot}, if the most significant bit of `b[i]` is set, whether `b[i]` is interpreted as signed or\\n   * unsigned is implementation-defined.\\n   */\\n  export function relaxed_dot<T>(a: v128, b: v128): v128;\\n  /**\\n   * Computes the dot product of two 8-bit integer lanes each, yielding lanes two sizes wider than the input with the\\n   * lanes of `c` accumulated into the result.\\n   * \\n   * Unlike {@link v128.dot}, if the most significant bit of `b[i]` is set, whether `b[i]` is interpreted as signed or\\n   * unsigned by the intermediate multiplication is implementation-defined.\\n   */\\n  export function relaxed_dot_add<T>(a: v128, b: v128, c: v128): v128;\\n}\\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\\ndeclare namespace i8x16 {\\n  /** Creates a vector with sixteen identical 8-bit integer lanes. */\\n  export function splat(x: i8): v128;\\n  /** Extracts one 8-bit integer lane as a signed scalar. */\\n  export function extract_lane_s(x: v128, idx: u8): i8;\\n  /** Extracts one 8-bit integer lane as an unsigned scalar. */\\n  export function extract_lane_u(x: v128, idx: u8): u8;\\n  /** Replaces one 8-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i8): v128;\\n  /** Adds each 8-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 8-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Computes the signed minimum of each 8-bit integer lane. */\\n  export function min_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned minimum of each 8-bit integer lane. */\\n  export function min_u(a: v128, b: v128): v128;\\n  /** Computes the signed maximum of each 8-bit integer lane. */\\n  export function max_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned maximum of each 8-bit integer lane. */\\n  export function max_u(a: v128, b: v128): v128;\\n  /** Computes the unsigned average of each 8-bit integer lane. */\\n  export function avgr_u(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 8-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 8-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Adds each 8-bit integer lane using signed saturation. */\\n  export function add_sat_s(a: v128, b: v128): v128;\\n  /** Adds each 8-bit integer lane using unsigned saturation. */\\n  export function add_sat_u(a: v128, b: v128): v128;\\n  /** Subtracts each 8-bit integer lane using signed saturation. */\\n  export function sub_sat_s(a: v128, b: v128): v128;\\n  /** Subtracts each 8-bit integer lane using unsigned saturation. */\\n  export function sub_sat_u(a: v128, b: v128): v128;\\n  /** Performs a bitwise left shift on each 8-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift on each 8-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 8-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 8-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 8-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Counts the number of bits set to one within each 8-bit integer lane. */\\n  export function popcnt(a: v128): v128;\\n  /** Computes which 8-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 8-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are less than those of the second. */\\n  export function lt_u(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_u(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than those of the second. */\\n  export function gt_u(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_u(a: v128, b: v128): v128;\\n  /** Narrows each 16-bit signed integer lane to 8-bit signed integer lanes. */\\n  export function narrow_i16x8_s(a: v128, b: v128): v128;\\n  /** Narrows each 16-bit signed integer lane to 8-bit unsigned integer lanes. */\\n  export function narrow_i16x8_u(a: v128, b: v128): v128;\\n  /** Selects 8-bit lanes from either vector according to the specified [0-15] respectively [16-31] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n  /**\\n   * Selects 8-bit integer lanes from `a` using indices in `s`. Indices in the range [0-15] select the i-th element of\\n   * `a`.\\n   * \\n   * Unlike {@link i8x16.swizzle}, the result of an out of bounds index is implementation-defined, depending on hardware\\n   * capabilities: Either `0` or `a[s[i]%16]`.\\n   */\\n  export function relaxed_swizzle(a: v128, s: v128): v128;\\n  /**\\n   * Selects 8-bit integer lanes from `a` or `b` based on masks in `m`.\\n   * \\n   * Behaves like {@link v128.bitselect} if masks in `m` do have all bits either set (result is `a[i]`) or unset (result\\n   * is `b[i]`). Otherwise the result is implementation-defined, depending on hardware capabilities: If the most\\n   * significant bit of `m` is set, the result is either `bitselect(a[i], b[i], mask)` or `a[i]`, otherwise the result\\n   * is `b[i]`.\\n   */\\n  export function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n}\\n/** Initializes a 128-bit vector from eight 16-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\\ndeclare namespace i16x8 {\\n  /** Creates a vector with eight identical 16-bit integer lanes. */\\n  export function splat(x: i16): v128;\\n  /** Extracts one 16-bit integer lane as a signed scalar. */\\n  export function extract_lane_s(x: v128, idx: u8): i16;\\n  /** Extracts one 16-bit integer lane as an unsigned scalar. */\\n  export function extract_lane_u(x: v128, idx: u8): u16;\\n  /** Replaces one 16-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i16): v128;\\n  /** Adds each 16-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 16-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 16-bit integer lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Computes the signed minimum of each 16-bit integer lane. */\\n  export function min_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned minimum of each 16-bit integer lane. */\\n  export function min_u(a: v128, b: v128): v128;\\n  /** Computes the signed maximum of each 16-bit integer lane. */\\n  export function max_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned maximum of each 16-bit integer lane. */\\n  export function max_u(a: v128, b: v128): v128;\\n  /** Computes the unsigned average of each 16-bit integer lane. */\\n  export function avgr_u(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 16-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 16-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Adds each 16-bit integer lane using signed saturation. */\\n  export function add_sat_s(a: v128, b: v128): v128;\\n  /** Adds each 16-bit integer lane using unsigned saturation. */\\n  export function add_sat_u(a: v128, b: v128): v128;\\n  /** Subtracts each 16-bit integer lane using signed saturation. */\\n  export function sub_sat_s(a: v128, b: v128): v128;\\n  /** Subtracts each 16-bit integer lane using unsigned saturation. */\\n  export function sub_sat_u(a: v128, b: v128): v128;\\n  /** Performs a bitwise left shift on each 16-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift each 16-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 16-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 16-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 16-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Computes which 16-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 16-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are less than those of the second. */\\n  export function lt_u(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_u(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than those of the second. */\\n  export function gt_u(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_u(a: v128, b: v128): v128;\\n  /** Narrows each 32-bit signed integer lane to 16-bit signed integer lanes. */\\n  export function narrow_i32x4_s(a: v128, b: v128): v128;\\n  /** Narrows each 32-bit signed integer lane to 16-bit unsigned integer lanes. */\\n  export function narrow_i32x4_u(a: v128, b: v128): v128;\\n  /** Extends the low 8-bit signed integer lanes to 16-bit signed integer lanes. */\\n  export function extend_low_i8x16_s(a: v128): v128;\\n  /** Extends the low 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */\\n  export function extend_low_i8x16_u(a: v128): v128;\\n  /** Extends the high 8-bit signed integer lanes to 16-bit signed integer lanes. */\\n  export function extend_high_i8x16_s(a: v128): v128;\\n  /** Extends the high 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */\\n  export function extend_high_i8x16_u(a: v128): v128;\\n  /** Adds the sixteen 8-bit signed integer lanes pairwise producing eight 16-bit signed integer results. */\\n  export function extadd_pairwise_i8x16_s(a: v128): v128;\\n  /** Adds the sixteen 8-bit unsigned integer lanes pairwise producing eight 16-bit unsigned integer results. */\\n  export function extadd_pairwise_i8x16_u(a: v128): v128;\\n  /** Performs the line-wise 16-bit signed integer saturating rounding multiplication in Q15 format. */\\n  export function q15mulr_sat_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */\\n  export function extmul_low_i8x16_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */\\n  export function extmul_low_i8x16_u(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */\\n  export function extmul_high_i8x16_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */\\n  export function extmul_high_i8x16_u(a: v128, b: v128): v128;\\n  /** Selects 16-bit lanes from either vector according to the specified [0-7] respectively [8-15] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8): v128;\\n  /**\\n   * Selects 16-bit integer lanes from `a` or `b` based on masks in `m`.\\n   *\\n   * Behaves like {@link v128.bitselect} if masks in `m` do have all bits either set (result is `a[i]`) or unset (result\\n   * is `b[i]`). Otherwise the result is implementation-defined, depending on hardware capabilities: If the most\\n   * significant bit of `m` is set, the result is either `bitselect(a[i], b[i], mask)` or `a[i]`, otherwise the result\\n   * is `b[i]`.\\n   */\\n  export function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n  /**\\n   * Performs the line-wise rounding multiplication in Q15 format (`(a[i] * b[i] + (1 << (Q - 1))) >> Q` where `Q=15`).\\n   *\\n   * Some results are implementation-defined: If both inputs are `i16.MIN_VALUE`, the value of the respective\\n   * resulting lane may be either `i16.MIN_VALUE` or `i16.MAX_VALUE`.\\n   */\\n  export function relaxed_q15mulr_s(a: v128, b: v128): v128;\\n  /**\\n   * Computes the dot product of two 8-bit integer lanes each, yielding lanes one size wider than the input.\\n   * \\n   * Some results are implementation-defined: If the most significant bit of `b[i]` is set, the intermediate\\n   * multiplication may interpret `b[i]` as either signed or unsigned.\\n   */\\n  export function relaxed_dot_i8x16_i7x16_s(a: v128, b: v128): v128;\\n}\\n/** Initializes a 128-bit vector from four 32-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\\ndeclare namespace i32x4 {\\n  /** Creates a vector with four identical 32-bit integer lanes. */\\n  export function splat(x: i32): v128;\\n  /** Extracts one 32-bit integer lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): i32;\\n  /** Replaces one 32-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i32): v128;\\n  /** Adds each 32-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 32-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 32-bit integer lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Computes the signed minimum of each 32-bit integer lane. */\\n  export function min_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned minimum of each 32-bit integer lane. */\\n  export function min_u(a: v128, b: v128): v128;\\n  /** Computes the signed maximum of each 32-bit integer lane. */\\n  export function max_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned maximum of each 32-bit integer lane. */\\n  export function max_u(a: v128, b: v128): v128;\\n  /** Computes the dot product of two 16-bit integer lanes each, yielding 32-bit integer lanes. */\\n  export function dot_i16x8_s(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 32-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 32-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Performs a bitwise left shift on each 32-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift on each 32-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 32-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 32-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 32-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Computes which 32-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 32-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are less than those of the second. */\\n  export function lt_u(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_u(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than those of the second. */\\n  export function gt_u(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_u(a: v128, b: v128): v128;\\n  /** Truncates each 32-bit float lane to a signed integer with saturation. */\\n  export function trunc_sat_f32x4_s(a: v128): v128;\\n  /** Truncates each 32-bit float lane to an unsigned integer with saturation. */\\n  export function trunc_sat_f32x4_u(a: v128): v128;\\n  /** Truncates the two 64-bit float lanes to the two lower signed integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */\\n  export function trunc_sat_f64x2_s_zero(a: v128): v128;\\n  /** Truncates the two 64-bit float lanes to the two lower unsigned integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */\\n  export function trunc_sat_f64x2_u_zero(a: v128): v128;\\n  /** Extends the low 16-bit signed integer lanes to 32-bit signed integer lanes. */\\n  export function extend_low_i16x8_s(a: v128): v128;\\n  /** Extends the low 16-bit unsigned integer lane to 32-bit unsigned integer lanes. */\\n  export function extend_low_i16x8_u(a: v128): v128;\\n  /** Extends the high 16-bit signed integer lanes to 32-bit signed integer lanes. */\\n  export function extend_high_i16x8_s(a: v128): v128;\\n  /** Extends the high 16-bit unsigned integer lanes to 32-bit unsigned integer lanes. */\\n  export function extend_high_i16x8_u(a: v128): v128;\\n  /** Adds the eight 16-bit signed integer lanes pairwise producing four 32-bit signed integer results. */\\n  export function extadd_pairwise_i16x8_s(a: v128): v128;\\n  /** Adds the eight 16-bit unsigned integer lanes pairwise producing four 32-bit unsigned integer results. */\\n  export function extadd_pairwise_i16x8_u(a: v128): v128;\\n  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */\\n  export function extmul_low_i16x8_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */\\n  export function extmul_low_i16x8_u(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */\\n  export function extmul_high_i16x8_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */\\n  export function extmul_high_i16x8_u(a: v128, b: v128): v128;\\n  /** Selects 32-bit lanes from either vector according to the specified [0-3] respectively [4-7] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n  /**\\n   * Truncates each lane of a vector from 32-bit floating point to a signed 32-bit integer.\\n   *\\n   * Unlike {@link i32x4.trunc_sat_f32x4_s}, the result of lanes out of bounds of the target type is implementation\\n   * defined, depending on hardware capabilities:\\n   * - If the input lane contains `NaN`, the result is either `0` or the respective maximum integer value.\\n   * - If the input lane contains a value otherwise out of bounds of the target type, the result is either the\\n   *   saturatated result or maximum integer value.\\n   */\\n  export function relaxed_trunc_f32x4_s(a: v128): v128;\\n  /**\\n   * Truncates each lane of a vector from 32-bit floating point to an unsigned 32-bit integer.\\n   *\\n   * Unlike {@link i32x4.trunc_sat_f32x4_u}, the result of lanes out of bounds of the target type is implementation\\n   * defined, depending on hardware capabilities:\\n   * - If the input lane contains `NaN`, the result is either `0` or the respective maximum integer value.\\n   * - If the input lane contains a value otherwise out of bounds of the target type, the result is either the\\n   *   saturatated result or maximum integer value.\\n   */\\n  export function relaxed_trunc_f32x4_u(a: v128): v128;\\n  /**\\n   * Truncates each lane of a vector from 64-bit floating point to a signed 32-bit integer. The two higher\\n   * integer lanes of the result are initialized to zero.\\n   * \\n   * Unlike {@link i32x4.trunc_sat_f64x2_s_zero}, the result of lanes out of bounds of the target type is implementation\\n   * defined, depending on hardware capabilities:\\n   * - If the input lane contains `NaN`, the result is either `0` or the respective maximum integer value.\\n   * - If the input lane contains a value otherwise out of bounds of the target type, the result is either the\\n   *   saturatated result or maximum integer value.\\n   */\\n  export function relaxed_trunc_f64x2_s_zero(a: v128): v128;\\n  /**\\n   * Truncates each lane of a vector from 64-bit floating point to an unsigned 32-bit integer. The two higher\\n   * integer lanes of the result are initialized to zero.\\n   * \\n   * Unlike {@link i32x4.trunc_sat_f64x2_u_zero}, the result of lanes out of bounds of the target type is implementation\\n   * defined, depending on hardware capabilities:\\n   * - If the input lane contains `NaN`, the result is either `0` or the respective maximum integer value.\\n   * - If the input lane contains a value otherwise out of bounds of the target type, the result is either the\\n   *   saturatated result or maximum integer value.\\n   */\\n  export function relaxed_trunc_f64x2_u_zero(a: v128): v128;\\n  /**\\n   * Selects 32-bit integer lanes from `a` or `b` based on masks in `m`.\\n   *\\n   * Behaves like {@link v128.bitselect} if masks in `m` do have all bits either set (result is `a[i]`) or unset (result\\n   * is `b[i]`). Otherwise the result is implementation-defined, depending on hardware capabilities: If the most\\n   * significant bit of `m` is set, the result is either `bitselect(a[i], b[i], mask)` or `a[i]`, otherwise the result\\n   * is `b[i]`.\\n   */\\n  export function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n  /**\\n   * Computes the dot product of two 8-bit lanes each, yielding lanes two sizes wider than the input with the lanes of\\n   * `c` accumulated into the result.\\n   * \\n   * Unlike {@link v128.dot}, if the most significant bit of `b[i]` is set, whether `b[i]` is interpreted as signed or\\n   * unsigned by the intermediate multiplication is implementation-defined.\\n   */\\n  export function relaxed_dot_i8x16_i7x16_add_s(a: v128, b: v128, c: v128): v128;\\n}\\n/** Initializes a 128-bit vector from two 64-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i64x2(a: i64, b: i64): v128;\\ndeclare namespace i64x2 {\\n  /** Creates a vector with two identical 64-bit integer lanes. */\\n  export function splat(x: i64): v128;\\n  /** Extracts one 64-bit integer lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): i64;\\n  /** Replaces one 64-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i64): v128;\\n  /** Adds each 64-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 64-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 64-bit integer lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 64-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 64-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Performs a bitwise left shift on each 64-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift on each 64-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 64-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 64-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 64-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Computes which 64-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 64-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Extends the low 32-bit signed integer lanes to 64-bit signed integer lanes. */\\n  export function extend_low_i32x4_s(a: v128): v128;\\n  /** Extends the low 32-bit unsigned integer lane to 64-bit unsigned integer lanes. */\\n  export function extend_low_i32x4_u(a: v128): v128;\\n  /** Extends the high 32-bit signed integer lanes to 64-bit signed integer lanes. */\\n  export function extend_high_i32x4_s(a: v128): v128;\\n  /** Extends the high 32-bit unsigned integer lanes to 64-bit unsigned integer lanes. */\\n  export function extend_high_i32x4_u(a: v128): v128;\\n  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */\\n  export function extmul_low_i32x4_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */\\n  export function extmul_low_i32x4_u(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */\\n  export function extmul_high_i32x4_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */\\n  export function extmul_high_i32x4_u(a: v128, b: v128): v128;\\n  /** Selects 64-bit lanes from either vector according to the specified [0-1] respectively [2-3] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n  /**\\n   * Selects 64-bit integer lanes from `a` or `b` based on masks in `m`.\\n   *\\n   * Behaves like {@link v128.bitselect} if masks in `m` do have all bits either set (result is `a[i]`) or unset (result\\n   * is `b[i]`). Otherwise the result is implementation-defined, depending on hardware capabilities: If the most\\n   * significant bit of `m` is set, the result is either `bitselect(a[i], b[i], mask)` or `a[i]`, otherwise the result\\n   * is `b[i]`.\\n   */\\n  export function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\\n}\\n/** Initializes a 128-bit vector from four 32-bit float values. Arguments must be compile-time constants. */\\ndeclare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\\ndeclare namespace f32x4 {\\n  /** Creates a vector with four identical 32-bit float lanes. */\\n  export function splat(x: f32): v128;\\n  /** Extracts one 32-bit float lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): f32;\\n  /** Replaces one 32-bit float lane. */\\n  export function replace_lane(x: v128, idx: u8, value: f32): v128;\\n  /** Adds each 32-bit float lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 32-bit float lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 32-bit float lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Divides each 32-bit float lane. */\\n  export function div(a: v128, b: v128): v128;\\n  /** Negates each 32-bit float lane. */\\n  export function neg(a: v128): v128;\\n  /** Computes the minimum of each 32-bit float lane. */\\n  export function min(a: v128, b: v128): v128;\\n  /** Computes the maximum of each 32-bit float lane. */\\n  export function max(a: v128, b: v128): v128;\\n  /** Computes the pseudo-minimum of each 32-bit float lane. */\\n  export function pmin(a: v128, b: v128): v128;\\n  /** Computes the pseudo-maximum of each 32-bit float lane. */\\n  export function pmax(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 32-bit float lane. */\\n  export function abs(a: v128): v128;\\n  /** Computes the square root of each 32-bit float lane. */\\n  export function sqrt(a: v128): v128;\\n  /** Performs the ceiling operation on each 32-bit float lane. */\\n  export function ceil(a: v128): v128;\\n  /** Performs the floor operation on each each 32-bit float lane. */\\n  export function floor(a: v128): v128;\\n  /** Rounds to the nearest integer towards zero of each 32-bit float lane. */\\n  export function trunc(a: v128): v128;\\n  /** Rounds to the nearest integer tied to even of each 32-bit float lane. */\\n  export function nearest(a: v128): v128;\\n  /** Computes which 32-bit float lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are less than those of the second. */\\n  export function lt(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are less than or equal those of the second. */\\n  export function le(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are greater than those of the second. */\\n  export function gt(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are greater than or equal those of the second. */\\n  export function ge(a: v128, b: v128): v128;\\n  /** Converts each 32-bit signed integer lane of a vector to single-precision floating point. */\\n  export function convert_i32x4_s(a: v128): v128;\\n  /** Converts each 32-bit unsigned integer lane of a vector to single-precision floating point. */\\n  export function convert_i32x4_u(a: v128): v128;\\n  /** Demotes each 64-bit float lane of a vector to single-precision. The higher lanes of the result are initialized to zero. */\\n  export function demote_f64x2_zero(a: v128): v128;\\n  /** Selects 32-bit lanes from either vector according to the specified [0-3] respectively [4-7] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n  /**\\n   * Performs the fused multiply-add operation (`a * b + c`) on all 32-bit floating point lanes.\\n   * \\n   * The result is implementation defined, depending on hardware capabilities:\\n   * - Either `a * b` is rounded once and the final result rounded again, or\\n   * - The expression is evaluated with higher precision and only rounded once\\n   */\\n  export function relaxed_madd(a: v128, b: v128, c: v128): v128;\\n  /**\\n   * Performs the fused negative multiply-add operation (`-(a * b) + c`) on all 32-bit floating point lanes.\\n   * \\n   * The result is implementation defined, depending on hardware capabilities:\\n   * - Either `a * b` is rounded once and the final result rounded again, or\\n   * - The expression is evaluated with higher precision and only rounded once\\n   */\\n  export function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\\n  /**\\n   * Computes the minimum of each 32-bit floating point lane.\\n   * \\n   * Unlike {@link f32x4.min}, the result is implementation-defined if either value is `NaN`, `-0.0` or `+0.0`,\\n   * depending on hardware capabilities: Either `a[i]` or `b[i]`.\\n   */\\n  export function relaxed_min(a: v128, b: v128): v128;\\n  /**\\n   * Computes the maximum of each 32-bit floating point lane.\\n   * \\n   * Unlike {@link f32x4.max}, the result is implementation-defined if either value is `NaN`, `-0.0` or `+0.0`,\\n   * depending on hardware capabilities: Either `a[i]` or `b[i]`.\\n   */\\n  export function relaxed_max(a: v128, b: v128): v128;\\n}\\n/** Initializes a 128-bit vector from two 64-bit float values. Arguments must be compile-time constants. */\\ndeclare function f64x2(a: f64, b: f64): v128;\\ndeclare namespace f64x2 {\\n  /** Creates a vector with two identical 64-bit float lanes. */\\n  export function splat(x: f64): v128;\\n  /** Extracts one 64-bit float lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): f64;\\n  /** Replaces one 64-bit float lane. */\\n  export function replace_lane(x: v128, idx: u8, value: f64): v128;\\n  /** Adds each 64-bit float lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 64-bit float lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 64-bit float lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Divides each 64-bit float lane. */\\n  export function div(a: v128, b: v128): v128;\\n  /** Negates each 64-bit float lane. */\\n  export function neg(a: v128): v128;\\n  /** Computes the minimum of each 64-bit float lane. */\\n  export function min(a: v128, b: v128): v128;\\n  /** Computes the maximum of each 64-bit float lane. */\\n  export function max(a: v128, b: v128): v128;\\n  /** Computes the pseudo-minimum of each 64-bit float lane. */\\n  export function pmin(a: v128, b: v128): v128;\\n  /** Computes the pseudo-maximum of each 64-bit float lane. */\\n  export function pmax(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 64-bit float lane. */\\n  export function abs(a: v128): v128;\\n  /** Computes the square root of each 64-bit float lane. */\\n  export function sqrt(a: v128): v128;\\n  /** Performs the ceiling operation on each 64-bit float lane. */\\n  export function ceil(a: v128): v128;\\n  /** Performs the floor operation on each each 64-bit float lane. */\\n  export function floor(a: v128): v128;\\n  /** Rounds to the nearest integer towards zero of each 64-bit float lane. */\\n  export function trunc(a: v128): v128;\\n  /** Rounds to the nearest integer tied to even of each 64-bit float lane. */\\n  export function nearest(a: v128): v128;\\n  /** Computes which 64-bit float lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are less than those of the second. */\\n  export function lt(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are less than or equal those of the second. */\\n  export function le(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are greater than those of the second. */\\n  export function gt(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are greater than or equal those of the second. */\\n  export function ge(a: v128, b: v128): v128;\\n  /** Converts the low 32-bit signed integer lanes of a vector to double-precision floating point. */\\n  export function convert_low_i32x4_s(a: v128): v128;\\n  /** Converts the low 32-bit unsigned integer lanes of a vector to double-precision floating point. */\\n  export function convert_low_i32x4_u(a: v128): v128;\\n  /** Promotes the low 32-bit float lanes of a vector to double-precision. */\\n  export function promote_low_f32x4(a: v128): v128;\\n  /** Selects 64-bit lanes from either vector according to the specified [0-1] respectively [2-3] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n  /**\\n   * Performs the fused multiply-add operation (`a * b + c`) on all 64-bit floating point lanes.\\n   * \\n   * The result is implementation defined, depending on hardware capabilities:\\n   * - Either `a * b` is rounded once and the final result rounded again, or\\n   * - The expression is evaluated with higher precision and only rounded once\\n   */\\n  export function relaxed_madd(a: v128, b: v128, c: v128): v128;\\n  /**\\n   * Performs the fused negative multiply-add operation (`-(a * b) + c`) on all 64-bit floating point lanes.\\n   * \\n   * The result is implementation defined, depending on hardware capabilities:\\n   * - Either `a * b` is rounded once and the final result rounded again, or\\n   * - The expression is evaluated with higher precision and only rounded once\\n   */\\n  export function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\\n  /**\\n   * Computes the minimum of each 64-bit floating point lane.\\n   * \\n   * Unlike {@link f64x2.min}, the result is implementation-defined if either value is `NaN`, `-0.0` or `+0.0`,\\n   * depending on hardware capabilities: Either `a[i]` or `b[i]`.\\n   */\\n  export function relaxed_min(a: v128, b: v128): v128;\\n  /**\\n   * Computes the maximum of each 64-bit floating point lane.\\n   * \\n   * Unlike {@link f64x2.max}, the result is implementation-defined if either value is `NaN`, `-0.0` or `+0.0`,\\n   * depending on hardware capabilities: Either `a[i]` or `b[i]`.\\n   */\\n  export function relaxed_max(a: v128, b: v128): v128;\\n}\\n\\ndeclare abstract class i31 {\\n  /** Creates a new 31-bit integer reference from the specified integer value. */\\n  static new(value: i32): ref_i31;\\n  /** Gets the integer value of an 31-bit integer reference. */\\n  static get(i31expr: ref_i31 | null): i32;\\n}\\n\\n/** Macro type evaluating to the underlying native WebAssembly type. */\\ndeclare type native<T> = T;\\n/** Special type evaluating the indexed access index type. */\\ndeclare type indexof<T extends ArrayLike<unknown>> = keyof T;\\n/** Special type evaluating the indexed access value type. */\\ndeclare type valueof<T extends ArrayLike<unknown>> = T[0];\\n/** A special type evaluated to the return type of T if T is a callable function. */\\ndeclare type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\\n/** A special type evaluated to the return type of T if T is a callable function. */\\ndeclare type returnof<T extends (...args: any) => any> = ReturnType<T>;\\n/** A special type that excludes null and undefined from T. */\\ndeclare type NonNullable<T> = T extends null | undefined ? never : T;\\n/** A special type that excludes null and undefined from T. */\\ndeclare type nonnull<T> = NonNullable<T>;\\n\\n/** Pseudo-class representing the backing class of integer types. */\\n/** @internal */\\ndeclare class _Integer {\\n  /** Smallest representable value. */\\n  static readonly MIN_VALUE: number;\\n  /** Largest representable value. */\\n  static readonly MAX_VALUE: number;\\n  /** @deprecated Converts a string to an integer of this type. Please use \\\"i32.parse\\\" method. */\\n  static parseInt(value: string, radix?: number): number;\\n  /** Converts this integer to a string. */\\n  toString(radix?: number): string;\\n}\\n\\n/** Pseudo-class representing the backing class of floating-point types. */\\n/** @internal */\\ndeclare class _Float {\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  static readonly EPSILON: f32 | f64;\\n  /** Smallest representable value. */\\n  static readonly MIN_VALUE: f32 | f64;\\n  /** Largest representable value. */\\n  static readonly MAX_VALUE: f32 | f64;\\n  /** Smallest safely representable integer value. */\\n  static readonly MIN_SAFE_INTEGER: f32 | f64;\\n  /** Largest safely representable integer value. */\\n  static readonly MAX_SAFE_INTEGER: f32 | f64;\\n  /** Value representing positive infinity. */\\n  static readonly POSITIVE_INFINITY: f32 | f64;\\n  /** Value representing negative infinity. */\\n  static readonly NEGATIVE_INFINITY: f32 | f64;\\n  /** Value representing 'not a number'. */\\n  static readonly NaN: f32 | f64;\\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\\n  static isNaN(value: f32 | f64): bool;\\n  /** Returns true if passed value is finite. */\\n  static isFinite(value: f32 | f64): bool;\\n  /** Returns true if the value passed is a safe integer. */\\n  static isSafeInteger(value: f32 | f64): bool;\\n  /** Returns true if the value passed is an integer, false otherwise. */\\n  static isInteger(value: f32 | f64): bool;\\n  /** @deprecated Converts a string to an integer. Please use \\\"i32.parse\\\" / \\\"i64.parse\\\" methods. */\\n  static parseInt(value: string, radix?: i32): f32 | f64;\\n  /** @deprecated Converts a string to a floating-point number. Please use \\\"f32.parse\\\" / \\\"f64.parse\\\" methods. */\\n  static parseFloat(value: string): f32 | f64;\\n  /** Converts this floating-point number to a string. */\\n  toString(radix?: number): string;\\n}\\n\\ndeclare class Boolean {\\n  toString(radix?: number): string;\\n}\\n\\n/** Backing class of signed 8-bit integers. */\\ndeclare const I8: typeof _Integer;\\n/** Backing class of signed 16-bit integers. */\\ndeclare const I16: typeof _Integer;\\n/** Backing class of signed 32-bit integers. */\\ndeclare const I32: typeof _Integer;\\n/** Backing class of signed 64-bit integers. */\\ndeclare const I64: typeof _Integer;\\n/** Backing class of signed size integers. */\\ndeclare const Isize: typeof _Integer;\\n/** Backing class of unsigned 8-bit integers. */\\ndeclare const U8: typeof _Integer;\\n/** Backing class of unsigned 16-bit integers. */\\ndeclare const U16: typeof _Integer;\\n/** Backing class of unsigned 32-bit integers. */\\ndeclare const U32: typeof _Integer;\\n/** Backing class of unsigned 64-bit integers. */\\ndeclare const U64: typeof _Integer;\\n/** Backing class of unsigned size integers. */\\ndeclare const Usize: typeof _Integer;\\n/** Backing class of 32-bit floating-point values. */\\ndeclare const F32: typeof _Float;\\n/** Backing class of 64-bit floating-point values. */\\ndeclare const F64: typeof _Float;\\n/** Alias of F64. */\\ndeclare const Number: typeof F64;\\ndeclare type Number = _Float;\\n\\n// User-defined diagnostic macros\\n\\n/** Emits a user-defined diagnostic error when encountered. */\\ndeclare function ERROR(message?: any): never;\\n/** Emits a user-defined diagnostic warning when encountered. */\\ndeclare function WARNING(message?: any): void;\\n/** Emits a user-defined diagnostic info when encountered. */\\ndeclare function INFO(message?: any): void;\\n\\n// Standard library\\n\\n/** Memory operations. */\\ndeclare namespace memory {\\n  /** Whether the memory managed interface is implemented. */\\n  export const implemented: bool;\\n  /** Returns the current memory size in units of pages. One page is 64kb. */\\n  export function size(): i32;\\n  /** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\\n  export function grow(value: i32): i32;\\n  /** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\\n  export function fill(dst: usize, value: u8, count: usize): void;\\n  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\\n  export function copy(dst: usize, src: usize, n: usize): void;\\n  /** Repeats `src` of length `srcLength` `count` times at `dst`. */\\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void;\\n  /** Copies elements from a passive element segment to a table. */\\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void;\\n  /** Prevents further use of a passive element segment. */\\n  export function drop(segmentIndex: u32): void;\\n  /** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\\n  export function compare(vl: usize, vr: usize, n: usize): i32;\\n  /** Gets a pointer to a zeroed static chunk of memory of the given size. Alignment defaults to `16`. Arguments must be compile-time constants. */\\n  export function data(size: i32, align?: i32): usize;\\n  /** Gets a pointer to a pre-initialized static chunk of memory. Alignment defaults to the size of `T`. Arguments must be compile-time constants. */\\n  export function data<T>(values: T[], align?: i32): usize;\\n\\n  export namespace atomic {\\n    /** Performs a wait operation on a 32-bit integer value in memory suspending this agent if the condition is met. */\\n    export function wait32(ptr: usize, expected: i32, timeout?: i64): AtomicWaitResult;\\n    /** Performs a wait operation on a 64-bit integer value in memory suspending this agent if the condition is met. */\\n    export function wait64(ptr: usize, expected: i64, timeout?: i64): AtomicWaitResult;\\n  }\\n}\\n\\n/** Heap memory interface. */\\ndeclare namespace heap {\\n  /** Allocates a chunk of memory of at least the specified size. */\\n  export function alloc(size: usize): usize;\\n  /** Reallocates a chunk of memory to have at least the specified size. */\\n  export function realloc(ptr: usize, size: usize): usize;\\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub/none runtime. */\\n  export function free(ptr: usize): void;\\n}\\n\\n/** Table operations. */\\ndeclare namespace table {\\n  /** Copies elements from a passive element segment to a table. */\\n  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void;\\n  /** Prevents further use of a passive element segment. */\\n  export function drop(elementIndex: u32): void;\\n  /** Copies elements from one region of a table to another region. */\\n  export function copy(dest: u32, src: u32, n: u32): void;\\n}\\n\\ndeclare namespace Atomics {\\n  export function load<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32): T;\\n  export function store<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): void;\\n  export function add<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function sub<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function and<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function or<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function xor<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function exchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function compareExchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, expectedValue: T, replacementValue: T): T;\\n  export function wait<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, value: T, timeout?: i64): AtomicWaitResult;\\n  export function notify<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, count?: i32): i32;\\n  /** The static Atomics.isLockFree() method is used to determine whether to use locks or atomic operations. It returns true, if the given size is one of the BYTES_PER_ELEMENT */\\n  export function isLockFree(size: usize): bool;\\n}\\n\\n/** Class representing a generic, fixed-length raw binary data buffer. */\\ndeclare class ArrayBuffer {\\n  /** The size, in bytes, of the array. */\\n  readonly byteLength: i32;\\n  /** Returns true if value is one of the ArrayBuffer views, such as typed array or a DataView **/\\n  static isView<T>(value: T): bool;\\n  /** Constructs a new array buffer of the given length in bytes. */\\n  constructor(length: i32);\\n  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */\\n  slice(begin?: i32, end?: i32): ArrayBuffer;\\n  /** Returns a string representation of ArrayBuffer. */\\n  toString(): string;\\n}\\n\\n/** The `DataView` view provides a low-level interface for reading and writing multiple number types in a binary `ArrayBuffer`, without having to care about the platform's endianness. */\\ndeclare class DataView {\\n  /** The `buffer` accessor property represents the `ArrayBuffer` or `SharedArrayBuffer` referenced by the `DataView` at construction time. */\\n  readonly buffer: ArrayBuffer;\\n  /** Returns raw pointer to data storage including offset (unsafe). */\\n  readonly dataStart: usize;\\n  /** The `byteLength` accessor property represents the length (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\\n  readonly byteLength: i32;\\n  /** The `byteOffset` accessor property represents the offset (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\\n  readonly byteOffset: i32;\\n  /** Constructs a new `DataView` with the given properties */\\n  constructor(buffer: ArrayBuffer, byteOffset?: i32, byteLength?: i32);\\n  /** The `getFloat32()` method gets a signed 32-bit float (float) at the specified byte offset from the start of the `DataView`. */\\n  getFloat32(byteOffset: i32, littleEndian?: bool): f32;\\n  /** The `getFloat64()` method gets a signed 64-bit float (double) at the specified byte offset from the start of the `DataView`. */\\n  getFloat64(byteOffset: i32, littleEndian?: bool): f64;\\n  /** The `getInt8()` method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the `DataView`. */\\n  getInt8(byteOffset: i32): i8;\\n  /** The `getInt16()` method gets a signed 16-bit integer (short) at the specified byte offset from the start of the `DataView`. */\\n  getInt16(byteOffset: i32, littleEndian?: bool): i16;\\n  /** The `getInt32()` method gets a signed 32-bit integer (long) at the specified byte offset from the start of the `DataView`. */\\n  getInt32(byteOffset: i32, littleEndian?: bool): i32;\\n  /** The `getInt64()` method gets a signed 64-bit integer (long long) at the specified byte offset from the start of the `DataView`. */\\n  getInt64(byteOffset: i32, littleEndian?: bool): i64;\\n  /** The `getUint8()` method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the `DataView`. */\\n  getUint8(byteOffset: i32): u8;\\n  /** The `getUint16()` method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the `DataView`. */\\n  getUint16(byteOffset: i32, littleEndian?: bool): u16;\\n  /** The `getUint32()` method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the `DataView`. */\\n  getUint32(byteOffset: i32, littleEndian?: bool): u32;\\n  /** The `getUint64()` method gets an unsigned 64-bit integer (unsigned long long) at the specified byte offset from the start of the `DataView`. */\\n  getUint64(byteOffset: i32, littleEndian?: bool): u64;\\n  /** The `setFloat32()` method stores a signed 32-bit float (float) value at the specified byte offset from the start of the `DataView`. */\\n  setFloat32(byteOffset: i32, value: f32, littleEndian?: bool): void;\\n  /** The `setFloat64()` method stores a signed 64-bit float (double) value at the specified byte offset from the start of the `DataView`. */\\n  setFloat64(byteOffset: i32, value: f64, littleEndian?: bool): void;\\n  /** The `setInt8()` method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\\n  setInt8(byteOffset: i32, value: i8): void;\\n  /** The `setInt16()` method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the `DataView`. */\\n  setInt16(byteOffset: i32, value: i16, littleEndian?: bool): void;\\n  /** The `setInt32()` method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the `DataView`. */\\n  setInt32(byteOffset: i32, value: i32, littleEndian?: bool): void;\\n  /** The `setInt64()` method stores a signed 64-bit integer (long long) value at the specified byte offset from the start of the `DataView`. */\\n  setInt64(byteOffset: i32, value: i64, littleEndian?: bool): void;\\n  /** The `setUint8()` method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\\n  setUint8(byteOffset: i32, value: u8): void;\\n  /** The `setUint16()` method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the `DataView`. */\\n  setUint16(byteOffset: i32, value: u16, littleEndian?: bool): void;\\n  /** The `setUint32()` method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the `DataView`. */\\n  setUint32(byteOffset: i32, value: u32, littleEndian?: bool): void;\\n  /** The `setUint64()` method stores an unsigned 64-bit integer (unsigned long long) value at the specified byte offset from the start of the `DataView`. */\\n  setUint64(byteOffset: i32, value: u64, littleEndian?: bool): void;\\n  /** Returns a string representation of DataView. */\\n  toString(): string;\\n}\\n\\ninterface ArrayLike<T> {\\n  [key: number]: T;\\n  length: i32;\\n}\\n\\n/** Interface for a typed view on an array buffer. */\\ninterface ArrayBufferView {\\n  /** The {@link ArrayBuffer} referenced by this view. */\\n  readonly buffer: ArrayBuffer;\\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteOffset: i32;\\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteLength: i32;\\n  /** Returns raw pointer to data storage including offset (unsafe). */\\n  readonly dataStart: usize;\\n}\\n\\n/** @internal */\\ndeclare abstract class TypedArray<T> implements ArrayBufferView {\\n  [key: number]: T;\\n  /** Number of bytes per element. */\\n  static readonly BYTES_PER_ELEMENT: usize;\\n  /** Constructs a new typed array. */\\n  constructor(length: i32);\\n  /** The {@link ArrayBuffer} referenced by this view. */\\n  readonly buffer: ArrayBuffer;\\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteOffset: i32;\\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteLength: i32;\\n  /** Returns raw pointer to data storage including offset (unsafe). */\\n  readonly dataStart: usize;\\n  /** The length (in elements). */\\n  readonly length: i32;\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): T;\\n  /** The includes() method determines whether a typed array includes a certain element, returning true or false as appropriate. */\\n  includes(searchElement: T, fromIndex?: i32): bool;\\n  /** The indexOf() method returns the first index at which a given element can be found in the typed array, or -1 if it is not present. */\\n  indexOf(searchElement: T, fromIndex?: i32): i32;\\n  /** The lastIndexOf() method returns the last index at which a given element can be found in the typed array, or -1 if it is not present. The typed array is searched backwards, starting at fromIndex. */\\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\\n  /** Returns copied section of an TypedArray from begin inclusive to end exclusive */\\n  slice(begin?: i32, end?: i32): TypedArray<T>;\\n  /** Returns a new TypedArray of this type on the same ArrayBuffer from begin inclusive to end exclusive. */\\n  subarray(begin?: i32, end?: i32): TypedArray<T>;\\n  /** The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end. The end argument is optional and defaults to the length of the array. */\\n  copyWithin(target: i32, start: i32, end?: i32): this;\\n  /**  The reduce() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value. This method has the same algorithm as Array.prototype.reduce(). */\\n  reduce<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;\\n  /**  The reduceRight() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value, starting from the end of the array. This method has the same algorithm as Array.prototype.reduceRight(). */\\n  reduceRight<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;\\n  /** The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some().*/\\n  some(callbackfn: (value: T, index: i32, self: this) => bool): bool;\\n  /** The map() method creates a new typed array with the results of calling a provided function on every element in this typed array. This method has the same algorithm as Array.prototype.map().*/\\n  map(callbackfn: (value: T, index: i32, self: this) => T): TypedArray<T>;\\n  /** The filter() method creates a new typed array with all elements that pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.filter(). */\\n  filter(callbackfn: (value: T, index: i32, self: this) => bool): TypedArray<T>;\\n  /** The sort() method sorts the elements of a typed array numerically in place and returns the typed array. This method has the same algorithm as Array.prototype.sort(), except that sorts the values numerically instead of as strings. TypedArray is one of the typed array types here. */\\n  sort(callback?: (a: T, b: T) => i32): this;\\n  /** The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). */\\n  fill(value: T, start?: i32, end?: i32): this;\\n  /** The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */\\n  findIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;\\n  /** The findLastIndex() method returns an index start searching from the end in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */\\n  findLastIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;\\n  /** The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). */\\n  every(callbackfn: (value: T, index: i32, self: this) => bool): bool;\\n  /** The forEach() method executes a provided function once per array element. This method has the same algorithm as Array.prototype.forEach().*/\\n  forEach(callbackfn: (value: T, index: i32, self: this) => void): void;\\n  /** The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). */\\n  reverse(): this;\\n  /** The join() method joins all elements of an array into a string. This method has the same algorithm as Array.prototype.join(). */\\n  join(separator?: string): string;\\n  /** The set() method stores multiple values in the typed array, reading input values from a specified array. */\\n  set<U extends ArrayLike<number>>(source: U, offset?: i32): void\\n  /** The toString() method returns a string representing the specified array and its elements. This method has the same algorithm as Array.prototype.toString() */\\n  toString(): string;\\n}\\n\\n/** An array of twos-complement 8-bit signed integers. */\\ndeclare class Int8Array extends TypedArray<i8> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;\\n}\\n/** An array of 8-bit unsigned integers. */\\ndeclare class Uint8Array extends TypedArray<u8> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;\\n}\\n/** A clamped array of 8-bit unsigned integers. */\\ndeclare class Uint8ClampedArray extends TypedArray<u8> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;\\n}\\n/** An array of twos-complement 16-bit signed integers. */\\ndeclare class Int16Array extends TypedArray<i16> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;\\n}\\n/** An array of 16-bit unsigned integers. */\\ndeclare class Uint16Array extends TypedArray<u16> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;\\n}\\n/** An array of twos-complement 32-bit signed integers. */\\ndeclare class Int32Array extends TypedArray<i32> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;\\n}\\n/** An array of 32-bit unsigned integers. */\\ndeclare class Uint32Array extends TypedArray<u32> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;\\n}\\n/** An array of twos-complement 64-bit signed integers. */\\ndeclare class Int64Array extends TypedArray<i64> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int64Array;\\n}\\n/** An array of 64-bit unsigned integers. */\\ndeclare class Uint64Array extends TypedArray<u64> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint64Array;\\n}\\n/** An array of 32-bit floating point numbers. */\\ndeclare class Float32Array extends TypedArray<f32> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;\\n}\\n/** An array of 64-bit floating point numbers. */\\ndeclare class Float64Array extends TypedArray<f64> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;\\n}\\n\\n/** Class representing a sequence of values of type `T`. */\\ndeclare class Array<T> {\\n\\n  /** Tests if a value is an array. */\\n  static isArray<U>(value: any): value is Array<any>;\\n\\n  [key: number]: T;\\n  /** Current length of the array. */\\n  length: i32;\\n  /** Returns raw pointer to data storage (unsafe). */\\n  readonly dataStart: usize;\\n  /** Constructs a new array. */\\n  constructor(length?: i32);\\n  at(index: i32): T;\\n  fill(value: T, start?: i32, end?: i32): this;\\n  findIndex(callbackfn: (value: T, index: i32, array: Array<T>) => bool): i32;\\n  findLastIndex(callbackfn: (value: T, index: i32, array: Array<T>) => bool): i32;\\n  includes(searchElement: T, fromIndex?: i32): bool;\\n  indexOf(searchElement: T, fromIndex?: i32): i32;\\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\\n  push(element: T): i32;\\n  concat(items: T[]): T[];\\n  copyWithin(target: i32, start: i32, end?: i32): this;\\n  pop(): T;\\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;\\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;\\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;\\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\\n  every(callbackfn: (value: T, index: i32, array: Array<T>) => bool): bool;\\n  some(callbackfn: (value: T, index: i32, array: Array<T>) => bool): bool;\\n  shift(): T;\\n  unshift(element: T): i32;\\n  slice(from?: i32, to?: i32): Array<T>;\\n  splice(start: i32, deleteCount?: i32): Array<T>;\\n  sort(comparator?: (a: T, b: T) => i32): this;\\n  join(separator?: string): string;\\n  reverse(): this;\\n  /** Flattens an array of arrays. If any null entries exist in the array, they are ignored, unlike JavaScript's version of Array#flat(). */\\n  flat(): T extends unknown[] ? T : never;\\n  toString(): string;\\n}\\n\\n/** Class representing a static (not resizable) sequence of values of type `T`. This class is @final. */\\ndeclare class StaticArray<T> {\\n  [key: number]: T;\\n  static fromArray<T>(source: Array<T>): StaticArray<T>;\\n  /** @deprecated */\\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T>;\\n  /** @deprecated */\\n  static slice<T>(source: StaticArray<T>, start?: i32, end?: i32): StaticArray<T>;\\n  readonly length: i32;\\n  constructor(length?: i32);\\n  at(index: i32): T;\\n  fill(value: T, start?: i32, end?: i32): this;\\n  findIndex(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): i32;\\n  findLastIndex(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): i32;\\n  copyWithin(target: i32, start: i32, end?: i32): this;\\n  includes(searchElement: T, fromIndex?: i32): bool;\\n  indexOf(searchElement: T, fromIndex?: i32): i32;\\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\\n  forEach(callbackfn: (value: T, index: i32, array: StaticArray<T>) => void): void;\\n  map<U>(callbackfn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U>;\\n  filter(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T>;\\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U, initialValue: U): U;\\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U, initialValue: U): U;\\n  every(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): bool;\\n  some(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): bool;\\n  concat(items: Array<T>): Array<T>;\\n  concat<U extends ArrayLike<T>>(other: U): U;\\n  slice(from?: i32, to?: i32): Array<T>;\\n  slice<U extends ArrayLike<T>>(from?: i32, to?: i32): U;\\n  sort(comparator?: (a: T, b: T) => i32): this;\\n  join(separator?: string): string;\\n  reverse(): this;\\n  toString(): string;\\n}\\n\\n/** Class representing a sequence of characters. */\\ndeclare class String {\\n  static fromCharCode(ls: i32, hs?: i32): string;\\n  static fromCharCodes(arr: i32[]): string;\\n  static fromCodePoint(code: i32): string;\\n  static fromCodePoints(arr: i32[]): string;\\n  static raw(parts: TemplateStringsArray, ...args: any[]): string;\\n  readonly length: i32;\\n  at(index: i32): string;\\n  charAt(index: i32): string;\\n  charCodeAt(index: i32): i32;\\n  codePointAt(index: i32): i32;\\n  concat(other: string): string;\\n  endsWith(other: string): bool;\\n  indexOf(other: string, fromIndex?: i32): i32;\\n  lastIndexOf(other: string, fromIndex?: i32): i32;\\n  localeCompare(other: string): i32;\\n  includes(other: string): bool;\\n  startsWith(other: string): bool;\\n  substr(start: i32, length?: i32): string;\\n  substring(start: i32, end?: i32): string;\\n  trim(): string;\\n  trimLeft(): string;\\n  trimRight(): string;\\n  trimStart(): string;\\n  trimEnd(): string;\\n  padStart(targetLength: i32, padString?: string): string;\\n  padEnd(targetLength: i32, padString?: string): string;\\n  repeat(count?: i32): string;\\n  replace(search: string, replacement: string): string;\\n  replaceAll(search: string, replacement: string): string;\\n  slice(beginIndex: i32, endIndex?: i32): string;\\n  split(separator?: string, limit?: i32): string[];\\n  toLowerCase(): string;\\n  toUpperCase(): string;\\n  toString(): string;\\n}\\n\\ndeclare namespace String {\\n  /** Encoding helpers for UTF-8. */\\n  export namespace UTF8 {\\n    /** UTF-8 encoding error modes. */\\n    export const enum ErrorMode {\\n      /** Keeps unpaired surrogates as of WTF-8. This is the default. */\\n      WTF8,\\n      /** Replaces unpaired surrogates with the replacement character (U+FFFD). */\\n      REPLACE,\\n      /** Throws an error on unpaired surrogates. */\\n      ERROR\\n    }\\n    /** Calculates the byte length of the specified string when encoded as UTF-8, optionally null terminated. */\\n    export function byteLength(str: string, nullTerminated?: bool): i32;\\n    /** Encodes the specified string to UTF-8 bytes, optionally null terminated. ErrorMode defaults to WTF-8. */\\n    export function encode(str: string, nullTerminated?: bool, errorMode?: ErrorMode): ArrayBuffer;\\n    /** Encodes the specified raw string to UTF-8 bytes, opionally null terminated. ErrorMode defaults to WTF-8. Returns the number of bytes written. */\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated?: bool, errorMode?: ErrorMode): usize;\\n    /** Decodes the specified buffer from UTF-8 bytes to a string, optionally null terminated. */\\n    export function decode(buf: ArrayBuffer, nullTerminated?: bool): string;\\n    /** Decodes raw UTF-8 bytes to a string, optionally null terminated. */\\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated?: bool): string;\\n  }\\n  /** Encoding helpers for UTF-16. */\\n  export namespace UTF16 {\\n    /** Calculates the byte length of the specified string when encoded as UTF-16. */\\n    export function byteLength(str: string): i32;\\n    /** Encodes the specified string to UTF-16 bytes. */\\n    export function encode(str: string): ArrayBuffer;\\n    /** Encodes the specified raw string to UTF-16 bytes. Returns the number of bytes written. */\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize;\\n    /** Decodes the specified buffer from UTF-16 bytes to a string. */\\n    export function decode(buf: ArrayBuffer): string;\\n    /** Decodes raw UTF-16 bytes to a string. */\\n    export function decodeUnsafe(buf: usize, len: usize): string;\\n  }\\n}\\n\\ndeclare class TemplateStringsArray extends Array<string> {\\n  readonly raw: string[];\\n}\\n\\ndeclare class Object {\\n  /** The Object.is() method determines whether two values are the same value. */\\n  static is<T>(value1: T, value2: T): bool;\\n}\\n\\ndeclare namespace performance {\\n  /** Gets a high resolution timestamp measured in milliseconds. */\\n  export function now(): f64;\\n}\\n\\ndeclare class Date {\\n  /** Returns the UTC timestamp in milliseconds of the specified date. */\\n  static UTC(\\n    year: i32,\\n    month: i32,\\n    day: i32,\\n    hour: i32,\\n    minute: i32,\\n    second: i32,\\n    millisecond: i32\\n  ): i64;\\n  /** Returns the current UTC timestamp in milliseconds. */\\n  static now(): i64;\\n  /** Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC. */\\n  static parse(dateString: string): Date;\\n  static fromString(dateString: string): Date;\\n  /** Constructs a new date object from an UTC timestamp in milliseconds. */\\n  constructor(value: i64);\\n  /** Returns the UTC timestamp of this date in milliseconds. */\\n  getTime(): i64;\\n  /** Sets the UTC timestamp of this date in milliseconds. */\\n  setTime(value: i64): i64;\\n\\n  getUTCFullYear(): i32;\\n  getUTCMonth(): i32;\\n  getUTCDate(): i32;\\n  getUTCDay(): i32;\\n  getUTCHours(): i32;\\n  getUTCMinutes(): i32;\\n  getUTCSeconds(): i32;\\n  getUTCMilliseconds(): i32;\\n\\n  setUTCFullYear(value: i32): void;\\n  setUTCMonth(value: i32, day?: i32): void;\\n  setUTCDate(value: i32): void;\\n  setUTCHours(value: i32): void;\\n  setUTCMinutes(value: i32): void;\\n  setUTCSeconds(value: i32): void;\\n  setUTCMilliseconds(value: i32): void;\\n\\n  toString(): string;\\n  toISOString(): string;\\n  toUTCString(): string;\\n  toDateString(): string;\\n  toTimeString(): string;\\n}\\n\\n/** Class for representing a runtime error. Base class of all errors. */\\ndeclare class Error {\\n\\n  /** Error name. */\\n  name: string;\\n\\n  /** Message provided on construction. */\\n  message: string;\\n\\n  /** Stack trace. */\\n  stack?: string;\\n\\n  /** Constructs a new error, optionally with a message. */\\n  constructor(message?: string);\\n\\n  /** Method returns a string representing the specified Error class. */\\n  toString(): string;\\n}\\n\\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\\ndeclare class RangeError extends Error { }\\n\\n/** Class for indicating an error when a value is not of the expected type. */\\ndeclare class TypeError extends Error { }\\n\\n/** Class for indicating an error when trying to interpret syntactically invalid code. */\\ndeclare class SyntaxError extends Error { }\\n\\n/** Class for indicating an error when a global URI handling function was used in a wrong way. */\\ndeclare class URIError extends Error { }\\n\\ninterface Function {\\n  /** Function table index. */\\n  readonly index: u32;\\n  /** Function name. Always an empty string. */\\n  readonly name: string;\\n  /** Number of expected parameters. */\\n  readonly length: u32;\\n  /** Calls this function indirectly with the specified arguments. */\\n  call(thisArg: unknown, ...args: unknown[]): any;\\n  /** Returns a string representation of this function. */\\n  toString(): string;\\n}\\n\\n/**\\n * Extracts the type of the 'this' parameter of a function type, or 'unknown' if the function type has no 'this' parameter.\\n */\\ntype ThisParameterType<T> = T extends (this: infer U, ...args: never) => any ? U : unknown;\\n\\n/**\\n * Removes the 'this' parameter from a function type.\\n */\\ntype OmitThisParameter<T> = unknown extends ThisParameterType<T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T;\\n\\ninterface CallableFunction extends Function {\\n  /**\\n   * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\\n   * @param thisArg The object to be used as the this object.\\n   */\\n  apply<T, R>(this: (this: T) => R, thisArg: T): R;\\n\\n  /**\\n   * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\\n   * @param thisArg The object to be used as the this object.\\n   * @param args An array of argument values to be passed to the function.\\n   */\\n  apply<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, args: A): R;\\n\\n  /**\\n   * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\\n   * @param thisArg The object to be used as the this object.\\n   * @param args Argument values to be passed to the function.\\n   */\\n  call<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, ...args: A): R;\\n\\n  /**\\n   * For a given function, creates a bound function that has the same body as the original function.\\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\\n   * @param thisArg The object to be used as the this object.\\n   */\\n  bind<T>(this: T, thisArg: ThisParameterType<T>): OmitThisParameter<T>;\\n\\n  /**\\n   * For a given function, creates a bound function that has the same body as the original function.\\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\\n   * @param thisArg The object to be used as the this object.\\n   * @param args Arguments to bind to the parameters of the function.\\n   */\\n  bind<T, A extends any[], B extends any[], R>(this: (this: T, ...args: [...A, ...B]) => R, thisArg: T, ...args: A): (...args: B) => R;\\n}\\n\\ninterface NewableFunction extends Function {\\n  /**\\n   * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\\n   * @param thisArg The object to be used as the this object.\\n   */\\n  apply<T>(this: new () => T, thisArg: T): void;\\n  /**\\n   * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\\n   * @param thisArg The object to be used as the this object.\\n   * @param args An array of argument values to be passed to the function.\\n   */\\n  apply<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, args: A): void;\\n\\n  /**\\n   * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\\n   * @param thisArg The object to be used as the this object.\\n   * @param args Argument values to be passed to the function.\\n   */\\n  call<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, ...args: A): void;\\n\\n  /**\\n   * For a given function, creates a bound function that has the same body as the original function.\\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\\n   * @param thisArg The object to be used as the this object.\\n   */\\n  bind<T>(this: T, thisArg: any): T;\\n\\n  /**\\n   * For a given function, creates a bound function that has the same body as the original function.\\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\\n   * @param thisArg The object to be used as the this object.\\n   * @param args Arguments to bind to the parameters of the function.\\n   */\\n  bind<A extends any[], B extends any[], R>(this: new (...args: [...A, ...B]) => R, thisArg: any, ...args: A): new (...args: B) => R;\\n}\\n\\ninterface IArguments {}\\ninterface RegExp {}\\n\\ndeclare class Map<K,V> {\\n  readonly size: i32;\\n  has(key: K): bool;\\n  set(key: K, value: V): this;\\n  get(key: K): V;\\n  delete(key: K): bool;\\n  clear(): void;\\n  keys(): K[]; // preliminary\\n  values(): V[]; // preliminary\\n  toString(): string;\\n}\\n\\ndeclare class Set<K> {\\n  readonly size: i32;\\n  has(value: K): bool;\\n  add(value: K): this;\\n  delete(value: K): bool;\\n  clear(): void;\\n  values(): K[]; // preliminary\\n  toString(): string;\\n}\\n\\ninterface SymbolConstructor {\\n  readonly hasInstance: symbol;\\n  readonly isConcatSpreadable: symbol;\\n  readonly isRegExp: symbol;\\n  readonly iterator: symbol;\\n  readonly match: symbol;\\n  readonly replace: symbol;\\n  readonly search: symbol;\\n  readonly species: symbol;\\n  readonly split: symbol;\\n  readonly toPrimitive: symbol;\\n  readonly toStringTag: symbol;\\n  readonly unscopables: symbol;\\n  (description?: string | null): symbol;\\n  for(key: string): symbol;\\n  keyFor(sym: symbol): string | null;\\n}\\n\\ndeclare const Symbol: SymbolConstructor;\\n\\n/** @internal */\\ninterface IMath<T> {\\n  /** The base of natural logarithms, e, approximately 2.718. */\\n  readonly E: T;\\n  /** The natural logarithm of 2, approximately 0.693. */\\n  readonly LN2: T;\\n  /** The natural logarithm of 10, approximately 2.302. */\\n  readonly LN10: T;\\n  /** The base 2 logarithm of e, approximately 1.442. */\\n  readonly LOG2E: T;\\n  /** The base 10 logarithm of e, approximately 0.434. */\\n  readonly LOG10E: T;\\n  /** The ratio of the circumference of a circle to its diameter, approximately 3.14159. */\\n  readonly PI: T;\\n  /** The square root of 1/2, approximately 0.707. */\\n  readonly SQRT1_2: T;\\n  /** The square root of 2, approximately 1.414. */\\n  readonly SQRT2: T;\\n  /** Returns the absolute value of `x`. */\\n  abs(x: T): T;\\n  /** Returns the arccosine (in radians) of `x`. */\\n  acos(x: T): T;\\n  /** Returns the hyperbolic arc-cosine of `x`. */\\n  acosh(x: T): T;\\n  /** Returns the arcsine (in radians) of `x`. */\\n  asin(x: T): T;\\n  /** Returns the hyperbolic arcsine of `x`. */\\n  asinh(x: T): T;\\n  /** Returns the arctangent (in radians) of `x`. */\\n  atan(x: T): T;\\n  /** Returns the arctangent of the quotient of its arguments. */\\n  atan2(y: T, x: T): T;\\n  /** Returns the hyperbolic arctangent of `x`. */\\n  atanh(x: T): T;\\n  /** Returns the cube root of `x`. */\\n  cbrt(x: T): T;\\n  /** Returns the smallest integer greater than or equal to `x`. */\\n  ceil(x: T): T;\\n  /** Returns the number of leading zero bits in the 32-bit binary representation of `x`. */\\n  clz32(x: T): T;\\n  /** Returns the cosine (in radians) of `x`. */\\n  cos(x: T): T;\\n  /** Returns the hyperbolic cosine of `x`. */\\n  cosh(x: T): T;\\n  /** Returns e to the power of `x`. */\\n  exp(x: T): T;\\n  /** Returns e to the power of `x`, minus 1. */\\n  expm1(x: T): T;\\n  /** Returns the largest integer less than or equal to `x`. */\\n  floor(x: T): T;\\n  /** Returns the nearest 32-bit single precision float representation of `x`. */\\n  fround(x: T): T;\\n  /** Returns the square root of the sum of squares of its arguments. */\\n  hypot(value1: T, value2: T): T; // TODO: rest\\n  /** Returns the result of the C-like 32-bit multiplication of `a` and `b`. */\\n  imul(a: T, b: T): T;\\n  /** Returns the natural logarithm (base e) of `x`. */\\n  log(x: T): T;\\n  /** Returns the base 10 logarithm of `x`. */\\n  log10(x: T): T;\\n  /** Returns the natural logarithm (base e) of 1 + `x`. */\\n  log1p(x: T): T;\\n  /** Returns the base 2 logarithm of `x`. */\\n  log2(x: T): T;\\n  /** Returns the largest-valued number of its arguments. */\\n  max(value1: T, value2: T): T; // TODO: rest\\n  /** Returns the lowest-valued number of its arguments. */\\n  min(value1: T, value2: T): T; // TODO: rest\\n  /** Returns `base` to the power of `exponent`. */\\n  pow(base: T, exponent: T): T;\\n  /** Returns a pseudo-random number in the range from 0.0 inclusive up to but not including 1.0. */\\n  random(): T;\\n  /** Returns the value of `x` rounded to the nearest integer. */\\n  round(x: T): T;\\n  /** Returns the sign of `x`, indicating whether the number is positive, negative or zero. */\\n  sign(x: T): T;\\n  /** Returns whether the sign bit of `x` is set. */\\n  signbit(x: T): bool;\\n  /** Returns the sine of `x`. */\\n  sin(x: T): T;\\n  /** Returns the hyperbolic sine of `x`. */\\n  sinh(x: T): T;\\n  /** Returns the square root of `x`. */\\n  sqrt(x: T): T;\\n  /** Returns the tangent of `x`. */\\n  tan(x: T): T;\\n  /** Returns the hyperbolic tangent of `x`. */\\n  tanh(x: T): T;\\n  /** Returns the integer part of `x` by removing any fractional digits. */\\n  trunc(x: T): T;\\n}\\n\\n/** @internal */\\ninterface INativeMath<T> extends IMath<T> {\\n  /** Contains sin value produced after Math/Mathf.sincos */\\n  sincos_sin: T;\\n  /** Contains cos value produced after Math/Mathf.sincos */\\n  sincos_cos: T;\\n  /** Seeds the random number generator. */\\n  seedRandom(value: i64): void;\\n  /** Multiplies a floating point `x` by 2 raised to power exp `n`. */\\n  scalbn(x: T, n: i32): T;\\n  /** Returns the floating-point remainder of `x / y` (rounded towards zero). */\\n  mod(x: T, y: T): T;\\n  /** Returns the floating-point remainder of `x / y` (rounded to nearest). */\\n  rem(x: T, y: T): T;\\n  /** Returns sin and cos simultaneously for same angle. Results stored to `sincos_s32/64` and `sincos_c32/64` globals */\\n  sincos(x: T): void;\\n  /** Returns 2 raised to the given power x. Equivalent to 2 ** x. */\\n  exp2(x: T): T;\\n}\\n\\n/** Double precision math imported from JavaScript. */\\ndeclare const JSMath: IMath<f64>;\\n/** Double precision math implemented natively. */\\ndeclare const NativeMath: INativeMath<f64>;\\n/** Single precision math implemented natively. */\\ndeclare const NativeMathf: INativeMath<f32>;\\n/** Alias of {@link NativeMath} or {@link JSMath} respectively. Defaults to `NativeMath`. */\\ndeclare const Math: IMath<f64>;\\n/** Alias of {@link NativeMathf} or {@link JSMath} respectively. Defaults to `NativeMathf`. */\\ndeclare const Mathf: IMath<f32>;\\n\\n/** Environmental abort function. */\\ndeclare function abort(msg?: string | null, fileName?: string | null, lineNumber?: i32, columnNumber?: i32): never;\\n/** Environmental tracing function. */\\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\\n/** Environmental seeding function. */\\ndeclare function seed(): f64;\\n\\n/** Node-like process. */\\ndeclare namespace process {\\n  /** String representing the CPU architecture for which the binary was compiled. Either `wasm32` or `wasm64`. */\\n  export const arch: string;\\n  /** String representing the operating system platform for which the binary was compiled. Always `wasm`. */\\n  export const platform: string;\\n  /** Array of command line arguments passed to the binary upon instantiation. */\\n  export const argv: string[];\\n  /** Map of variables in the binary's user environment. */\\n  export const env: Map<string,string>;\\n  /** Terminates the process with either the given exit code, or `process.exitCode` if omitted. */\\n  export function exit(code?: i32): void;\\n  /** `exit()`\u2019s default value. Defaults to `0`. */\\n  export let exitCode: i32;\\n  /** Stream connected to `stdin` (fd `0`). */\\n  export const stdin: ReadableStream;\\n  /** Stream connected to `stdout` (fd `1`). */\\n  export const stdout: WritableStream;\\n  /** Stream connected to `stderr` (fd `2`). */\\n  export const stderr: WritableStream;\\n  /** Obtains the system's current time of day, in milliseconds since Unix epoch. */\\n  export function time(): i64;\\n  /** Obtains the system's monotonic high resolution time, in nanoseconds since an arbitrary time in the past. */\\n  export function hrtime(): u64;\\n\\n  interface Stream {\\n    /** Closes the stream. Throws if already closed or if the stream cannot be closed. */\\n    close(): void;\\n  }\\n  interface ReadableStream extends Stream {\\n    /** Reads available data from the stream, into `buffer` at offset `offset`, returning the number of bytes read. */\\n    read(buffer: ArrayBuffer, offset?: isize): i32;\\n  }\\n  interface WritableStream extends Stream {\\n    /** Writes string or buffer to the stream. */\\n    write<T extends string | ArrayBuffer>(data: T): void;\\n  }\\n}\\n\\n/** Browser-like console. */\\ndeclare namespace console {\\n  /** Logs `message` to console if `assertion` is false-ish. */\\n  export function assert<T>(assertion: T, message?: string): void;\\n  /** Outputs `message` to the console. */\\n  export function log(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Debug:\\\". */\\n  export function debug(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Info:\\\". */\\n  export function info(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Warning:\\\". */\\n  export function warn(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Error:\\\". */\\n  export function error(message?: string): void;\\n  /** Starts a new timer using the specified `label`. */\\n  export function time(label?: string): void;\\n  /** Logs the current value of a timer previously started with `console.time`. */\\n  export function timeLog(label?: string): void;\\n  /** Logs the current value of a timer previously started with `console.time` and discards the timer. */\\n  export function timeEnd(label?: string): void;\\n}\\n\\n/** Browser-like crypto utilities. */\\ndeclare namespace crypto {\\n  /** Fills `array` with cryptographically strong random values. */\\n  export function getRandomValues(array: Uint8Array): void;\\n}\\n\\n// Decorators\\n\\ninterface TypedPropertyDescriptor<T> {\\n  configurable?: boolean;\\n  enumerable?: boolean;\\n  writable?: boolean;\\n  value?: T;\\n  get?(): T;\\n  set?(value: T): void;\\n}\\n\\ntype Constructor =\\n  (new (...args: any[]) => unknown)\\n  | (abstract new (...args: any[]) => unknown);\\n\\n/** Annotates a method as a binary operator overload for the specified `token`. */\\ndeclare function operator(token:\\n  \\\"[]\\\" | \\\"[]=\\\" | \\\"{}\\\" | \\\"{}=\\\" | \\\"==\\\" | \\\"!=\\\" | \\\">\\\" | \\\"<\\\" | \\\"<=\\\" | \\\">=\\\" |\\n  \\\">>\\\" | \\\">>>\\\" | \\\"<<\\\" |  \\\"&\\\"  | \\\"|\\\"  | \\\"^\\\"  | \\\"+\\\" | \\\"-\\\" | \\\"*\\\"  | \\\"**\\\" | \\\"/\\\"  | \\\"%\\\"\\n): (\\n  target: any,\\n  propertyKey: string,\\n  descriptor: TypedPropertyDescriptor<any>\\n) => TypedPropertyDescriptor<any> | void;\\n\\ndeclare namespace operator {\\n  /** Annotates a method as a binary operator overload for the specified `token`. */\\n  export function binary(token:\\n    \\\"[]\\\" | \\\"[]=\\\" | \\\"{}\\\" | \\\"{}=\\\" | \\\"==\\\" | \\\"!=\\\" | \\\">\\\" | \\\"<\\\" | \\\"<=\\\" | \\\">=\\\" |\\n    \\\">>\\\" | \\\">>>\\\" | \\\"<<\\\" |  \\\"&\\\"  | \\\"|\\\"  | \\\"^\\\"  | \\\"+\\\" | \\\"-\\\" | \\\"*\\\"  | \\\"**\\\" | \\\"/\\\"  | \\\"%\\\"\\n  ): (\\n    target: any,\\n    propertyKey: string,\\n    descriptor: TypedPropertyDescriptor<any>\\n  ) => TypedPropertyDescriptor<any> | void;\\n  /** Annotates a method as an unary prefix operator overload for the specified `token`. */\\n  export function prefix(token: \\\"!\\\" | \\\"~\\\" | \\\"+\\\" | \\\"-\\\" | \\\"++\\\" | \\\"--\\\"): (\\n    target: any,\\n    propertyKey: string,\\n    descriptor: TypedPropertyDescriptor<any>\\n  ) => TypedPropertyDescriptor<any> | void;\\n  /** Annotates a method as an unary postfix operator overload for the specified `token`. */\\n  export function postfix(token: \\\"++\\\" | \\\"--\\\"): (\\n    target: any,\\n    propertyKey: string,\\n    descriptor: TypedPropertyDescriptor<any>\\n  ) => TypedPropertyDescriptor<any> | void;\\n}\\n\\n/** Annotates an element as a program global. */\\ndeclare function global(...args: any[]): any;\\n\\n/** Annotates a class as being unmanaged with limited capabilities. */\\ndeclare function unmanaged(constructor: Constructor): void;\\n\\n/** Annotates a class as being final / non-derivable. */\\ndeclare function final(constructor: Constructor): void;\\n\\n/** Annotates a method, function or constant global as always inlined. */\\ndeclare function inline(...args: any[]): any;\\n\\n/** Annotates a method, function or constant global as unsafe. */\\ndeclare function unsafe(...args: any[]): any;\\n\\n/** Annotates an explicit external name of a function or global. */\\ndeclare function external(name: string): any;\\ndeclare function external(moduleName: string, name: string): any;\\ndeclare namespace external {\\n  function js(code: string): any;\\n}\\n\\n/** Annotates a global for lazy compilation. */\\ndeclare function lazy(...args: any[]): any;\\n\",\n  \"portable\": \"/**\\n * Environment definitions for compiling AssemblyScript to JavaScript using tsc.\\n *\\n * Note that semantic differences require additional explicit conversions for full compatibility.\\n * For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\\n * result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\\n *\\n * Note that i64's are not portable (JS numbers are IEEE754 doubles with a maximum safe integer\\n * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example\\n * {@link glue/js/i64} respectively {@link glue/wasm/i64}.\\n *\\n * @module std/portable\\n *//***/\\n\\n// Types\\n\\ndeclare type bool = boolean;\\ndeclare type i8 = number;\\ndeclare type i16 = number;\\ndeclare type i32 = number;\\ndeclare type isize = number;\\ndeclare type u8 = number;\\ndeclare type u16 = number;\\ndeclare type u32 = number;\\ndeclare type usize = number;\\ndeclare type f32 = number;\\ndeclare type f64 = number;\\n\\n/** Special type evaluating the indexed access index type. */\\ndeclare type indexof<T extends unknown[]> = keyof T;\\n/** Special type evaluating the indexed access value type. */\\ndeclare type valueof<T extends unknown[]> = T[0];\\n\\n// Compiler hints\\n\\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\\ndeclare const ASC_TARGET: i32;\\n/** Runtime type. 0 = Stub, 1 = Minimal, 2 = Incremental. */\\ndeclare const ASC_RUNTIME: i32;\\n/** Provided noAssert option. */\\ndeclare const ASC_NO_ASSERT: bool;\\n/** Provided memoryBase option. */\\ndeclare const ASC_MEMORY_BASE: i32;\\n/** Provided optimizeLevel option. */\\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\\n/** Provided shrinkLevel option. */\\ndeclare const ASC_SHRINK_LEVEL: i32;\\n/** Whether the mutable global feature is enabled. */\\ndeclare const ASC_FEATURE_MUTABLE_GLOBAL: bool;\\n/** Whether the sign extension feature is enabled. */\\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\\n\\n// Builtins\\n\\n/** Performs the sign-agnostic reverse bytes **/\\ndeclare function bswap<T = i32 | u32 | isize | usize>(value: T): T;\\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\\ndeclare function clz<T = i32>(value: T): T;\\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\\ndeclare function ctz<T = i32>(value: T): T;\\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\\ndeclare function popcnt<T = i32>(value: T): T;\\n/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\\ndeclare function rotl<T = i32>(value: T, shift: T): T;\\n/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\\ndeclare function rotr<T = i32>(value: T, shift: T): T;\\n/** Computes the absolute value of an integer or float. */\\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\\ndeclare function ceil<T = f32 | f64>(value: T): T;\\n/** Performs the floor operation on a 32-bit or 64-bit float. */\\ndeclare function floor<T = f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\\ndeclare function nearest<T = f32 | f64>(value: T): T;\\n/** Selects one of two pre-evaluated values depending on the condition. */\\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\\n/** Calculates the square root of a 32-bit or 64-bit float. */\\ndeclare function sqrt<T = f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\\ndeclare function trunc<T = f32 | f64>(value: T): T;\\n/** Emits an unreachable operation that results in a runtime error when executed. */\\ndeclare function unreachable(): any; // sic\\n\\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\\ndeclare function changetype<T>(value: any): T;\\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\\ndeclare function unchecked<T>(value: T): T;\\n/** Tests if the specified value is a valid integer. Can't distinguish an integer from an integral float. */\\ndeclare function isInteger(value: any): value is number;\\n/** Tests if the specified value is a valid float. Can't distinguish a float from an integer. */\\ndeclare function isFloat(value: any): value is number;\\n/** Tests if the specified value is of a nullable reference type. */\\ndeclare function isNullable(value: any): bool;\\n/** Tests if the specified value is of a reference type. */\\ndeclare function isReference(value: any): value is object | string;\\n/** Tests if the specified value is of a function type */\\ndeclare function isFunction(value: any): value is Function;\\n/** Tests if the specified value can be used as a string. */\\ndeclare function isString(value: any): value is string | String;\\n/** Tests if the specified value can be used as an array. */\\ndeclare function isArray(value: any): value is Array<any>;\\n/** Tests if the specified type *or* expression can be used as an array like object. */\\ndeclare function isArrayLike(value: any): value is ArrayLike<any>;\\n/** Tests if the specified expression resolves to a defined element. */\\ndeclare function isDefined(expression: any): bool;\\n/** Tests if the specified expression evaluates to a constant value. */\\ndeclare function isConstant(expression: any): bool;\\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\\ndeclare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?\\n/** Parses an integer string to a 64-bit float. */\\ndeclare function parseInt(str: string, radix?: i32): f64;\\n/** Parses a floating point string to a 64-bit float. */\\ndeclare function parseFloat(str: string): f64;\\n/** Returns the 64-bit floating-point remainder of `x/y`. */\\ndeclare function fmod(x: f64, y: f64): f64;\\n/** Returns the 32-bit floating-point remainder of `x/y`. */\\ndeclare function fmodf(x: f32, y: f32): f32;\\n\\n/** Converts any other numeric value to an 8-bit signed integer. */\\ndeclare function i8(value: any): i8;\\ndeclare namespace i8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i8;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): i8;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): i8;\\n  /** Parses a string as an i8. */\\n  export function parse(value: string, radix?: i32): i8;\\n}\\n/** Converts any other numeric value to a 16-bit signed integer. */\\ndeclare function i16(value: any): i16;\\ndeclare namespace i16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i16;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): i16;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): i16;\\n  /** Parses a string as an i16. */\\n  export function parse(value: string, radix?: i32): i16;\\n}\\n/** Converts any other numeric value to a 32-bit signed integer. */\\ndeclare function i32(value: any): i32;\\ndeclare namespace i32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i32;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): i32;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): i32;\\n  /** Parses a string as an i32. */\\n  export function parse(value: string, radix?: i32): i32;\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\\ndeclare function isize(value: any): isize;\\ndeclare namespace isize {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: isize;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: isize;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): isize;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): isize;\\n  /** Parses a string as an iszie. */\\n  export function parse(value: string, radix?: i32): isize;\\n}\\n/** Converts any other numeric value to an 8-bit unsigned integer. */\\ndeclare function u8(value: any): u8;\\ndeclare namespace u8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u8;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): u8;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): u8;\\n  /** Parses a string as an u8. */\\n  export function parse(value: string, radix?: i32): u8;\\n}\\n/** Converts any other numeric value to a 16-bit unsigned integer. */\\ndeclare function u16(value: any): u16;\\ndeclare namespace u16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u16;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): u16;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): u16;\\n  /** Parses a string as an u16. */\\n  export function parse(value: string, radix?: i32): u16;\\n}\\n/** Converts any other numeric value to a 32-bit unsigned integer. */\\ndeclare function u32(value: any): u32;\\ndeclare namespace u32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u32;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): u32;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): u32;\\n  /** Parses a string as an u32. */\\n  export function parse(value: string, radix?: i32): u32;\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\\ndeclare function usize(value: any): isize;\\ndeclare namespace usize {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: usize;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: usize;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): usize;\\n  /** Parses a string as an integer. */\\n  export function parseInt(string: string, radix?: i32): usize;\\n  /** Parses a string as an usize. */\\n  export function parse(value: string, radix?: i32): usize;\\n}\\n/** Converts any other numeric value to a 1-bit unsigned integer. */\\ndeclare function bool(value: any): bool;\\ndeclare namespace bool {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: bool;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: bool;\\n  /** Parses a string as a bool. */\\n  export function parse(value: string): bool;\\n}\\n/** Converts any other numeric value to a 32-bit float. */\\ndeclare function f32(value: any): f32;\\ndeclare namespace f32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f32;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f32;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f32;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f32;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f32;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f32;\\n  /** Not a number value. */\\n  /* eslint no-shadow-restricted-names: \\\"off\\\" */\\n  export const NaN: f32;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f32;\\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\\n  export function isNaN(value: f32): bool;\\n  /** Returns true if passed value is finite. */\\n  export function isFinite(value: f32): bool;\\n  /** Returns true if the value passed is a safe integer. */\\n  export function isSafeInteger(value: f32): bool;\\n  /** Returns true if the value passed is an integer, false otherwise. */\\n  export function isInteger(value: f32): bool;\\n  /** Converts a string to a floating-point number. */\\n  export function parseFloat(string: string): f32;\\n  /** Parses a string as an integer and convert to an f32. */\\n  export function parseInt(string: string, radix?: i32): f32;\\n  /** Parses a string as an f32. */\\n  export function parse(value: string): f32;\\n}\\n/** Converts any other numeric value to a 64-bit float. */\\ndeclare function f64(value: any): f64;\\ndeclare namespace f64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f64;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f64;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f64;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f64;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f64;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f64;\\n  /** Not a number value. */\\n  /* eslint no-shadow-restricted-names: \\\"off\\\" */\\n  export const NaN: f64;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f64;\\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\\n  export function isNaN(value: f32): bool;\\n  /** Returns true if passed value is finite. */\\n  export function isFinite(value: f32): bool;\\n  /** Returns true if the value passed is a safe integer. */\\n  export function isSafeInteger(value: f64): bool;\\n  /** Returns true if the value passed is an integer, false otherwise. */\\n  export function isInteger(value: f64): bool;\\n  /** Converts a string to a floating-point number. */\\n  export function parseFloat(string: string): f64;\\n  /** Parses a string as an integer and convert to an f64. */\\n  export function parseInt(string: string, radix?: i32): f64;\\n  /** Parses a string as an f64. */\\n  export function parse(value: string): f64;\\n}\\n\\n// Standard library\\n\\ndeclare const Mathf: typeof Math;\\ndeclare const JSMath: typeof Math;\\n\\ndeclare interface StringConstructor {\\n  /** Equivalent to calling `String.fromCharCode` with multiple arguments. */\\n  fromCharCodes(arr: i32[]): string;\\n  /** Equivalent to calling `String.fromCodePoint` with multiple arguments. */\\n  fromCodePoints(arr: i32[]): string;\\n}\\n\\ndeclare interface String {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): string;\\n}\\n\\n/** Annotates a class as being unmanaged with limited capabilities. */\\ndeclare function unmanaged(constructor: Function): void;\\n\\n/** Environmental tracing function. */\\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\\n\\ndeclare interface Array<T> {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): T;\\n  /** Returns an index start searching from the end in the array */\\n  findLastIndex(callbackfn: (value: T, index: i32, self: Array<T>) => bool): i32;\\n}\\n\\ndeclare interface Int8ArrayConstructor {\\n  /** Equivalent to calling `new Int8Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;\\n}\\n\\ndeclare interface Int8Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): i8;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): i32;\\n}\\n\\ndeclare interface Uint8ArrayConstructor {\\n  /** Equivalent to calling `new Uint8Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;\\n}\\n\\ndeclare interface Uint8Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u8;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): i32;\\n}\\n\\ndeclare interface Uint8ClampedArrayConstructor {\\n  /** Equivalent to calling `new Uint8ClampedArray` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;\\n}\\n\\ndeclare interface Uint8ClampedArray {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u8;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32;\\n}\\n\\ndeclare interface Int16ArrayConstructor {\\n  /** Equivalent to calling `new Int16Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;\\n}\\n\\ndeclare interface Int16Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): i16;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): i32;\\n}\\n\\ndeclare interface Uint16ArrayConstructor {\\n  /** Equivalent to calling `new Uint16Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;\\n}\\n\\ndeclare interface Uint16Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u16;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): i32;\\n}\\n\\ndeclare interface Int32ArrayConstructor {\\n  /** Equivalent to calling `new Int32Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;\\n}\\n\\ndeclare interface Int32Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): i32;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): i32;\\n}\\n\\ndeclare interface Uint32ArrayConstructor {\\n  /** Equivalent to calling `new Uint32Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;\\n}\\n\\ndeclare interface Uint32Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u32;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): i32;\\n}\\n\\ndeclare interface Float32ArrayConstructor {\\n  /** Equivalent to calling `new Float32Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;\\n}\\n\\ndeclare interface Float32Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): f32;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): i32;\\n}\\n\\ndeclare interface Float64ArrayConstructor {\\n  /** Equivalent to calling `new Float64Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;\\n}\\n\\ndeclare interface Float64Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): f64;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): i32;\\n}\\n\\n// FIXME: remove\\ndeclare function offsetof<T>(fieldName?: string): usize;\\ndeclare function idof<T>(): u32;\\n\"\n};\n", "export * from \"binaryen\";\nexport { default } from \"binaryen\";\n"],
  "mappings": "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CACd,SAAY,WACZ,YAAe,wCACf,KAAQ,IACR,QAAW,EACb,EACA,eAAkB,CAChB,SAAY,WACZ,YAAe,0CACf,KAAQ,IACR,QAAW,EACb,EACA,cAAiB,CACf,SAAY,WACZ,YAAe,yCACf,KAAQ,IACR,QAAW,CACb,EACA,cAAiB,CACf,SAAY,WACZ,YAAe,yCACf,KAAQ,IACR,QAAW,CACb,EACA,aAAgB,CACd,SAAY,WACZ,YAAe,oDACf,KAAQ,IACR,QAAW,EACb,EACA,iBAAoB,CAClB,SAAY,WACZ,YAAe,2DACf,KAAQ,IACR,QAAW,EACb,EACA,YAAe,CACb,SAAY,WACZ,YAAe,+CACf,KAAQ,IACR,QAAW,EACb,EACA,YAAe,CACb,SAAY,WACZ,YAAe,yCACf,KAAQ,IACR,QAAW,EACb,EACA,YAAe,CACb,SAAY,WACZ,YAAe,CACb,8DACA,iEACA,yCACF,EACA,KAAQ,GACV,EACA,QAAW,CACT,SAAY,WACZ,YAAe,CACb,2DACA,GACA,gDACA,yDACA,mDACA,wDACA,EACF,EACA,KAAQ,IACR,QAAW,aACb,EACA,cAAiB,CACf,SAAY,WACZ,YAAe,CACb,qEACA,oEACF,EACA,KAAQ,IACR,QAAW,EACb,EACA,UAAa,CACX,SAAY,WACZ,YAAe,CACb,6DACA,4DACA,yDACF,EACA,QAAW,EACX,KAAQ,GACV,EACA,OAAU,CACR,SAAY,WACZ,YAAe,CACb,0DACA,GACA,wDACA,kDACA,uDACA,iDACA,+CACA,gDACA,EACF,EACA,oBAAuB,CACrB,2CACA,6CACA,0CACA,4CACA,kDACF,EACA,KAAQ,IACR,kBAAqB,SACvB,EACA,QAAW,CACT,SAAY,WACZ,YAAe,CACb,0DACA,GACA,2DACA,iDACA,0DACA,+CACA,EACF,EACA,KAAQ,IACR,kBAAqB,QACvB,EACA,IAAO,CACL,SAAY,WACZ,YAAe,CACb,8DACA,4DACA,oDACF,EACA,KAAQ,IACR,MAAS,GACX,EACA,eAAkB,CAChB,SAAY,WACZ,YAAe,+CACf,QAAW,EACX,KAAQ,GACV,EACA,WAAc,CACZ,SAAY,UACZ,YAAe,oDA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACT,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,QAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,oBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACrB,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAChB,gBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACjB,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,OAAU;AAAA;AAAA,EACV,QAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,KAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACR,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,MAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACT,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACP,KAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACR,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACP,iBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAClB,iBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAClB,gBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACjB,kBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACnB,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,MAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACT,WAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACd,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACP,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAChB,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACd,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,WAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,OAAU;AAAA;AAAA;AAAA;AAAA,CACZ,EACaC,GAAkB,CAC7B,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": ["fs_exports", "__export", "promises", "init_fs", "__esmMin", "module_exports", "__export", "createRequire", "path", "init_module", "__esmMin", "process_exports", "__export", "argv", "cwd", "exit", "hrtime", "platform", "umask", "code", "previousTimestamp", "clocktime", "performanceNow", "performance", "seconds", "nanoseconds", "init_process", "__esmMin", "path_exports", "__export", "basename", "delimiter", "dirname", "extname", "format", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "win32", "assertPath", "path", "normalizeStringPosix", "allowAboveRoot", "res", "lastSegmentLength", "lastSlash", "dots", "code", "i", "lastSlashIndex", "_format", "pathObject", "dir", "base", "resolvedPath", "resolvedAbsolute", "cwd", "trailingSeparator", "joined", "arg", "from", "to", "fromStart", "fromEnd", "fromLen", "toStart", "toEnd", "toLen", "length", "lastCommonSep", "fromCode", "toCode", "out", "hasRoot", "end", "matchedSlash", "ext", "start", "extIdx", "firstNonSlashEnd", "startDot", "startPart", "preDotState", "ret", "init_path", "__esmMin", "init_process", "url_exports", "__export", "pathToFileURL", "encodePathChars", "filepath", "resolved", "resolve", "sep", "url", "init_url", "__esmMin", "init_path", "cli_exports", "__export", "Stats", "checkDiagnostics", "compileString", "configToArguments", "createMemoryStream", "defaultOptimizeLevel", "defaultShrinkLevel", "definitionFiles", "libraryFiles", "libraryPrefix", "main", "options", "tscOptions", "version", "isNode", "fs", "module", "path", "process", "url", "proc", "isCI", "GRAY", "RED", "GREEN", "YELLOW", "BLUE", "MAGENTA", "CYAN", "WHITE", "RESET", "Colors", "stream", "text", "stdoutColors", "stderrColors", "Diff", "oldString", "newString", "options", "callback", "self", "done", "value", "newLen", "oldLen", "editLength", "maxEditLength", "bestPath", "oldPos", "execEditLength", "diagonalPath", "basePath", "addPath", "removePath", "_oldPos", "canAdd", "canRemove", "clonePath", "buildValues", "exec", "ret", "components", "added", "removed", "last", "newPos", "commonCount", "left", "right", "array", "chars", "diff", "useLongestToken", "componentPos", "componentLen", "component", "tmp", "i", "oldValue", "lastComponent", "path", "characterDiff", "extendedWordChars", "reWhitespace", "wordDiff", "Diff", "left", "right", "value", "tokens", "i", "lineDiff", "Diff", "value", "retLines", "linesAndNewlines", "line", "sentenceDiff", "Diff", "value", "cssDiff", "Diff", "value", "_typeof", "obj", "objectPrototypeToString", "jsonDiff", "Diff", "lineDiff", "value", "_this$options", "undefinedReplacement", "_this$options$stringi", "stringifyReplacer", "k", "v", "canonicalize", "left", "right", "canonicalize", "obj", "stack", "replacementStack", "replacer", "key", "i", "canonicalizedObj", "objectPrototypeToString", "_typeof", "sortedKeys", "_key", "arrayDiff", "Diff", "value", "utf8Length", "string", "len", "i", "k", "c", "utf8Read", "buffer", "start", "end", "parts", "chunk", "t", "utf8Write", "offset", "c1", "c2", "utf8", "require", "module", "parse", "argv", "config", "propagateDefaults", "options", "unknown", "args", "trailing", "aliases", "key", "option", "alias", "i", "k", "arg", "match", "addDefaults", "help", "indent", "padding", "eol", "sbCategories", "sbOther", "text", "sb", "line", "hasCategories", "category", "stdoutColors", "sanitizeValue", "value", "type", "v", "merge", "currentOptions", "parentOptions", "parentBaseDir", "mergedOptions", "mutuallyExclusive", "isPath", "useNodeResolution", "cliOnly", "currentValue", "parentValue", "exclude", "resolvePath", "normalizePath", "p", "parsed", "path", "baseDir", "defaultValue", "version", "options", "libraryPrefix", "libraryFiles", "definitionFiles", "binaryen_exports", "__export", "default", "__reExport", "binaryen_star", "assemblyscriptJS", "assemblyscript", "wasmPos", "process", "wasmPath", "url", "require", "module", "WIN", "EOL", "SEP", "extension", "extension_d", "extension_re", "extension_re_except_d", "toUpperSnakeCase", "str", "isNonEmptyString", "value", "version", "options", "libraryPrefix", "libraryFiles", "definitionFiles", "defaultOptimizeLevel", "defaultShrinkLevel", "configToArguments", "argv", "key", "val", "opt", "compileString", "sources", "config", "output", "result", "main", "name", "contents", "stats", "Stats", "statsBegin", "bundleMinorVersion", "bundleMajorVersion", "bundlePatchVersion", "versionParts", "stdout", "createMemoryStream", "stderr", "readFile", "readFileNode", "writeFile", "writeFileNode", "listFiles", "listFilesNode", "optionsResult", "parse", "opts", "stdoutColors", "Colors", "stderrColors", "unknownOpts", "arg", "trailingArgv", "binaryenModule", "prepareResult", "error", "baseDir", "path", "configPath", "resolvePath", "configFile", "configDir", "getConfig", "configHasEntries", "out", "colors", "help", "fs", "seenAsconfig", "target", "targetOptions", "merge", "generalOptions", "entry", "addDefaults", "unique", "values", "program", "runtime", "uncheckedBehavior", "compilerOptions", "aliases", "i", "k", "part", "p", "alias", "features", "flag", "optimizeLevel", "shrinkLevel", "transforms", "transformArgs", "filename", "resolved", "transform", "e1", "e", "default", "applyTransform", "args", "start", "libPath", "begin", "customLibDirs", "lib", "libDir", "libFiles", "libText", "packageBases", "getFile", "internalPath", "dependeePath", "sourceText", "sourcePath", "plainName", "indexName", "match", "packageName", "filePath", "basePath", "paths", "parts", "currentDir", "getBacklog", "parseBacklog", "backlog", "files", "dependee", "file", "numErrors", "checkDiagnostics", "err", "runtimeName", "runtimePath", "runtimeText", "code", "crash", "isValid", "debugInfo", "converge", "zeroFilledMemory", "runPasses", "pass", "last", "next", "pending", "bindings", "hasStdout", "hasOutFile", "hasTextFile", "hasOutput", "hasFileOutput", "basepath", "basename", "sourceMapURL", "wasm", "writeStdout", "map", "text", "bindingsEsm", "bindingsRaw", "source", "dirPath", "dirname", "stage", "BAR", "isObject", "location", "targets", "disableWarning", "reportDiagnostic", "useColors", "diagnostic", "isDisabledWarning", "wrapRange", "range", "wrapSource", "hrtime", "formatTime", "time", "keys", "times", "counts", "keysLen", "current", "timesLen", "countsLen", "count", "totalLen", "header", "totalTime", "readsWrites", "allocBuffer", "len", "fn", "stream", "chunk", "buffer", "utf8", "offset", "tscOptions"]
}
